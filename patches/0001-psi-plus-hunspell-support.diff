--- git.orig/psi.qc
+++ git/psi.qc
@@ -41,6 +41,7 @@
   <dep type='xss'/>
   <dep type='aspell'/>
   <dep type='enchant'/>
+  <dep type='hunspell'/>
   <dep type='spell'>
     <required/>
   </dep>
--- git.orig/qcm/hunspell.qcm
+++ git/qcm/hunspell.qcm
@@ -0,0 +1,99 @@
+/*
+-----BEGIN QCMOD-----
+name: hunspell
+arg: with-hunspell-inc=[path],Path to Hunspell include files
+arg: with-hunspell-lib=[path],Path to Hunspell library files
+-----END QCMOD-----
+*/
+
+#define QC_HUNSPELL
+bool qc_hunspell_have = false;
+QStringList qc_hunspell_defs;
+QStringList qc_hunspell_incs;
+QStringList qc_hunspell_libs;
+
+//----------------------------------------------------------------------------
+// qc_hunspell
+//----------------------------------------------------------------------------
+class qc_hunspell : public ConfObj
+{
+public:
+	qc_hunspell(Conf *c) : ConfObj(c) {}
+	QString name() const { return "hunspell"; }
+	QString shortname() const { return "hunspell"; }
+
+	// no output
+	QString checkString() const { return QString(); }
+
+	bool exec()
+	{
+		// on mac, always use built-in spell check
+#ifdef Q_OS_MAC
+		return false;
+#else
+		qc_hunspell_have = false;
+		qc_hunspell_defs.clear();
+		qc_hunspell_incs.clear();
+		qc_hunspell_libs.clear();
+
+		QString s;
+
+#ifdef Q_OS_WIN
+		s = conf->getenv("QC_WITH_HUNSPELL_INC");
+		if(!s.isEmpty()) {
+			if(!conf->checkHeader(s, "hunspell.hxx")) {
+				conf->debug("Hunspell includes not found!");
+				return false;
+			}
+			qc_hunspell_incs += s;
+		}
+		else
+			return false;
+
+		QString a_lib = conf->getenv("QC_WITH_HUNSPELL_LIB");
+		if(a_lib.isEmpty())
+			return false;
+
+		QStringList libnames;
+		libnames += "hunspell-1.3";
+		libnames += "hunspell";
+
+		bool success;
+		QString libname_success;
+		foreach(const QString &libname, libnames) {
+			conf->debug(QString("Trying %1").arg(libname));
+			if(conf->checkLibrary(a_lib, libname)) {
+				success = true;
+				libname_success = libname;
+				break;
+			}
+		}
+
+		if(!success)
+			return false;
+
+		qc_hunspell_defs += "HAVE_HUNSPELL";
+		qc_hunspell_libs += QString("-L") + a_lib;
+		qc_hunspell_libs += QString("-l") + libname_success;
+		qc_hunspell_have = true;
+#else
+		qc_hunspell_have = false;
+		qc_hunspell_defs.clear();
+		qc_hunspell_incs.clear();
+		qc_hunspell_libs.clear();
+
+		QStringList incs;
+		QString version, libs, other;
+		if(!conf->findPkgConfig("hunspell", VersionMin, "1.3.0", &version, &incs, &libs, &other))
+                        return false;
+
+		qc_hunspell_defs += "HAVE_HUNSPELL";
+		qc_hunspell_incs += incs;
+		qc_hunspell_libs += libs;
+		qc_hunspell_have = true;
+#endif
+
+		return true;
+#endif
+	}
+};
--- git.orig/qcm/spell.qcm
+++ git/qcm/spell.qcm
@@ -47,6 +47,16 @@ public:
 			have = true;
 		}
 #endif
+#ifdef QC_HUNSPELL
+		if(!have && qc_hunspell_have)
+		{
+			defs = qc_hunspell_defs;
+			incs = qc_hunspell_incs;
+			libs = qc_hunspell_libs;
+			engine = "hunspell";
+			have = true;
+		}
+#endif
 
 		if(!have)
 			return true;
--- git.orig/src/libpsi/tools/spellchecker/hunspellchecker.cpp
+++ git/src/libpsi/tools/spellchecker/hunspellchecker.cpp
@@ -0,0 +1,179 @@
+/*
+ * hunspellchecker.cpp
+ *
+ * Copyright (C) 2015  Ili'nykh Sergey, Vitaly Tonkacheyev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * You can also redistribute and/or modify this program under the
+ * terms of the Psi License, specified in the accompanied COPYING
+ * file, as published by the Psi Project; either dated January 1st,
+ * 2005, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include "hunspellchecker.h"
+
+#include <QString>
+#include <QSet>
+#include <QDir>
+#include <QLibraryInfo>
+#include <QTextCodec>
+#include <QCoreApplication>
+#include <QLocale>
+//#include <QDebug>
+#include <hunspell/hunspell.hxx>
+#ifdef Q_OS_WIN
+#include "applicationinfo.h"
+#endif
+
+
+HunspellChecker::HunspellChecker()
+{
+	getDictPaths();
+	getSupportedLanguages();
+	foreach (const QLocale &locale, supportedLangs_) {
+		addLanguage(locale);
+	}
+}
+
+HunspellChecker::~HunspellChecker()
+{
+}
+
+void HunspellChecker::getDictPaths()
+{
+	if (dictPaths_.isEmpty()) {
+		QSet<QString> dictPathSet;
+		QString pathFromEnv = QString::fromLocal8Bit(qgetenv("MYSPELL_DICT_DIR"));
+		if (!pathFromEnv.isEmpty())
+			dictPathSet << pathFromEnv;
+#if defined(Q_OS_WIN)
+		dictPathSet << QCoreApplication::applicationDirPath() + QLatin1String("/myspell/dicts")
+			    << ApplicationInfo::homeDir(ApplicationInfo::DataLocation) + QLatin1String("/myspell/dicts");
+
+#elif defined(Q_OS_MAC)
+		dictPathSet << QLatin1String("/opt/local/share/myspell"); // MacPorts standard paths
+#else
+		dictPathSet << QLatin1String("/usr/share/myspell")
+			    << QLatin1String("/usr/share/hunspell")
+			    << QLatin1String("/usr/local/share/myspell")
+			    << QLatin1String("/usr/local/share/hunspell");
+#endif
+		dictPaths_ = dictPathSet.toList();
+	}
+}
+
+bool HunspellChecker::scanDictPaths(const QString &language, QFileInfo &aff , QFileInfo &dic)
+{
+	foreach (const QString &dictPath, dictPaths_) {
+		QDir dir(dictPath);
+		if (dir.exists()) {
+			QFileInfo affInfo(dir.filePath(language + QLatin1String(".aff")));
+			QFileInfo dicInfo(dir.filePath(language + QLatin1String(".dic")));
+			if (affInfo.isReadable() && dicInfo.isReadable()) {
+				aff = affInfo;
+				dic = dicInfo;
+				return true;
+			}
+		}
+	}
+	return false;
+}
+
+void HunspellChecker::getSupportedLanguages()
+{
+	QMap<QString,QLocale> retHash;
+	foreach (const QString &dictPath, dictPaths_) {
+		QDir dir(dictPath);
+		if (!dir.exists()) {
+			continue;
+		}
+		foreach (const QFileInfo &fi, dir.entryInfoList(QStringList() << "*.dic", QDir::Files)) {
+			QLocale locale(fi.baseName());
+			if (locale != QLocale::c())  {
+				retHash.insert(locale.nativeLanguageName()+locale.nativeCountryName(), locale);
+			}
+		}
+	}
+	supportedLangs_ = retHash.values();
+}
+
+void HunspellChecker::addLanguage(const QLocale &locale)
+{
+	QString language = locale.name();
+	QFileInfo aff, dic;
+	if (scanDictPaths(language, aff, dic)) {
+		LangItem li;
+		li.hunspell_ = new Hunspell(aff.absoluteFilePath().toLocal8Bit(),
+					    dic.absoluteFilePath().toLocal8Bit());
+		li.codec = QTextCodec::codecForName(QByteArray(li.hunspell_->get_dic_encoding()));
+		li.info.language = locale.language();
+		li.info.country = locale.country();
+		li.info.filename = dic.filePath();
+		languages_.append(li);
+	}
+}
+
+QList<QString> HunspellChecker::suggestions(const QString& word)
+{
+	foreach (const LangItem &li, languages_) {
+		char **result;
+		int sugNum = li.hunspell_->suggest(&result, li.codec->fromUnicode(word));
+		if (sugNum != 0) {
+			QStringList qtResult;
+			for (int i=0; i < sugNum; i++) {
+				qtResult << li.codec->toUnicode(result[i]);
+			}
+			return qtResult;
+		}
+	}
+	return QList<QString>();
+}
+
+bool HunspellChecker::isCorrect(const QString &word)
+{
+	foreach (const LangItem &li, languages_) {
+		if (li.hunspell_->spell(li.codec->fromUnicode(word)) != 0) {
+			return true;
+		}
+	}
+	return false;
+}
+bool HunspellChecker::add(const QString& word)
+{
+	if (!word.isEmpty()) {
+		QString trimmed_word = word.trimmed();
+		foreach (const LangItem &li, languages_) {
+			if (li.hunspell_->add(li.codec->fromUnicode(trimmed_word)) != 0) {
+				return true;
+			}
+		}
+	}
+	return false;
+}
+bool HunspellChecker::available() const
+{
+	foreach (const LangItem &li, languages_) {
+		if (li.hunspell_ != NULL) {
+			return true;
+		}
+	}
+	return false;
+}
+bool HunspellChecker::writable() const
+{
+	return false;
+}
--- git.orig/src/libpsi/tools/spellchecker/hunspellchecker.h
+++ git/src/libpsi/tools/spellchecker/hunspellchecker.h
@@ -0,0 +1,72 @@
+/*
+ * hunspellchecker.h
+ *
+ * Copyright (C) 2015  Ili'nykh Sergey, Vitaly Tonkacheyev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * You can also redistribute and/or modify this program under the
+ * terms of the Psi License, specified in the accompanied COPYING
+ * file, as published by the Psi Project; either dated January 1st,
+ * 2005, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+#ifndef HUNSPELLCHECKER_H
+#define HUNSPELLCHECKER_H
+
+#include <QList>
+#include <QString>
+#include <QLocale>
+#include <QFileInfo>
+#include <QStringList>
+#include "spellchecker.h"
+
+class Hunspell;
+class QTextCodec;
+
+class HunspellChecker : public SpellChecker
+{
+public:
+	HunspellChecker();
+	~HunspellChecker();
+	virtual QList<QString> suggestions(const QString&);
+	virtual bool isCorrect(const QString &word);
+	virtual bool add(const QString &word);
+	virtual bool available() const;
+	virtual bool writable() const;
+private:
+	struct DictInfo
+	{
+		QLocale::Language language;
+		QLocale::Country country;
+		QString filename;
+	};
+	struct LangItem {
+		Hunspell *hunspell_;
+		DictInfo info;
+		QTextCodec *codec;
+	};
+	void getSupportedLanguages();
+	void addLanguage(const QLocale &locale);
+	void getDictPaths();
+	bool scanDictPaths(const QString &language, QFileInfo &aff , QFileInfo &dic);
+
+private:
+	QList<LangItem> languages_;
+	QStringList dictPaths_;
+	QList<QLocale> supportedLangs_;
+};
+
+#endif // HUNSPELLCHECKER_H
--- git.orig/src/libpsi/tools/spellchecker/spellchecker.cpp
+++ git/src/libpsi/tools/spellchecker/spellchecker.cpp
@@ -34,6 +34,8 @@
 #include "enchantchecker.h"
 #elif defined(HAVE_ASPELL)
 #include "aspellchecker.h"
+#elif defined(HAVE_HUNSPELL)
+#include "hunspellchecker.h"
 #endif
 
 SpellChecker* SpellChecker::instance()
@@ -45,6 +47,8 @@ SpellChecker* SpellChecker::instance()
 		instance_ = new EnchantChecker();
 #elif defined(HAVE_ASPELL)
 		instance_ = new ASpellChecker();
+#elif defined(HAVE_HUNSPELL)
+		instance_ = new HunspellChecker();
 #else
 		instance_ = new SpellChecker();
 #endif
--- git.orig/src/libpsi/tools/spellchecker/spellchecker.pri
+++ git/src/libpsi/tools/spellchecker/spellchecker.pri
@@ -17,3 +17,8 @@ mac {
 	HEADERS += $$PWD/enchantchecker.h
 	SOURCES += $$PWD/enchantchecker.cpp
 }
+
+!mac:contains(DEFINES, HAVE_HUNSPELL) {
+	HEADERS += $$PWD/hunspellchecker.h
+	SOURCES += $$PWD/hunspellchecker.cpp
+}
\ В конце файла нет новой строки
