diff --git a/src/xmpp/xmpp-im/xmpp_discoinfotask.cpp b/src/xmpp/xmpp-im/xmpp_discoinfotask.cpp
index eb92cf4..4d0e75e 100644
--- a/src/xmpp/xmpp-im/xmpp_discoinfotask.cpp
+++ b/src/xmpp/xmpp-im/xmpp_discoinfotask.cpp
@@ -125,39 +125,8 @@ bool DiscoInfoTask::take(const QDomElement &x)
 		return false;
 
 	if(x.attribute("type") == "result") {
-		QDomElement q = queryTag(x);
-
-		DiscoItem item;
-
-		item.setJid( d->jid );
-		item.setNode( q.attribute("node") );
-
-		QStringList features;
-		DiscoItem::Identities identities;
-
-		for(QDomNode n = q.firstChild(); !n.isNull(); n = n.nextSibling()) {
-			QDomElement e = n.toElement();
-			if( e.isNull() )
-				continue;
-
-			if ( e.tagName() == "feature" ) {
-				features << e.attribute("var");
-			}
-			else if ( e.tagName() == "identity" ) {
-				DiscoItem::Identity id;
-
-				id.category = e.attribute("category");
-				id.name     = e.attribute("name");
-				id.type     = e.attribute("type");
-
-				identities.append( id );
-			}
-		}
-
-		item.setFeatures( features );
-		item.setIdentities( identities );
-
-		d->item = item;
+		d->item = DiscoItem::fromDiscoInfoResult(queryTag(x));
+		d->item.setJid( d->jid );
 
 		setSuccess(true);
 	}
diff --git a/src/xmpp/xmpp-im/xmpp_discoitem.cpp b/src/xmpp/xmpp-im/xmpp_discoitem.cpp
index 59e9551..3be33dc 100644
--- a/src/xmpp/xmpp-im/xmpp_discoitem.cpp
+++ b/src/xmpp/xmpp-im/xmpp_discoitem.cpp
@@ -18,35 +18,38 @@
  *
  */
 
+#include <QtXml>
+
 #include "xmpp_discoitem.h"
 
 using namespace XMPP;
 
-class DiscoItem::Private
+class XMPP::DiscoItemPrivate : public QSharedData
 {
 public:
-	Private()
+	DiscoItemPrivate()
 	{
-		action = None;
+		action = DiscoItem::None;
 	}
 
 	Jid jid;
 	QString name;
 	QString node;
-	Action action;
+	DiscoItem::Action action;
 
 	Features features;
-	Identities identities;
+	DiscoItem::Identities identities;
+	QList<XData> exts;
 };
 
 DiscoItem::DiscoItem()
 {
-	d = new Private;
+	d = new DiscoItemPrivate;
 }
 
 DiscoItem::DiscoItem(const DiscoItem &from)
 {
-	d = new Private;
+	d = new DiscoItemPrivate;
 	*this = from;
 }
 
@@ -58,13 +61,14 @@ DiscoItem & DiscoItem::operator= (const DiscoItem &from)
 	d->action = from.d->action;
 	d->features = from.d->features;
 	d->identities = from.d->identities;
+	d->exts = from.d->exts;
 
 	return *this;
 }
 
 DiscoItem::~DiscoItem()
 {
-	delete d;
+
 }
 
 AgentItem DiscoItem::toAgentItem() const
@@ -104,6 +108,127 @@ void DiscoItem::fromAgentItem(const AgentItem &ai)
 	setFeatures( ai.features() );
 }
 
+QString DiscoItem::capsHash(QCryptographicHash::Algorithm algo) const
+{
+	QStringList prep;
+	DiscoItem::Identities idents = d->identities;
+	qSort(idents);
+
+	foreach (const DiscoItem::Identity &id, idents) {
+		prep << QString("%1/%2/%3/%4<").arg(id.category, id.type, id.lang, id.name);
+	}
+
+	QStringList fl = d->features.list();
+	qSort(fl);
+	prep += fl;
+
+	QMap<QString,XData> forms;
+	foreach (const XData &xd, d->exts) {
+		if (xd.registrarType().isEmpty()) {
+			continue;
+		}
+		if (forms.contains(xd.registrarType())) {
+			return QString(); // ill-formed
+		}
+		forms.insert(xd.registrarType(), xd);
+	}
+	foreach (const XData &xd, forms.values()) {
+		prep << xd.registrarType();
+		QMap <QString, QStringList> values;
+		foreach (const XData::Field &f, xd.fields()) {
+			if (f.var() == QLatin1String("FORM_TYPE")) {
+				continue;
+			}
+			if (values.contains(f.var())) {
+				return QString(); // ill-formed
+			}
+			QStringList v = f.value();
+			if (v.isEmpty()) {
+				continue; // maybe it's media-element but xep-115 (1.5) and xep-232 (0.3) are not clear about that.
+			}
+			qSort(v);
+			values[f.var()] = v;
+		}
+		foreach (const QStringList &sl, values.values()) {
+			prep += sl;
+		}
+	}
+
+	QByteArray ba = (prep.join('<') + '<').toUtf8();
+	return QString::fromLatin1(QCryptographicHash::hash(ba, algo).toBase64());
+}
+
+DiscoItem DiscoItem::fromDiscoInfoResult(const QDomElement &q)
+{
+	DiscoItem item;
+
+	item.setNode( q.attribute("node") );
+
+	QStringList features;
+	DiscoItem::Identities identities;
+	QList<XData> extList;
+
+	for(QDomNode n = q.firstChild(); !n.isNull(); n = n.nextSibling()) {
+		QDomElement e = n.toElement();
+		if( e.isNull() )
+			continue;
+
+		if ( e.tagName() == "feature" ) {
+			features << e.attribute("var");
+		}
+		else if ( e.tagName() == "identity" ) {
+			DiscoItem::Identity id;
+
+			id.category = e.attribute("category");
+			id.type     = e.attribute("type");
+			id.lang     = e.attribute("lang");
+			id.name     = e.attribute("name");
+
+			identities.append( id );
+		}
+		else if (e.tagName() == QLatin1String("x") && e.namespaceURI() == QLatin1String("jabber:x:data")) {
+			XData form;
+			form.fromXml(e);
+			extList.append(form);
+		}
+	}
+
+	item.setFeatures( features );
+	item.setIdentities( identities );
+	item.setExtensions( extList );
+
+	return item;
+}
+
+QDomElement DiscoItem::toDiscoInfoResult(QDomDocument *doc) const
+{
+	QDomElement q = doc->createElementNS(QLatin1String("http://jabber.org/protocol/disco#info"), QLatin1String("query"));
+	q.setAttribute("node", d->node);
+
+	foreach (const Identity &id, d->identities) {
+		QDomElement idel = q.appendChild(doc->createElement(QLatin1String("identity"))).toElement();
+		idel.setAttribute("category", id.category);
+		idel.setAttribute("type", id.type);
+		if (!id.lang.isEmpty()) {
+			idel.setAttribute("lang", id.lang);
+		}
+		if (!id.name.isEmpty()) {
+			idel.setAttribute("name", id.name);
+		}
+	}
+
+	foreach (const QString &f, d->features.list()) {
+		QDomElement fel = q.appendChild(doc->createElement(QLatin1String("feature"))).toElement();
+		fel.setAttribute("var", f);
+	}
+
+	foreach (const XData &f, d->exts) {
+		q.appendChild(f.toXml(doc));
+	}
+
+	return q;
+}
+
 const Jid &DiscoItem::jid() const
 {
 	return d->jid;
@@ -167,6 +292,15 @@ void DiscoItem::setIdentities(const Identities &i)
 		setName( i.first().name );
 }
 
+const QList<XData> &DiscoItem::extensions() const
+{
+	return d->exts;
+}
+
+void DiscoItem::setExtensions(const QList<XData> &extlist)
+{
+	d->exts = extlist;
+}
 
 DiscoItem::Action DiscoItem::string2action(QString s)
 {
@@ -197,3 +331,19 @@ QString DiscoItem::action2string(Action a)
 }
 
 
+
+bool XMPP::operator<(const DiscoItem::Identity &a, const DiscoItem::Identity &b)
+{
+	int r = a.category.compare(b.category);
+	if (!r) {
+		r = a.type.compare(b.type);
+		if (!r) {
+			r = a.lang.compare(b.lang);
+			if (!r) {
+				r = a.name.compare(b.name);
+			}
+		}
+	}
+
+	return r < 0;
+}
diff --git a/src/xmpp/xmpp-im/xmpp_discoitem.h b/src/xmpp/xmpp-im/xmpp_discoitem.h
index 8380ba5..dee515b 100644
--- a/src/xmpp/xmpp-im/xmpp_discoitem.h
+++ b/src/xmpp/xmpp-im/xmpp_discoitem.h
@@ -22,12 +22,16 @@
 #define XMPP_DISCOITEM
 
 #include <QString>
+#include <QCryptographicHash>
 
 #include "xmpp/jid/jid.h"
 #include "xmpp_features.h"
+#include "xmpp_xdata.h"
 #include "xmpp_agentitem.h"
 
 namespace XMPP {
+	class DiscoItemPrivate;
+
 	class DiscoItem
 	{
 	public:
@@ -57,14 +61,24 @@ namespace XMPP {
 		struct Identity
 		{
 			QString category;
-			QString name;
 			QString type;
+			QString lang;
+			QString name;
+
+			inline Identity() {}
+			inline Identity(const QString &categoty, const QString &type,
+							const QString &lang = QString::null, const QString &name = QString::null) :
+				category(categoty), type(type), lang(lang), name(name) {}
 		};
 
 		typedef QList<Identity> Identities;
 
 		const Identities &identities() const;
 		void setIdentities(const Identities &);
+		inline void setIdentities(const Identity &id) { setIdentities(Identities() << id); }
+
+		const QList<XData> &extensions() const;
+		void setExtensions(const QList<XData> &extlist);
 
 		// some useful helper functions
 		static Action string2action(QString s);
@@ -77,10 +91,16 @@ namespace XMPP {
 		AgentItem toAgentItem() const;
 		void fromAgentItem(const AgentItem &);
 
+		QString capsHash(QCryptographicHash::Algorithm algo) const;
+
+		static DiscoItem fromDiscoInfoResult(const QDomElement &x);
+		QDomElement toDiscoInfoResult(QDomDocument *doc) const;
+
 	private:
-		class Private;
-		Private *d;
+		QSharedDataPointer<DiscoItemPrivate> d;
 	};
+
+	bool operator<(const DiscoItem::Identity &a, const DiscoItem::Identity &b);
 }
 
 #endif
diff --git a/src/xmpp/xmpp-im/xmpp_tasks.cpp b/src/xmpp/xmpp-im/xmpp_tasks.cpp
index 8a9aa6c..a391ec7 100644
--- a/src/xmpp/xmpp-im/xmpp_tasks.cpp
+++ b/src/xmpp/xmpp-im/xmpp_tasks.cpp
@@ -766,6 +766,7 @@ bool JT_PushPresence::take(const QDomElement &e)
  			p.setCapsNode(i.attribute("node"));
  			p.setCapsVersion(i.attribute("ver"));
  			p.setCapsExt(i.attribute("ext"));
+			p.setCapsHashAlgorithm(i.attribute("hash"));
   		}
 		else if(i.tagName() == "x" && i.attribute("xmlns") == "vcard-temp:x:update") {
 			QDomElement t;
@@ -1486,72 +1487,32 @@ bool JT_ServInfo::take(const QDomElement &e)
 			node = q.attribute("node");
 
 		QDomElement iq = createIQ(doc(), "result", e.attribute("from"), e.attribute("id"));
-		QDomElement query = doc()->createElement("query");
-		query.setAttribute("xmlns", "http://jabber.org/protocol/disco#info");
-		if (!node.isEmpty())
-			query.setAttribute("node", node);
-		iq.appendChild(query);
-
-		// Identity
-		DiscoItem::Identity identity = client()->identity();
-		QDomElement id = doc()->createElement("identity");
-		if (!identity.category.isEmpty() && !identity.type.isEmpty()) {
-			id.setAttribute("category",identity.category);
-			id.setAttribute("type",identity.type);
-			if (!identity.name.isEmpty()) {
-				id.setAttribute("name",identity.name);
-			}
-		}
-		else {
-			// Default values
-			id.setAttribute("category","client");
-			id.setAttribute("type","pc");
+		DiscoItem item;
+		item.setNode(node);
+		DiscoItem::Identity id = client()->identity();
+		if (id.category.isEmpty() || id.type.isEmpty()) {
+			id.category = "client";
+			id.type = "pc";
 		}
-		query.appendChild(id);
+		item.setIdentities(id);
 
-		QDomElement feature;
+		Features features;
 		if (node.isEmpty() || node == client()->capsNode() + "#" + client()->capsVersion()) {
 			if (client()->fileTransferManager()) {
-				// Standard features
-				feature = doc()->createElement("feature");
-				feature.setAttribute("var", "http://jabber.org/protocol/bytestreams");
-				query.appendChild(feature);
-
-				feature = doc()->createElement("feature");
-				feature.setAttribute("var", "http://jabber.org/protocol/ibb");
-				query.appendChild(feature);
-
-				feature = doc()->createElement("feature");
-				feature.setAttribute("var", "http://jabber.org/protocol/si");
-				query.appendChild(feature);
-
-				feature = doc()->createElement("feature");
-				feature.setAttribute("var", "http://jabber.org/protocol/si/profile/file-transfer");
-				query.appendChild(feature);
+				features.addFeature("http://jabber.org/protocol/bytestreams");
+				features.addFeature("http://jabber.org/protocol/ibb");
+				features.addFeature("http://jabber.org/protocol/si");
+				features.addFeature("http://jabber.org/protocol/si/profile/file-transfer");
 			}
-
-			feature = doc()->createElement("feature");
-			feature.setAttribute("var", "http://jabber.org/protocol/disco#info");
-			query.appendChild(feature);
-
-			feature = doc()->createElement("feature");
-			feature.setAttribute("var", "urn:xmpp:bob");
-			query.appendChild(feature);
-
-			feature = doc()->createElement("feature");
-			feature.setAttribute("var", "urn:xmpp:ping");
-			query.appendChild(feature);
-
-			feature = doc()->createElement("feature");
-			feature.setAttribute("var", "urn:xmpp:time");
-			query.appendChild(feature);
+			features.addFeature("http://jabber.org/protocol/disco#info");
+			features.addFeature("urn:xmpp:bob");
+			features.addFeature("urn:xmpp:ping");
+			features.addFeature("urn:xmpp:time");
 
 			// Client-specific features
 			QStringList clientFeatures = client()->features().list();
 			foreach (const QString & i, clientFeatures) {
-				feature = doc()->createElement("feature");
-				feature.setAttribute("var", i);
-				query.appendChild(feature);
+				features.addFeature(i);
 			}
 
 			if (node.isEmpty()) {
@@ -1560,9 +1521,7 @@ bool JT_ServInfo::take(const QDomElement &e)
 				for (QStringList::ConstIterator i = exts.begin(); i != exts.end(); ++i) {
 					const QStringList& l = client()->extension(*i).list();
 					for ( QStringList::ConstIterator j = l.begin(); j != l.end(); ++j ) {
-						feature = doc()->createElement("feature");
-						feature.setAttribute("var", *j);
-						query.appendChild(feature);
+						features.addFeature(*j);
 					}
 				}
 			}
@@ -1572,9 +1531,7 @@ bool JT_ServInfo::take(const QDomElement &e)
 			if (client()->extensions().contains(ext)) {
 				const QStringList& l = client()->extension(ext).list();
 				for ( QStringList::ConstIterator it = l.begin(); it != l.end(); ++it ) {
-					feature = doc()->createElement("feature");
-					feature.setAttribute("var", *it);
-					query.appendChild(feature);
+					features.addFeature(*it);
 				}
 			}
 			else {
@@ -1586,6 +1543,8 @@ bool JT_ServInfo::take(const QDomElement &e)
 		}
 
 		if (!invalid_node) {
+			item.setFeatures(features);
+			iq.appendChild(item.toDiscoInfoResult(doc()));
 			send(iq);
 		}
 		else {
diff --git a/src/xmpp/xmpp-im/xmpp_xdata.cpp b/src/xmpp/xmpp-im/xmpp_xdata.cpp
index 16bd85b..6ae7f5c 100644
--- a/src/xmpp/xmpp-im/xmpp_xdata.cpp
+++ b/src/xmpp/xmpp-im/xmpp_xdata.cpp
@@ -431,6 +431,19 @@ XData::FieldList XData::fields() const
 	return d->fields;
 }
 
+XData::Field XData::getField(const QString &var) const
+{
+	if ( !d->fields.isEmpty() ) {
+		FieldList::ConstIterator it = d->fields.begin();
+		for ( ; it != d->fields.end(); ++it) {
+			Field f = *it;
+			if (f.isValid() && f.var() == var)
+				return f;
+		}
+	}
+	return Field();
+}
+
 void XData::setFields(const FieldList &f)
 {
 	d->fields = f;
diff --git a/src/xmpp/xmpp-im/xmpp_xdata.h b/src/xmpp/xmpp-im/xmpp_xdata.h
index 9689636..d8fd261 100644
--- a/src/xmpp/xmpp-im/xmpp_xdata.h
+++ b/src/xmpp/xmpp-im/xmpp_xdata.h
@@ -161,6 +161,7 @@ namespace XMPP {
 		typedef QList<Field> FieldList;
 
 		FieldList fields() const;
+		Field getField(const QString &var) const;
 		void setFields(const FieldList &);
 
 	private:
