diff --git a/src/xmpp/xmpp-im/types.cpp b/src/xmpp/xmpp-im/types.cpp
index b0d5d05..e2b45ac 100644
--- a/src/xmpp/xmpp-im/types.cpp
+++ b/src/xmpp/xmpp-im/types.cpp
@@ -2199,69 +2199,216 @@ bool Subscription::fromString(const QString &s)
 //---------------------------------------------------------------------------
 // Status
 //---------------------------------------------------------------------------
+/**
+ * Default constructor.
+ */
+CapsSpec::CapsSpec()
+{
+}
+
+
+/**
+ * \brief Basic constructor.
+ * @param node the node
+ * @param ven the version
+ * @param ext the list of extensions (separated by spaces)
+ */
+CapsSpec::CapsSpec(const QString& node, const QString& ver, const QString& hashAlgo)
+	: node_(node)
+	, ver_(ver)
+	, hashAlgo_(hashAlgo)
+{}
+
+/**
+ * @brief Checks for validity
+ * @return true on valid
+ */
+bool CapsSpec::isValid() const
+{
+	return !node_.isEmpty() && !ver_.isEmpty() && !hashAlgo_.isEmpty();
+}
+
+
+/**
+ * \brief Returns the node of the capabilities specification.
+ */
+const QString& CapsSpec::node() const
+{
+	return node_;
+}
+
+
+/**
+ * \brief Returns the version of the capabilities specification.
+ */
+const QString& CapsSpec::version() const
+{
+	return ver_;
+}
+
+const QString& CapsSpec::hashAlgorithm() const
+{
+	return hashAlgo_;
+}
+
+QDomElement CapsSpec::toXml(QDomDocument *doc) const
+{
+	QDomElement c = doc->createElement("c");
+	c.setAttribute("xmlns","http://jabber.org/protocol/caps");
+	c.setAttribute("hash",hashAlgo_);
+	c.setAttribute("node",node_);
+	c.setAttribute("ver",ver_);
+	return c;
+}
+
+CapsSpec CapsSpec::fromXml(const QDomElement &e)
+{
+	QString node = e.attribute("node");
+	QString ver = e.attribute("ver");
+	QString hashAlgo = e.attribute("hash");
+	return CapsSpec(node, ver, hashAlgo);
+}
+
+/**
+ * \brief Flattens the caps specification into the set of 'simple'
+ * specifications.
+ * A 'simple' specification is a specification with exactly one extension,
+ * or with the version number as the extension.
+ *
+ * Example: A caps specification with node=http://psi-im.org, version=0.10,
+ * and ext='achat vchat' would be expanded into the following list of specs:
+ *	node=http://psi-im.org, ver=0.10, ext=0.10
+ *	node=http://psi-im.org, ver=0.10, ext=achat
+ *	node=http://psi-im.org, ver=0.10, ext=vchat
+ */
+QString CapsSpec::flatten() const
+{
+	if (isValid())
+		return node_ + QLatin1String("#") + ver_;
+	return QString();
+}
+
+bool CapsSpec::operator==(const CapsSpec& s) const
+{
+	return (node() == s.node() && version() == s.version() && hashAlgorithm() == s.hashAlgorithm());
+}
+
+bool CapsSpec::operator!=(const CapsSpec& s) const
+{
+	return !((*this) == s);
+}
+
+bool CapsSpec::operator<(const CapsSpec& s) const
+{
+	return (node() != s.node() ? node() < s.node() :
+			(version() != s.version() ? version() < s.version() :
+			 hashAlgorithm() < s.hashAlgorithm()));
+}
+
+
+class StatusPrivate : public QSharedData
+{
+public:
+	StatusPrivate() :
+		hasPhotoHash(false),
+		isMUC(false),
+		hasMUCItem(false),
+		hasMUCDestroy(false),
+		mucHistoryMaxChars(-1),
+		mucHistoryMaxStanzas(-1),
+		mucHistorySeconds(-1),
+		ecode(-1)
+	{}
+
+	int priority;
+	QString show, status, key;
+	QDateTime timeStamp;
+	bool isAvailable;
+	bool isInvisible;
+	QString photoHash;
+	bool hasPhotoHash;
+
+	QString xsigned;
+	// gabber song extension
+	QString songTitle;
+	CapsSpec caps;
+	QList<BoBData> bobDataList;
+
+	// MUC
+	bool isMUC, hasMUCItem, hasMUCDestroy;
+	MUCItem mucItem;
+	MUCDestroy mucDestroy;
+	QList<int> mucStatuses;
+	QString mucPassword;
+	int mucHistoryMaxChars, mucHistoryMaxStanzas, mucHistorySeconds;
+	QDateTime mucHistorySince;
+
+	int ecode;
+	QString estr;
+};
+
 
 Status::Status(const QString &show, const QString &status, int priority, bool available)
 {
-	v_isAvailable = available;
-	v_show = show;
-	v_status = status;
-	v_priority = priority;
-	v_timeStamp = QDateTime::currentDateTime();
-	v_isInvisible = false;
-	v_hasPhotoHash = false;
-	v_isMUC = false;
-	v_hasMUCItem = false;
-	v_hasMUCDestroy = false;
-	v_mucHistoryMaxChars = -1;
-	v_mucHistoryMaxStanzas = -1;
-	v_mucHistorySeconds = -1;
-	ecode = -1;
+	d = new StatusPrivate;
+
+	d->isAvailable = available;
+	d->show = show;
+	d->status = status;
+	d->priority = priority;
+	d->timeStamp = QDateTime::currentDateTime();
+	d->isInvisible = false;
 }
 
 Status::Status(Type type, const QString& status, int priority)
 {
-	v_status = status;
-	v_priority = priority;
-	v_timeStamp = QDateTime::currentDateTime();
-	v_hasPhotoHash = false;
-	v_isMUC = false;
-	v_hasMUCItem = false;
-	v_hasMUCDestroy = false;
-	v_mucHistoryMaxChars = -1;
-	v_mucHistoryMaxStanzas = -1;
-	v_mucHistorySeconds = -1;
-	ecode = -1;
+	d = new StatusPrivate;
+
+	d->status = status;
+	d->priority = priority;
+	d->timeStamp = QDateTime::currentDateTime();
 	setType(type);
 }
 
+Status::Status(const Status &other) :
+	d(other.d)
+{
+}
+
+Status &Status::operator=(const Status &other)
+{
+	d = other.d;
+	return *this;
+}
+
 Status::~Status()
 {
 }
 
 bool Status::hasError() const
 {
-	return (ecode != -1);
+	return (d->ecode != -1);
 }
 
 void Status::setError(int code, const QString &str)
 {
-	ecode = code;
-	estr = str;
+	d->ecode = code;
+	d->estr = str;
 }
 
 void Status::setIsAvailable(bool available)
 {
-	v_isAvailable = available;
+	d->isAvailable = available;
 }
 
 void Status::setIsInvisible(bool invisible)
 {
-	v_isInvisible = invisible;
+	d->isInvisible = invisible;
 }
 
 void Status::setPriority(int x)
 {
-	v_priority = x;
+	d->priority = x;
 }
 
 void Status::setType(Status::Type _type)
@@ -2310,124 +2457,109 @@ void Status::setType(QString stat)
 
 void Status::setShow(const QString & _show)
 {
-	v_show = _show;
+	d->show = _show;
 }
 
 void Status::setStatus(const QString & _status)
 {
-	v_status = _status;
+	d->status = _status;
 }
 
 void Status::setTimeStamp(const QDateTime & _timestamp)
 {
-	v_timeStamp = _timestamp;
+	d->timeStamp = _timestamp;
 }
 
 void Status::setKeyID(const QString &key)
 {
-	v_key = key;
+	d->key = key;
 }
 
 void Status::setXSigned(const QString &s)
 {
-	v_xsigned = s;
+	d->xsigned = s;
 }
 
 void Status::setSongTitle(const QString & _songtitle)
 {
-	v_songTitle = _songtitle;
-}
-
-void Status::setCapsNode(const QString & _capsNode)
-{
-	v_capsNode = _capsNode;
+	d->songTitle = _songtitle;
 }
 
-void Status::setCapsVersion(const QString & _capsVersion)
+void Status::setCaps(const CapsSpec & caps)
 {
-	v_capsVersion = _capsVersion;
-}
-
-void Status::setCapsHashAlgorithm(const QString & _capsHashAlgorithm)
-{
-	v_capsHashAlgorithm = _capsHashAlgorithm;
-}
-
-void Status::setCapsExt(const QString & _capsExt)
-{
-	v_capsExt = _capsExt;
+	d->caps = caps;
 }
 
 void Status::setMUC()
 {
-	v_isMUC = true;
+	d->isMUC = true;
 }
 
 void Status::setMUCItem(const MUCItem& i)
 {
-	v_hasMUCItem = true;
-	v_mucItem = i;
+	d->hasMUCItem = true;
+	d->mucItem = i;
 }
 
 void Status::setMUCDestroy(const MUCDestroy& i)
 {
-	v_hasMUCDestroy = true;
-	v_mucDestroy = i;
+	d->hasMUCDestroy = true;
+	d->mucDestroy = i;
 }
 
 void Status::setMUCHistory(int maxchars, int maxstanzas, int seconds, const QDateTime &since)
 {
-	v_mucHistoryMaxChars = maxchars;
-	v_mucHistoryMaxStanzas = maxstanzas;
-	v_mucHistorySeconds = seconds;
-	v_mucHistorySince = since;
+	d->mucHistoryMaxChars = maxchars;
+	d->mucHistoryMaxStanzas = maxstanzas;
+	d->mucHistorySeconds = seconds;
+	d->mucHistorySince = since;
 }
 
 
 const QString& Status::photoHash() const
 {
-	return v_photoHash;
+	return d->photoHash;
 }
 
 void Status::setPhotoHash(const QString& h)
 {
-	v_photoHash = h;
-	v_hasPhotoHash = true;
+	d->photoHash = h;
+	d->hasPhotoHash = true;
 }
 
 bool Status::hasPhotoHash() const
 {
-	return v_hasPhotoHash;
+	return d->hasPhotoHash;
 }
 
 void Status::addBoBData(const BoBData &bob)
 {
-	v_bobDataList.append(bob);
+	d->bobDataList.append(bob);
 }
 
 QList<BoBData> Status::bobDataList() const
 {
-	return v_bobDataList;
+	return d->bobDataList;
 }
 
 bool Status::isAvailable() const
 {
-	return v_isAvailable;
+	return d->isAvailable;
 }
 
 bool Status::isAway() const
 {
-	return (v_show == "away" || v_show == "xa" || v_show == "dnd");
+	return (d->show == "away" || d->show == "xa" || d->show == "dnd");
 }
 
 bool Status::isInvisible() const
 {
-	return v_isInvisible;
+	return d->isInvisible;
 }
 
 int Status::priority() const
 {
-	return v_priority;
+	return d->priority;
 }
 
 Status::Type Status::type() const
@@ -2471,131 +2603,116 @@ QString Status::typeString() const
 
 const QString & Status::show() const
 {
-	return v_show;
+	return d->show;
 }
 const QString & Status::status() const
 {
-	return v_status;
+	return d->status;
 }
 
 QDateTime Status::timeStamp() const
 {
-	return v_timeStamp;
+	return d->timeStamp;
 }
 
 const QString & Status::keyID() const
 {
-	return v_key;
+	return d->key;
 }
 
 const QString & Status::xsigned() const
 {
-	return v_xsigned;
+	return d->xsigned;
 }
 
 const QString & Status::songTitle() const
 {
-	return v_songTitle;
+	return d->songTitle;
 }
 
-const QString & Status::capsNode() const
+const CapsSpec & Status::caps() const
 {
-	return v_capsNode;
-}
-
-const QString & Status::capsVersion() const
-{
-	return v_capsVersion;
-}
-
-const QString & Status::capsHashAlgorithm() const
-{
-	return v_capsHashAlgorithm;
-}
-
-const QString & Status::capsExt() const
-{
-	return v_capsExt;
+	return d->caps;
 }
 
 bool Status::isMUC() const
 {
-	return v_isMUC || !v_mucPassword.isEmpty() || hasMUCHistory();
+	return d->isMUC || !d->mucPassword.isEmpty() || hasMUCHistory();
 }
 
 bool Status::hasMUCItem() const
 {
-	return v_hasMUCItem;
+	return d->hasMUCItem;
 }
 
 const MUCItem& Status::mucItem() const
 {
-	return v_mucItem;
+	return d->mucItem;
 }
 
 bool Status::hasMUCDestroy() const
 {
-	return v_hasMUCDestroy;
+	return d->hasMUCDestroy;
 }
 
 const MUCDestroy& Status::mucDestroy() const
 {
-	return v_mucDestroy;
+	return d->mucDestroy;
 }
 
 const QList<int>& Status::getMUCStatuses() const
 {
-	return v_mucStatuses;
+	return d->mucStatuses;
 }
 
 void Status::addMUCStatus(int i)
 {
-	v_mucStatuses += i;
+	d->mucStatuses += i;
 }
 
 const QString& Status::mucPassword() const
 {
-	return v_mucPassword;
+	return d->mucPassword;
 }
 
 bool Status::hasMUCHistory() const
 {
-	return v_mucHistoryMaxChars >= 0 || v_mucHistoryMaxStanzas >= 0 || v_mucHistorySeconds >= 0 || !v_mucHistorySince.isNull();
+	return d->mucHistoryMaxChars >= 0 || d->mucHistoryMaxStanzas >= 0 || d->mucHistorySeconds >= 0 || !d->mucHistorySince.isNull();
 }
 
 int Status::mucHistoryMaxChars() const
 {
-	return v_mucHistoryMaxChars;
+	return d->mucHistoryMaxChars;
 }
 
 int Status::mucHistoryMaxStanzas() const
 {
-	return v_mucHistoryMaxStanzas;
+	return d->mucHistoryMaxStanzas;
 }
 
 int Status::mucHistorySeconds() const
 {
-	return v_mucHistorySeconds;
+	return d->mucHistorySeconds;
 }
 
 const QDateTime & Status::mucHistorySince() const
 {
-	return v_mucHistorySince;
+	return d->mucHistorySince;
 }
 
 void Status::setMUCPassword(const QString& i)
 {
-	v_mucPassword = i;
+	d->mucPassword = i;
 }
 
 int Status::errorCode() const
 {
-	return ecode;
+	return d->ecode;
 }
 
 const QString & Status::errorString() const
 {
-	return estr;
+	return d->estr;
 }
 
 
diff --git a/src/xmpp/xmpp-im/xmpp_discoinfotask.cpp b/src/xmpp/xmpp-im/xmpp_discoinfotask.cpp
index eb92cf4..4d0e75e 100644
--- a/src/xmpp/xmpp-im/xmpp_discoinfotask.cpp
+++ b/src/xmpp/xmpp-im/xmpp_discoinfotask.cpp
@@ -125,39 +125,8 @@ bool DiscoInfoTask::take(const QDomElement &x)
 		return false;
 
 	if(x.attribute("type") == "result") {
-		QDomElement q = queryTag(x);
-
-		DiscoItem item;
-
-		item.setJid( d->jid );
-		item.setNode( q.attribute("node") );
-
-		QStringList features;
-		DiscoItem::Identities identities;
-
-		for(QDomNode n = q.firstChild(); !n.isNull(); n = n.nextSibling()) {
-			QDomElement e = n.toElement();
-			if( e.isNull() )
-				continue;
-
-			if ( e.tagName() == "feature" ) {
-				features << e.attribute("var");
-			}
-			else if ( e.tagName() == "identity" ) {
-				DiscoItem::Identity id;
-
-				id.category = e.attribute("category");
-				id.name     = e.attribute("name");
-				id.type     = e.attribute("type");
-
-				identities.append( id );
-			}
-		}
-
-		item.setFeatures( features );
-		item.setIdentities( identities );
-
-		d->item = item;
+		d->item = DiscoItem::fromDiscoInfoResult(queryTag(x));
+		d->item.setJid( d->jid );
 
 		setSuccess(true);
 	}
diff --git a/src/xmpp/xmpp-im/xmpp_discoitem.cpp b/src/xmpp/xmpp-im/xmpp_discoitem.cpp
index 59e9551..d13dafa 100644
--- a/src/xmpp/xmpp-im/xmpp_discoitem.cpp
+++ b/src/xmpp/xmpp-im/xmpp_discoitem.cpp
@@ -18,35 +18,38 @@
  *
  */
 
+#include <QtXml>
+
 #include "xmpp_discoitem.h"
 
 using namespace XMPP;
 
-class DiscoItem::Private
+class XMPP::DiscoItemPrivate : public QSharedData
 {
 public:
-	Private()
+	DiscoItemPrivate()
 	{
-		action = None;
+		action = DiscoItem::None;
 	}
 
 	Jid jid;
 	QString name;
 	QString node;
-	Action action;
+	DiscoItem::Action action;
 
 	Features features;
-	Identities identities;
+	DiscoItem::Identities identities;
+	QList<XData> exts;
 };
 
 DiscoItem::DiscoItem()
 {
-	d = new Private;
+	d = new DiscoItemPrivate;
 }
 
 DiscoItem::DiscoItem(const DiscoItem &from)
 {
-	d = new Private;
+	d = new DiscoItemPrivate;
 	*this = from;
 }
 
@@ -58,13 +61,14 @@ DiscoItem & DiscoItem::operator= (const DiscoItem &from)
 	d->action = from.d->action;
 	d->features = from.d->features;
 	d->identities = from.d->identities;
+	d->exts = from.d->exts;
 
 	return *this;
 }
 
 DiscoItem::~DiscoItem()
 {
-	delete d;
+
 }
 
 AgentItem DiscoItem::toAgentItem() const
@@ -104,6 +108,127 @@ void DiscoItem::fromAgentItem(const AgentItem &ai)
 	setFeatures( ai.features() );
 }
 
+QString DiscoItem::capsHash(QCryptographicHash::Algorithm algo) const
+{
+	QStringList prep;
+	DiscoItem::Identities idents = d->identities;
+	qSort(idents);
+
+	foreach (const DiscoItem::Identity &id, idents) {
+		prep << QString("%1/%2/%3/%4<").arg(id.category, id.type, id.lang, id.name);
+	}
+
+	QStringList fl = d->features.list();
+	qSort(fl);
+	prep += fl;
+
+	QMap<QString,XData> forms;
+	foreach (const XData &xd, d->exts) {
+		if (xd.registrarType().isEmpty()) {
+			continue;
+		}
+		if (forms.contains(xd.registrarType())) {
+			return QString(); // ill-formed
+		}
+		forms.insert(xd.registrarType(), xd);
+	}
+	foreach (const XData &xd, forms.values()) {
+		prep << xd.registrarType();
+		QMap <QString, QStringList> values;
+		foreach (const XData::Field &f, xd.fields()) {
+			if (f.var() == QLatin1String("FORM_TYPE")) {
+				continue;
+			}
+			if (values.contains(f.var())) {
+				return QString(); // ill-formed
+			}
+			QStringList v = f.value();
+			if (v.isEmpty()) {
+				continue; // maybe it's media-element but xep-115 (1.5) and xep-232 (0.3) are not clear about that.
+			}
+			qSort(v);
+			values[f.var()] = v;
+		}
+		foreach (const QStringList &sl, values.values()) {
+			prep += sl;
+		}
+	}
+
+	QByteArray ba = (prep.join(QLatin1String("<")) + QLatin1Char('<')).toUtf8();
+	return QString::fromLatin1(QCryptographicHash::hash(ba, algo).toBase64());
+}
+
+DiscoItem DiscoItem::fromDiscoInfoResult(const QDomElement &q)
+{
+	DiscoItem item;
+
+	item.setNode( q.attribute("node") );
+
+	QStringList features;
+	DiscoItem::Identities identities;
+	QList<XData> extList;
+
+	for(QDomNode n = q.firstChild(); !n.isNull(); n = n.nextSibling()) {
+		QDomElement e = n.toElement();
+		if( e.isNull() )
+			continue;
+
+		if ( e.tagName() == "feature" ) {
+			features << e.attribute("var");
+		}
+		else if ( e.tagName() == "identity" ) {
+			DiscoItem::Identity id;
+
+			id.category = e.attribute("category");
+			id.type     = e.attribute("type");
+			id.lang     = e.attribute("lang");
+			id.name     = e.attribute("name");
+
+			identities.append( id );
+		}
+		else if (e.tagName() == QLatin1String("x") && e.namespaceURI() == QLatin1String("jabber:x:data")) {
+			XData form;
+			form.fromXml(e);
+			extList.append(form);
+		}
+	}
+
+	item.setFeatures( features );
+	item.setIdentities( identities );
+	item.setExtensions( extList );
+
+	return item;
+}
+
+QDomElement DiscoItem::toDiscoInfoResult(QDomDocument *doc) const
+{
+	QDomElement q = doc->createElementNS(QLatin1String("http://jabber.org/protocol/disco#info"), QLatin1String("query"));
+	q.setAttribute("node", d->node);
+
+	foreach (const Identity &id, d->identities) {
+		QDomElement idel = q.appendChild(doc->createElement(QLatin1String("identity"))).toElement();
+		idel.setAttribute("category", id.category);
+		idel.setAttribute("type", id.type);
+		if (!id.lang.isEmpty()) {
+			idel.setAttribute("lang", id.lang);
+		}
+		if (!id.name.isEmpty()) {
+			idel.setAttribute("name", id.name);
+		}
+	}
+
+	foreach (const QString &f, d->features.list()) {
+		QDomElement fel = q.appendChild(doc->createElement(QLatin1String("feature"))).toElement();
+		fel.setAttribute("var", f);
+	}
+
+	foreach (const XData &f, d->exts) {
+		q.appendChild(f.toXml(doc));
+	}
+
+	return q;
+}
+
 const Jid &DiscoItem::jid() const
 {
 	return d->jid;
@@ -167,6 +292,25 @@ void DiscoItem::setIdentities(const Identities &i)
 		setName( i.first().name );
 }
 
+const QList<XData> &DiscoItem::extensions() const
+{
+	return d->exts;
+}
+
+void DiscoItem::setExtensions(const QList<XData> &extlist)
+{
+	d->exts = extlist;
+}
+
+XData DiscoItem::registeredExtension(const QString &ns) const
+{
+	foreach (const XData &xd, d->exts) {
+		if (xd.registrarType() == ns) {
+			return xd;
+		}
+	}
+	return XData();
+}
 
 DiscoItem::Action DiscoItem::string2action(QString s)
 {
@@ -197,3 +341,19 @@ QString DiscoItem::action2string(Action a)
 }
 
 
+
+bool XMPP::operator<(const DiscoItem::Identity &a, const DiscoItem::Identity &b)
+{
+	int r = a.category.compare(b.category);
+	if (!r) {
+		r = a.type.compare(b.type);
+		if (!r) {
+			r = a.lang.compare(b.lang);
+			if (!r) {
+				r = a.name.compare(b.name);
+			}
+		}
+	}
+
+	return r < 0;
+}
diff --git a/src/xmpp/xmpp-im/xmpp_discoitem.h b/src/xmpp/xmpp-im/xmpp_discoitem.h
index 8380ba5..969dd09 100644
--- a/src/xmpp/xmpp-im/xmpp_discoitem.h
+++ b/src/xmpp/xmpp-im/xmpp_discoitem.h
@@ -22,12 +22,16 @@
 #define XMPP_DISCOITEM
 
 #include <QString>
+#include <QCryptographicHash>
 
 #include "xmpp/jid/jid.h"
 #include "xmpp_features.h"
+#include "xmpp_xdata.h"
 #include "xmpp_agentitem.h"
 
 namespace XMPP {
+	class DiscoItemPrivate;
+
 	class DiscoItem
 	{
 	public:
@@ -57,14 +61,25 @@ namespace XMPP {
 		struct Identity
 		{
 			QString category;
-			QString name;
 			QString type;
+			QString lang;
+			QString name;
+
+			inline Identity() {}
+			inline Identity(const QString &categoty, const QString &type,
+							const QString &lang = QString::null, const QString &name = QString::null) :
+				category(categoty), type(type), lang(lang), name(name) {}
 		};
 
 		typedef QList<Identity> Identities;
 
 		const Identities &identities() const;
 		void setIdentities(const Identities &);
+		inline void setIdentities(const Identity &id) { setIdentities(Identities() << id); }
+
+		const QList<XData> &extensions() const;
+		void setExtensions(const QList<XData> &extlist);
+		XData registeredExtension(const QString &ns) const;
 
 		// some useful helper functions
 		static Action string2action(QString s);
@@ -77,10 +92,16 @@ namespace XMPP {
 		AgentItem toAgentItem() const;
 		void fromAgentItem(const AgentItem &);
 
+		QString capsHash(QCryptographicHash::Algorithm algo) const;
+
+		static DiscoItem fromDiscoInfoResult(const QDomElement &x);
+		QDomElement toDiscoInfoResult(QDomDocument *doc) const;
+
 	private:
-		class Private;
-		Private *d;
+		QSharedDataPointer<DiscoItemPrivate> d;
 	};
+
+	bool operator<(const DiscoItem::Identity &a, const DiscoItem::Identity &b);
 }
 
 #endif
diff --git a/src/xmpp/xmpp-im/xmpp_status.h b/src/xmpp/xmpp-im/xmpp_status.h
index f7c88ea..8d34352 100644
--- a/src/xmpp/xmpp-im/xmpp_status.h
+++ b/src/xmpp/xmpp-im/xmpp_status.h
@@ -30,6 +30,30 @@
 
 namespace XMPP
 {
+	class CapsSpec
+	{
+		public:
+			CapsSpec();
+			CapsSpec(const QString& node, const QString& ver, const QString& hashAlgo);
+			bool isValid() const;
+			const QString& node() const;
+			const QString& version() const;
+			const QString& hashAlgorithm() const;
+			QString flatten() const;
+
+			bool operator==(const CapsSpec&) const;
+			bool operator!=(const CapsSpec&) const;
+			bool operator<(const CapsSpec&) const;
+
+			QDomElement toXml(QDomDocument *doc) const;
+			static CapsSpec fromXml(const QDomElement &e);
+
+		private:
+			QString node_, ver_, hashAlgo_;
+	};
+
+	class StatusPrivate;
+
 	class Status
 	{
 	public:
@@ -37,6 +61,8 @@ namespace XMPP
 
 		Status(const QString &show=QString(), const QString &status=QString(), int priority=0, bool available=true);
 		Status(Type type, const QString& status=QString(), int priority=0);
+		Status(const Status &);
+		Status &operator=(const Status &);
 		~Status();
 
 		int priority() const;
@@ -55,10 +81,7 @@ namespace XMPP
 
 		const QString & xsigned() const;
 		const QString & songTitle() const;
-		const QString & capsNode() const;
-		const QString & capsVersion() const;
-		const QString & capsHashAlgorithm() const;
-		const QString & capsExt() const;
+		const CapsSpec & caps() const;
 
 		bool isMUC() const;
 		bool hasMUCItem() const;
@@ -85,10 +108,7 @@ namespace XMPP
 		void setIsAvailable(bool);
 		void setIsInvisible(bool);
 		void setError(int, const QString &);
-		void setCapsNode(const QString&);
-		void setCapsVersion(const QString&);
-		void setCapsHashAlgorithm(const QString&);
-		void setCapsExt(const QString&);
+		void setCaps(const CapsSpec&);
 
 		void setMUC();
 		void setMUCItem(const MUCItem&);
@@ -110,31 +130,7 @@ namespace XMPP
 		QList<BoBData> bobDataList() const;
 
 	private:
-		int v_priority;
-		QString v_show, v_status, v_key;
-		QDateTime v_timeStamp;
-		bool v_isAvailable;
-		bool v_isInvisible;
-		QString v_photoHash;
-		bool v_hasPhotoHash;
-
-		QString v_xsigned;
-		// gabber song extension
-		QString v_songTitle;
-		QString v_capsNode, v_capsVersion, v_capsHashAlgorithm, v_capsExt;
-		QList<BoBData> v_bobDataList;
-
-		// MUC
-		bool v_isMUC, v_hasMUCItem, v_hasMUCDestroy;
-		MUCItem v_mucItem;
-		MUCDestroy v_mucDestroy;
-		QList<int> v_mucStatuses;
-		QString v_mucPassword;
-		int v_mucHistoryMaxChars, v_mucHistoryMaxStanzas, v_mucHistorySeconds;
-		QDateTime v_mucHistorySince;
-
-		int ecode;
-		QString estr;
+		QSharedDataPointer<StatusPrivate> d;
 	};
 
 }
diff --git a/src/xmpp/xmpp-im/xmpp_tasks.cpp b/src/xmpp/xmpp-im/xmpp_tasks.cpp
index 8a9aa6c..2172ae4 100644
--- a/src/xmpp/xmpp-im/xmpp_tasks.cpp
+++ b/src/xmpp/xmpp-im/xmpp_tasks.cpp
@@ -588,16 +588,8 @@ void JT_Presence::pres(const Status &s)
 			tag.appendChild(x);
 		}
 
-		if(!s.capsNode().isEmpty() && !s.capsVersion().isEmpty()) {
-			QDomElement c = doc()->createElement("c");
-			c.setAttribute("xmlns","http://jabber.org/protocol/caps");
-			if (!s.capsHashAlgorithm().isEmpty())
-				c.setAttribute("hash",s.capsHashAlgorithm());
-			c.setAttribute("node",s.capsNode());
-			c.setAttribute("ver",s.capsVersion());
-			if (!s.capsExt().isEmpty())
-				c.setAttribute("ext",s.capsExt());
-			tag.appendChild(c);
+		if (s.caps().isValid()) {
+			tag.appendChild(s.caps().toXml(doc()));
 		}
 
 		if(s.isMUC()) {
@@ -763,9 +755,7 @@ bool JT_PushPresence::take(const QDomElement &e)
 			p.setKeyID(tagContent(i));
 		}
  		else if(i.tagName() == "c" && i.attribute("xmlns") == "http://jabber.org/protocol/caps") {
- 			p.setCapsNode(i.attribute("node"));
- 			p.setCapsVersion(i.attribute("ver"));
- 			p.setCapsExt(i.attribute("ext"));
+			p.setCaps(CapsSpec::fromXml(i));
   		}
 		else if(i.tagName() == "x" && i.attribute("xmlns") == "vcard-temp:x:update") {
 			QDomElement t;
@@ -1486,72 +1476,32 @@ bool JT_ServInfo::take(const QDomElement &e)
 			node = q.attribute("node");
 
 		QDomElement iq = createIQ(doc(), "result", e.attribute("from"), e.attribute("id"));
-		QDomElement query = doc()->createElement("query");
-		query.setAttribute("xmlns", "http://jabber.org/protocol/disco#info");
-		if (!node.isEmpty())
-			query.setAttribute("node", node);
-		iq.appendChild(query);
-
-		// Identity
-		DiscoItem::Identity identity = client()->identity();
-		QDomElement id = doc()->createElement("identity");
-		if (!identity.category.isEmpty() && !identity.type.isEmpty()) {
-			id.setAttribute("category",identity.category);
-			id.setAttribute("type",identity.type);
-			if (!identity.name.isEmpty()) {
-				id.setAttribute("name",identity.name);
-			}
-		}
-		else {
-			// Default values
-			id.setAttribute("category","client");
-			id.setAttribute("type","pc");
+		DiscoItem item;
+		item.setNode(node);
+		DiscoItem::Identity id = client()->identity();
+		if (id.category.isEmpty() || id.type.isEmpty()) {
+			id.category = "client";
+			id.type = "pc";
 		}
-		query.appendChild(id);
+		item.setIdentities(id);
 
-		QDomElement feature;
+		Features features;
 		if (node.isEmpty() || node == client()->capsNode() + "#" + client()->capsVersion()) {
 			if (client()->fileTransferManager()) {
-				// Standard features
-				feature = doc()->createElement("feature");
-				feature.setAttribute("var", "http://jabber.org/protocol/bytestreams");
-				query.appendChild(feature);
-
-				feature = doc()->createElement("feature");
-				feature.setAttribute("var", "http://jabber.org/protocol/ibb");
-				query.appendChild(feature);
-
-				feature = doc()->createElement("feature");
-				feature.setAttribute("var", "http://jabber.org/protocol/si");
-				query.appendChild(feature);
-
-				feature = doc()->createElement("feature");
-				feature.setAttribute("var", "http://jabber.org/protocol/si/profile/file-transfer");
-				query.appendChild(feature);
+				features.addFeature("http://jabber.org/protocol/bytestreams");
+				features.addFeature("http://jabber.org/protocol/ibb");
+				features.addFeature("http://jabber.org/protocol/si");
+				features.addFeature("http://jabber.org/protocol/si/profile/file-transfer");
 			}
-
-			feature = doc()->createElement("feature");
-			feature.setAttribute("var", "http://jabber.org/protocol/disco#info");
-			query.appendChild(feature);
-
-			feature = doc()->createElement("feature");
-			feature.setAttribute("var", "urn:xmpp:bob");
-			query.appendChild(feature);
-
-			feature = doc()->createElement("feature");
-			feature.setAttribute("var", "urn:xmpp:ping");
-			query.appendChild(feature);
-
-			feature = doc()->createElement("feature");
-			feature.setAttribute("var", "urn:xmpp:time");
-			query.appendChild(feature);
+			features.addFeature("http://jabber.org/protocol/disco#info");
+			features.addFeature("urn:xmpp:bob");
+			features.addFeature("urn:xmpp:ping");
+			features.addFeature("urn:xmpp:time");
 
 			// Client-specific features
 			QStringList clientFeatures = client()->features().list();
 			foreach (const QString & i, clientFeatures) {
-				feature = doc()->createElement("feature");
-				feature.setAttribute("var", i);
-				query.appendChild(feature);
+				features.addFeature(i);
 			}
 
 			if (node.isEmpty()) {
@@ -1560,9 +1510,7 @@ bool JT_ServInfo::take(const QDomElement &e)
 				for (QStringList::ConstIterator i = exts.begin(); i != exts.end(); ++i) {
 					const QStringList& l = client()->extension(*i).list();
 					for ( QStringList::ConstIterator j = l.begin(); j != l.end(); ++j ) {
-						feature = doc()->createElement("feature");
-						feature.setAttribute("var", *j);
-						query.appendChild(feature);
+						features.addFeature(*j);
 					}
 				}
 			}
@@ -1572,9 +1520,7 @@ bool JT_ServInfo::take(const QDomElement &e)
 			if (client()->extensions().contains(ext)) {
 				const QStringList& l = client()->extension(ext).list();
 				for ( QStringList::ConstIterator it = l.begin(); it != l.end(); ++it ) {
-					feature = doc()->createElement("feature");
-					feature.setAttribute("var", *it);
-					query.appendChild(feature);
+					features.addFeature(*it);
 				}
 			}
 			else {
@@ -1586,6 +1532,8 @@ bool JT_ServInfo::take(const QDomElement &e)
 		}
 
 		if (!invalid_node) {
+			item.setFeatures(features);
+			iq.appendChild(item.toDiscoInfoResult(doc()));
 			send(iq);
 		}
 		else {
diff --git a/src/xmpp/xmpp-im/xmpp_xdata.cpp b/src/xmpp/xmpp-im/xmpp_xdata.cpp
index 16bd85b..6ae7f5c 100644
--- a/src/xmpp/xmpp-im/xmpp_xdata.cpp
+++ b/src/xmpp/xmpp-im/xmpp_xdata.cpp
@@ -431,6 +431,19 @@ XData::FieldList XData::fields() const
 	return d->fields;
 }
 
+XData::Field XData::getField(const QString &var) const
+{
+	if ( !d->fields.isEmpty() ) {
+		FieldList::ConstIterator it = d->fields.begin();
+		for ( ; it != d->fields.end(); ++it) {
+			Field f = *it;
+			if (f.isValid() && f.var() == var)
+				return f;
+		}
+	}
+	return Field();
+}
+
 void XData::setFields(const FieldList &f)
 {
 	d->fields = f;
diff --git a/src/xmpp/xmpp-im/xmpp_xdata.h b/src/xmpp/xmpp-im/xmpp_xdata.h
index 9689636..d8fd261 100644
--- a/src/xmpp/xmpp-im/xmpp_xdata.h
+++ b/src/xmpp/xmpp-im/xmpp_xdata.h
@@ -161,6 +161,7 @@ namespace XMPP {
 		typedef QList<Field> FieldList;
 
 		FieldList fields() const;
+		Field getField(const QString &var) const;
 		void setFields(const FieldList &);
 
 	private:
