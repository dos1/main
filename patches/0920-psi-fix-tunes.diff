--- git.orig/options/default.xml
+++ git/options/default.xml
@@ -36,7 +36,7 @@
 				<publish comment="Publish user tune information" type="bool">true</publish>
 				<url-filter comment="Ingore tune by media file extension" type="QString">avi asf asx mpg mpg2 mpeg mpe mst mp4 flv 3gp mkv wmv swf rv rm rst dat vob ifo ogv</url-filter>
 				<title-filter comment="Ignore tune by name via RegExp" type="QString"></title-filter>
-				<controller-filter comment="List of disabled controllers" type="QString"></controller-filter>
+				<controller-filter comment="List of disabled controllers" type="QString">WinAmp</controller-filter>
 			</tune>
 		</extended-presence>
 		<muc comment="Multi-User Chat options">
--- git.orig/src/options/options.pri
+++ git/src/options/options.pri
@@ -27,7 +27,8 @@ HEADERS += \
 	$$PWD/opt_avcall.h \
 	$$PWD/opt_toolbars.h \
 	$$PWD/opt_advanced.h \
-	$$PWD/opt_shortcuts.h
+	$$PWD/opt_shortcuts.h \
+	$$PWD/opt_statuspep.h
 
 HEADERS += $$PWD/opt_tree.h
 
@@ -48,7 +49,8 @@ SOURCES += \
 	$$PWD/opt_avcall.cpp \
 	$$PWD/opt_toolbars.cpp \
 	$$PWD/opt_advanced.cpp \
-	$$PWD/opt_shortcuts.cpp
+	$$PWD/opt_shortcuts.cpp \
+	$$PWD/opt_statuspep.cpp
 
 SOURCES += $$PWD/opt_tree.cpp
 
@@ -75,7 +77,8 @@ FORMS += \
 	$$PWD/opt_iconset_system.ui \
 	$$PWD/opt_iconset_roster.ui \
 	$$PWD/opt_general_groupchat.ui \
-	$$PWD/opt_shortcuts.ui
+	$$PWD/opt_shortcuts.ui \
+	$$PWD/opt_statuspep.ui
 
 psi_plugins {
 	FORMS += $$PWD/opt_plugins.ui
--- git.orig/src/options/opt_status.cpp
+++ git/src/options/opt_status.cpp
@@ -1,6 +1,7 @@
 #include "opt_status.h"
 #include "opt_statusgeneral.h"
 #include "opt_statusauto.h"
+#include "opt_statuspep.h"
 
 OptionsTabStatus::OptionsTabStatus(QObject *parent)
 : MetaOptionsTab(parent, "status", "", tr("Status"), tr("Status preferences"), "psi/status")
@@ -10,4 +11,5 @@ OptionsTabStatus::OptionsTabStatus(QObje
 	connect(general, SIGNAL(enableDlgCommonWidgets(bool)), parent, SLOT(enableCommonWidgets(bool)));
 	connect(general, SIGNAL(enableDlgCommonWidgets(bool)), SLOT(enableOtherTabs(bool)));
 	addTab(new OptionsTabStatusAuto(this));
+	addTab(new OptionsTabStatusPep(this));
 }
--- git.orig/src/options/opt_statuspep.cpp
+++ git/src/options/opt_statuspep.cpp
@@ -0,0 +1,108 @@
+#include "opt_statuspep.h"
+#include "psioptions.h"
+
+#include <QListWidget>
+#include <QCheckBox>
+
+#include "ui_opt_statuspep.h"
+
+static const char *tuneUrlFilterOptionPath = "options.extended-presence.tune.url-filter";
+static const char *tuneControllerFilterOptionPath = "options.extended-presence.tune.controller-filter";
+
+class OptStatusPepUI : public QWidget, public Ui::OptStatusPep
+{
+public:
+	OptStatusPepUI() : QWidget() { setupUi(this); }
+};
+
+OptionsTabStatusPep::OptionsTabStatusPep(QObject *parent)
+: OptionsTab(parent, "status_tunes", "", tr("PEP"), tr("Tunes no-video filter and controllers switcher"))
+, w_(0)
+, psi_(0)
+, controllersChanged_(false)
+{
+}
+
+OptionsTabStatusPep::~OptionsTabStatusPep()
+{
+}
+
+QWidget *OptionsTabStatusPep::widget()
+{
+	if (w_) {
+		return 0;
+	}
+
+	w_ = new OptStatusPepUI();
+	return w_;
+}
+
+void OptionsTabStatusPep::applyOptions()
+{
+	if (!w_) {
+		return;
+	}
+
+	OptStatusPepUI *d = (OptStatusPepUI *)w_;
+	PsiOptions* o = PsiOptions::instance();
+	QStringList newTuneFilters = d->tuneExtensions->text().split(QRegExp("\\W+"));
+	QString tuneExstensionsFilter;
+	if (!newTuneFilters.isEmpty()) {
+		newTuneFilters.removeDuplicates();
+		qSort(newTuneFilters);
+		tuneExstensionsFilter = newTuneFilters.join(" ").toLower();
+		d->tuneExtensions->setText(tuneExstensionsFilter);
+	}
+	QString controllerFilter = blackList_.join(",");
+	if (tuneExstensionsFilter != tuneFilters_) {
+		o->setOption(tuneUrlFilterOptionPath, tuneExstensionsFilter);
+	}
+	if (controllersChanged_) {
+		o->setOption(tuneControllerFilterOptionPath, controllerFilter);
+	}
+}
+
+void OptionsTabStatusPep::restoreOptions()
+{
+	if (!w_) {
+		return;
+	}
+
+	OptStatusPepUI *d = (OptStatusPepUI *)w_;
+	PsiOptions* o = PsiOptions::instance();
+	tuneFilters_ = o->getOption(tuneUrlFilterOptionPath).toString();
+	d->tuneExtensions->setText(tuneFilters_);
+	QStringList controllers = psi_->tuneManager()->controllerNames();
+	blackList_ = o->getOption(tuneControllerFilterOptionPath).toString().split(QRegExp("[,]\\s*"), QString::SkipEmptyParts);
+	foreach(const QString &name, controllers) {
+		QCheckBox* cb = new QCheckBox(name);
+		QString caption = name + " controller";
+		cb->setText(caption);
+		cb->setObjectName(name);
+		int i = controllers.indexOf(name);
+		d->gridLayout->addWidget(cb,i/3,i%3);
+		cb->setChecked(!blackList_.contains(name));
+		connect(cb, SIGNAL(toggled(bool)), SLOT(controllerSelected(bool)));
+	}
+}
+
+void OptionsTabStatusPep::controllerSelected(bool checked)
+{
+	QCheckBox *box = qobject_cast<QCheckBox*>(sender());
+	QString name_ = box->objectName();
+	if (!name_.isEmpty()) {
+		if (!checked && !blackList_.contains(name_, Qt::CaseInsensitive)) {
+			blackList_ << name_;
+			controllersChanged_ = true;
+		}
+		else if (checked) {
+			blackList_.removeAll(name_);
+			controllersChanged_ = true;
+		}
+	}
+}
+
+void OptionsTabStatusPep::setData(PsiCon *psi, QWidget *)
+{
+	psi_ = psi;
+}
--- git.orig/src/options/opt_statuspep.h
+++ git/src/options/opt_statuspep.h
@@ -0,0 +1,36 @@
+#ifndef OPT_STAUSPEP_H
+#define OPT_STAUSPEP_H
+
+#include "optionstab.h"
+#include "common.h"
+#include "psicon.h"
+
+class QWidget;
+
+class OptionsTabStatusPep : public OptionsTab
+{
+	Q_OBJECT
+
+public:
+
+	OptionsTabStatusPep(QObject *parent);
+	~OptionsTabStatusPep();
+
+	QWidget *widget();
+	void applyOptions();
+	void restoreOptions();
+	void setData(PsiCon *psi, QWidget *);
+
+protected slots:
+	void controllerSelected(bool);
+
+private:
+	QWidget *w_;
+	PsiCon *psi_;
+	QStringList blackList_;
+	QString tuneFilters_;
+	bool controllersChanged_;
+};
+
+
+#endif // OPT_STAUSPEP_H
--- git.orig/src/options/opt_statuspep.ui
+++ git/src/options/opt_statuspep.ui
@@ -0,0 +1,108 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>OptStatusPep</class>
+ <widget class="QWidget" name="OptStatusPep">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>588</width>
+    <height>350</height>
+   </rect>
+  </property>
+  <property name="sizePolicy">
+   <sizepolicy hsizetype="Preferred" vsizetype="Expanding">
+    <horstretch>0</horstretch>
+    <verstretch>0</verstretch>
+   </sizepolicy>
+  </property>
+  <property name="windowTitle">
+   <string>Form</string>
+  </property>
+  <property name="autoFillBackground">
+   <bool>false</bool>
+  </property>
+  <layout class="QVBoxLayout" name="verticalLayout">
+   <item>
+    <widget class="QGroupBox" name="groupBox">
+     <property name="title">
+      <string>Tunes</string>
+     </property>
+     <property name="alignment">
+      <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>
+     </property>
+     <property name="flat">
+      <bool>false</bool>
+     </property>
+     <layout class="QVBoxLayout" name="verticalLayout_4">
+      <property name="spacing">
+       <number>6</number>
+      </property>
+      <item>
+       <widget class="QLabel" name="label">
+        <property name="text">
+         <string>Enter media file extensions to ignore them on tune sending</string>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <widget class="QLineEdit" name="tuneExtensions">
+        <property name="toolTip">
+         <string>Add extensions</string>
+        </property>
+        <property name="whatsThis">
+         <string>Ignored media file extensions on psi tunes sending</string>
+        </property>
+       </widget>
+      </item>
+      <item>
+       <widget class="QGroupBox" name="rightGroupBox">
+        <property name="sizePolicy">
+         <sizepolicy hsizetype="Expanding" vsizetype="Minimum">
+          <horstretch>0</horstretch>
+          <verstretch>0</verstretch>
+         </sizepolicy>
+        </property>
+        <property name="title">
+         <string>Tune Controllers</string>
+        </property>
+        <property name="flat">
+         <bool>false</bool>
+        </property>
+        <layout class="QVBoxLayout" name="verticalLayout_2">
+         <property name="spacing">
+          <number>0</number>
+         </property>
+         <property name="sizeConstraint">
+          <enum>QLayout::SetDefaultConstraint</enum>
+         </property>
+         <property name="margin">
+          <number>6</number>
+         </property>
+         <item>
+          <layout class="QGridLayout" name="gridLayout"/>
+         </item>
+        </layout>
+       </widget>
+      </item>
+     </layout>
+    </widget>
+   </item>
+   <item>
+    <spacer name="verticalSpacer">
+     <property name="orientation">
+      <enum>Qt::Vertical</enum>
+     </property>
+     <property name="sizeHint" stdset="0">
+      <size>
+       <width>20</width>
+       <height>40</height>
+      </size>
+     </property>
+    </spacer>
+   </item>
+  </layout>
+ </widget>
+ <resources/>
+ <connections/>
+</ui>
--- git.orig/src/src.pri
+++ git/src/src.pri
@@ -37,7 +37,7 @@ pep {
 	DEFINES += USE_PEP
 	CONFIG += tc_psifile
 	mac { CONFIG += tc_itunes }
-	windows { CONFIG += tc_winamp }
+	windows { CONFIG += tc_aimp tc_winamp }
 	unix:dbus:!mac { CONFIG += tc_mpris }
 }
 include($$PWD/tools/tunecontroller/tunecontroller.pri)
--- git.orig/src/tools/tunecontroller/aimptunecontroller.cpp
+++ git/src/tools/tunecontroller/aimptunecontroller.cpp
@@ -0,0 +1,137 @@
+/*
+ * aimptunecontroller.cpp
+ * Copyright (C) 2012 Vitaly Tonkacheyev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include "aimptunecontroller.h"
+#include "plugins/aimp/third-party/apiRemote.h"
+
+/**
+ * \class AimpTuneController
+ * \brief A controller class for AIMP3 player.
+ */
+
+static const int PLAYING = 2;
+static const int STOPPED = 0;
+static const WCHAR* AIMP_REMOTE_CLASS = (WCHAR *)L"AIMP2_RemoteInfo";
+
+AimpTuneController::AimpTuneController()
+: PollingTuneController(),
+  _tuneSent(false)
+{
+	startPoll();
+}
+
+HWND AimpTuneController::findAimp() const
+{
+	return FindWindow(AIMP_REMOTE_CLASS, AIMP_REMOTE_CLASS);
+}
+
+int AimpTuneController::getAimpStatus(const HWND &aimp) const
+{
+	if (aimp) {
+		return (int)SendMessage(aimp, WM_AIMP_PROPERTY, AIMP_RA_PROPERTY_PLAYER_STATE | AIMP_RA_PROPVALUE_GET, 0);
+	}
+	return STOPPED;
+}
+
+void AimpTuneController::check()
+{
+	HWND aimp = findAimp();
+	if (getAimpStatus(aimp) == PLAYING) {
+		sendTune(getTune());
+	}
+	else {
+		clearTune();
+	}
+	PollingTuneController::check();
+}
+
+Tune AimpTuneController::currentTune() const
+{
+	return _currentTune;
+}
+
+Tune AimpTuneController::getTune() const
+{
+	HANDLE aFile=OpenFileMapping(FILE_MAP_READ, TRUE, AIMP_REMOTE_CLASS);
+	PAIMPRemoteFileInfo aInfo = (PAIMPRemoteFileInfo)MapViewOfFile(aFile, FILE_MAP_READ, 0, 0, AIMPRemoteAccessMapFileSize);
+	if (aInfo != NULL) {
+		wchar_t *str = (wchar_t *)((char*)aInfo + sizeof(*aInfo));
+		QString album = QString::fromWCharArray(str, aInfo->AlbumLength);
+		str += aInfo->AlbumLength;
+		QString artist = QString::fromWCharArray(str, aInfo->ArtistLength);
+		str += aInfo->ArtistLength + aInfo->DateLength;
+		QString url = QString::fromWCharArray(str, aInfo->FileNameLength);
+		str += aInfo->FileNameLength + aInfo->GenreLength;
+		QString title = QString::fromWCharArray(str, aInfo->TitleLength);
+		unsigned long trackNumber = aInfo->TrackNumber;
+		unsigned long time = aInfo->Duration;
+		Tune tune = Tune();
+		if (!url.isEmpty()) {
+			if (!title.isEmpty()) {
+				tune.setName(title);
+			}
+			else {
+				int index = url.replace("/", "\\").lastIndexOf("\\");
+				if (index > 0) {
+					QString filename = url.right(url.length()-index-1);
+					index = filename.lastIndexOf(".");
+					title = (index > 0) ? filename.left(index) : filename;
+				}
+				else {
+					title = url;
+				}
+				tune.setName(title);
+			}
+			if (trackNumber > 0) {
+				tune.setTrack(QString::number(trackNumber));
+			}
+			if (time > 0) {
+				tune.setTime((uint)time);
+			}
+			if (!artist.isEmpty()) {
+				tune.setArtist(artist);
+			}
+			if (!album.isEmpty()) {
+				tune.setAlbum(album);
+			}
+			tune.setURL(url);
+		}
+		return tune;
+	}
+	UnmapViewOfFile(aInfo);
+	CloseHandle(aFile);
+	return Tune();
+}
+
+void AimpTuneController::sendTune(const Tune &tune)
+{
+	if (tune != _currentTune && !tune.isNull()) {
+		_currentTune = tune;
+		_tuneSent = true;
+	}
+}
+
+void AimpTuneController::clearTune()
+{
+	if (_tuneSent) {
+		_currentTune = Tune();
+		_tuneSent = false;
+	}
+}
--- git.orig/src/tools/tunecontroller/aimptunecontroller.h
+++ git/src/tools/tunecontroller/aimptunecontroller.h
@@ -0,0 +1,51 @@
+/*
+ * aimptunecontroller.h
+ * Copyright (C) 2012 Vitaly Tonkacheyev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef AIMPTUNECONTROLLER_H
+#define AIMPTUNECONTROLLER_H
+
+#include "pollingtunecontroller.h"
+#include "tune.h"
+#include "windows.h"
+
+class AimpTuneController : public PollingTuneController
+{
+	Q_OBJECT
+
+public:
+	AimpTuneController();
+	Tune currentTune() const;
+
+protected slots:
+	void check();
+
+private:
+	Tune getTune() const;
+	HWND findAimp() const;
+	int getAimpStatus(const HWND &aimp) const;
+	void sendTune(const Tune &tune);
+	void clearTune();
+
+private:
+	Tune _currentTune;
+	bool _tuneSent;
+};
+
+#endif
--- git.orig/src/tools/tunecontroller/itunestunecontroller.cpp
+++ git/src/tools/tunecontroller/itunestunecontroller.cpp
@@ -0,0 +1,113 @@
+/*
+ * itunescontroller.cpp
+ * Copyright (C) 2006  Remko Troncon
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include <QtGlobal>
+#include <QString>
+#include <QTime>
+#include <QDebug>
+
+#include <CoreFoundation/CoreFoundation.h>
+
+#include "itunestunecontroller.h"
+
+/**
+ * \class ITunesController
+ * \brief A controller for the Mac OS X version of iTunes.
+ */
+
+static QString CFStringToQString(CFStringRef s)
+{
+	QString result;
+
+	if (s != NULL) {
+		CFIndex length = CFStringGetMaximumSizeForEncoding(CFStringGetLength(s), kCFStringEncodingUTF8) + 1;
+		char* buffer = new char[length];
+		if (CFStringGetCString(s, buffer, length, kCFStringEncodingUTF8)) {
+			result = QString::fromUtf8(buffer);
+		}
+		else {
+			qWarning("itunesplayer.cpp: CFString conversion failed.");
+		}
+		delete[] buffer;
+	}
+    return result;
+}
+
+
+ITunesController::ITunesController()
+{
+	// TODO: Poll iTunes for current playing tune
+	CFNotificationCenterRef center = CFNotificationCenterGetDistributedCenter();
+	CFNotificationCenterAddObserver(center, this, ITunesController::iTunesCallback, CFSTR("com.apple.iTunes.playerInfo"), NULL, CFNotificationSuspensionBehaviorDeliverImmediately);
+}
+
+ITunesController::~ITunesController()
+{
+	CFNotificationCenterRef center = CFNotificationCenterGetDistributedCenter();
+	CFNotificationCenterRemoveObserver(center, this, CFSTR("com.apple.iTunes.playerInfo"), NULL);
+}
+
+Tune ITunesController::currentTune() const
+{
+	return currentTune_;
+}
+
+void ITunesController::iTunesCallback(CFNotificationCenterRef,void* observer,CFStringRef,const void*, CFDictionaryRef info)
+{
+	Tune tune;
+	ITunesController* controller = (ITunesController*) observer;
+
+	CFStringRef cf_state = (CFStringRef) CFDictionaryGetValue(info, CFSTR("Player State"));
+	if (CFStringCompare(cf_state,CFSTR("Paused"),0) == kCFCompareEqualTo) {
+		//qDebug() << "itunesplayer.cpp: Paused";
+		emit controller->stopped();
+	}
+	else if (CFStringCompare(cf_state,CFSTR("Stopped"),0) == kCFCompareEqualTo) {
+		//qDebug() << "itunesplayer.cpp: Stopped";
+		emit controller->stopped();
+	}
+	else if (CFStringCompare(cf_state,CFSTR("Playing"),0) == kCFCompareEqualTo) {
+		//qDebug() << "itunesplayer.cpp: Playing";
+		tune.setArtist(CFStringToQString((CFStringRef) CFDictionaryGetValue(info, CFSTR("Artist"))));
+		tune.setName(CFStringToQString((CFStringRef) CFDictionaryGetValue(info, CFSTR("Name"))));
+		tune.setAlbum(CFStringToQString((CFStringRef) CFDictionaryGetValue(info, CFSTR("Album"))));
+
+		CFNumberRef cf_track = (CFNumberRef) CFDictionaryGetValue(info, CFSTR("Track Number"));
+		if (cf_track) {
+			int tracknr;
+			if (!CFNumberGetValue(cf_track,kCFNumberIntType,&tracknr)) {
+				qWarning("itunesplayer.cpp: Number value conversion failed.");
+			}
+			tune.setTrack(QString::number(tracknr));
+		}
+
+		CFNumberRef cf_time = (CFNumberRef) CFDictionaryGetValue(info, CFSTR("Total Time"));
+		int time = 0;
+		if (cf_time && !CFNumberGetValue(cf_time,kCFNumberIntType,&time)) {
+			qWarning("itunesplayer.cpp: Number value conversion failed.");
+		}
+		tune.setTime((unsigned int) (time / 1000));
+		controller->currentTune_ = tune;
+		emit controller->playing(tune);
+	}
+	else {
+		qWarning("itunesplayer.cpp: Unknown state.");
+	}
+}
--- git.orig/src/tools/tunecontroller/itunestunecontroller.h
+++ git/src/tools/tunecontroller/itunestunecontroller.h
@@ -0,0 +1,22 @@
+#ifndef ITUNESTUNECONTROLLER_H
+#define ITUNESTUNECONTROLLER_H
+
+#include <QString>
+#include <CoreFoundation/CoreFoundation.h>
+
+#include "tunecontrollerinterface.h"
+
+class ITunesController : public TuneController
+{
+public:
+	ITunesController();
+	~ITunesController();
+
+	virtual Tune currentTune() const;
+
+private:
+	static void iTunesCallback(CFNotificationCenterRef,void*,CFStringRef,const void*, CFDictionaryRef info);
+	Tune currentTune_;
+};
+
+#endif
--- git.orig/src/tools/tunecontroller/plugins/aimp/aimpplugin.cpp
+++ git/src/tools/tunecontroller/plugins/aimp/aimpplugin.cpp
@@ -0,0 +1,61 @@
+/*
+ * aimpplugin.cpp
+ * Copyright (C) 2012 Vitaly Tonkacheyev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef QT_STATICPLUGIN
+#define QT_STATICPLUGIN
+#endif
+
+#include <QtCore>
+#include <QObject>
+#include <QString>
+
+#include "aimptunecontroller.h"
+#include "tunecontrollerplugin.h"
+
+class AIMPPlugin : public QObject, public TuneControllerPlugin
+{
+
+	Q_OBJECT
+
+	Q_INTERFACES(TuneControllerPlugin)
+#ifdef HAVE_QT5
+	Q_PLUGIN_METADATA(IID "org.psi-im.Psi.TuneControllerPlugin")
+#endif
+
+public:
+	virtual QString name();
+	virtual TuneController* createController();
+};
+
+#ifndef HAVE_QT5
+Q_EXPORT_PLUGIN2(aimpplugin, AIMPPlugin);
+#endif
+
+QString AIMPPlugin::name()
+{
+	return "AIMP3";
+}
+
+TuneController* AIMPPlugin::createController()
+{
+    return new AimpTuneController();
+}
+
+#include "aimpplugin.moc"
--- git.orig/src/tools/tunecontroller/plugins/aimp/third-party/apiRemote.h
+++ git/src/tools/tunecontroller/plugins/aimp/third-party/apiRemote.h
@@ -0,0 +1,213 @@
+/************************************************/
+/*                                              */
+/*          AIMP Programming Interface          */
+/*               v3.60 build 1400               */
+/*                                              */
+/*                Artem Izmaylov                */
+/*                (C) 2006-2014                 */
+/*                 www.aimp.ru                  */
+/*              ICQ: 345-908-513                */
+/*            Mail: support@aimp.ru             */
+/*                                              */
+/************************************************/
+
+#ifndef apiRemoteH
+#define apiRemoteH
+
+#include <windows.h>
+
+const char AIMPRemoteAccessClass[] = "AIMP2_RemoteInfo";
+const int  AIMPRemoteAccessMapFileSize = 2048;
+
+#pragma pack(push, 1)
+struct TAIMPRemoteFileInfo
+{
+	DWORD Deprecated1;
+	BOOL Active;
+	DWORD BitRate;
+	DWORD Channels;
+	DWORD Duration;
+	INT64 FileSize;
+	DWORD FileMark;
+	DWORD SampleRate;
+	DWORD TrackNumber;
+	DWORD AlbumLength;
+	DWORD ArtistLength;
+	DWORD DateLength;
+	DWORD FileNameLength;
+	DWORD GenreLength;
+	DWORD TitleLength;
+	DWORD Deprecated2[6];
+};
+#pragma pack(pop)
+typedef TAIMPRemoteFileInfo *PAIMPRemoteFileInfo;
+
+// Messages, which you can send to window with "AIMPRemoteAccessClass" class
+// You can receive Window Handle via FindWindow function (see MSDN for details)
+const int WM_AIMP_COMMAND  = WM_USER + 0x75;
+const int WM_AIMP_NOTIFY   = WM_USER + 0x76;
+const int WM_AIMP_PROPERTY = WM_USER + 0x77;
+
+// See AIMP_RA_CMD_GET_ALBUMART command
+const int WM_AIMP_COPYDATA_ALBUMART_ID = 0x41495043;
+
+//==============================================================================
+// + How to:
+//     GET:  SendMessage(Handle, WM_AIMP_PROPERTY, PropertyID | AIMP_RA_PROPVALUE_GET, 0);
+//     SET:  SendMessage(Handle, WM_AIMP_PROPERTY, PropertyID | AIMP_RA_PROPVALUE_SET, NewValue);
+//
+//     Receive Change Notification:
+//       1) You should register notification hook using AIMP_RA_CMD_REGISTER_NOTIFY command
+//       2) When property will change you receive WM_AIMP_NOTIFY message with following params:
+//          WParam: AIMP_RA_NOTIFY_PROPERTY (Notification ID)
+//          LParam: Property ID
+//
+// Properties ID:
+//==============================================================================
+
+const int AIMP_RA_PROPVALUE_GET = 0;
+const int AIMP_RA_PROPVALUE_SET = 1;
+
+const int AIMP_RA_PROPERTY_MASK = 0xFFFFFFF0;
+
+// !! ReadOnly
+// Returns player version:
+// HiWord: Version ID (for example: 301 -> v3.01)
+// LoWord: Build Number
+const int AIMP_RA_PROPERTY_VERSION = 0x10;
+
+// GET: Returns current position of now playing track (in msec)
+// SET: LParam: position (in msec)
+const int AIMP_RA_PROPERTY_PLAYER_POSITION = 0x20;
+
+// !! ReadOnly
+// Returns duration of now playing track (in msec)
+const int AIMP_RA_PROPERTY_PLAYER_DURATION = 0x30;
+
+// !! ReadOnly
+// Returns current player state
+//  0 = Stopped
+//  1 = Paused
+//  2 = Playing
+const int AIMP_RA_PROPERTY_PLAYER_STATE = 0x40;
+
+// GET: Return current volume [0..100] (%)
+// SET: LParam: volume [0..100] (%)
+//      Returns 0, if fails
+const int AIMP_RA_PROPERTY_VOLUME = 0x50;
+
+// GET: Return current mute state [0..1]
+// SET: LParam: Mute state [0..1]
+//      Returns 0, if fails
+const int AIMP_RA_PROPERTY_MUTE = 0x60;
+
+// GET: Return track repeat state [0..1]
+// SET: LParam: Track Repeat state [0..1]
+//      Returns 0, if fails
+const int AIMP_RA_PROPERTY_TRACK_REPEAT = 0x70;
+
+// GET: Return shuffle state [0..1]
+// SET: LParam: shuffle state [0..1]
+//      Returns 0, if fails
+const int AIMP_RA_PROPERTY_TRACK_SHUFFLE = 0x80;
+
+// GET: Return radio capture state [0..1]
+// SET: LParam: radio capture state [0..1]
+//      Returns 0, if fails
+const int AIMP_RA_PROPERTY_RADIOCAP = 0x90;
+
+// GET: Return full screen visualization mode [0..1]
+// SET: LParam: full screen visualization mode [0..1]
+//      Returns 0, if fails
+const int AIMP_RA_PROPERTY_VISUAL_FULLSCREEN = 0xA0;
+
+//==============================================================================
+// Commands ID for WM_AIMP_COMMAND message: (Command ID must be defined in WParam)
+//==============================================================================
+
+const int AIMP_RA_CMD_BASE = 10;
+
+// LParam: Window Handle, which will receive WM_AIMP_NOTIFY message from AIMP
+// See description for WM_AIMP_NOTIFY message for details
+const int AIMP_RA_CMD_REGISTER_NOTIFY = AIMP_RA_CMD_BASE + 1;
+
+// LParam: Window Handle
+const int AIMP_RA_CMD_UNREGISTER_NOTIFY = AIMP_RA_CMD_BASE + 2;
+
+// Start / Resume playback
+// See AIMP_RA_PROPERTY_PLAYER_STATE
+const int AIMP_RA_CMD_PLAY = AIMP_RA_CMD_BASE + 3;
+
+// Pause / Start playback
+// See AIMP_RA_PROPERTY_PLAYER_STATE
+const int AIMP_RA_CMD_PLAYPAUSE = AIMP_RA_CMD_BASE + 4;
+
+// Pause / Resume playback
+// See AIMP_RA_PROPERTY_PLAYER_STATE
+const int AIMP_RA_CMD_PAUSE = AIMP_RA_CMD_BASE + 5;
+
+// Stop playback
+// See AIMP_RA_PROPERTY_PLAYER_STATE
+const int AIMP_RA_CMD_STOP = AIMP_RA_CMD_BASE + 6;
+
+// Next Track
+const int AIMP_RA_CMD_NEXT = AIMP_RA_CMD_BASE + 7;
+
+// Previous Track
+const int AIMP_RA_CMD_PREV = AIMP_RA_CMD_BASE + 8;
+
+// Next Visualization
+const int AIMP_RA_CMD_VISUAL_NEXT = AIMP_RA_CMD_BASE + 9;
+
+// Previous Visualization
+const int AIMP_RA_CMD_VISUAL_PREV = AIMP_RA_CMD_BASE + 10;
+
+// Close the program
+const int AIMP_RA_CMD_QUIT = AIMP_RA_CMD_BASE + 11;
+
+// Execute "Add files" dialog
+const int AIMP_RA_CMD_ADD_FILES = AIMP_RA_CMD_BASE + 12;
+
+// Execute "Add folders" dialog
+const int AIMP_RA_CMD_ADD_FOLDERS = AIMP_RA_CMD_BASE + 13;
+
+// Execute "Add Playlists" dialog
+const int AIMP_RA_CMD_ADD_PLAYLISTS = AIMP_RA_CMD_BASE + 14;
+
+// Execute "Add URL" dialog
+const int AIMP_RA_CMD_ADD_URL = AIMP_RA_CMD_BASE + 15;
+
+// Execute "Open Files" dialog
+const int AIMP_RA_CMD_OPEN_FILES = AIMP_RA_CMD_BASE + 16;
+
+// Execute "Open Folders" dialog
+const int AIMP_RA_CMD_OPEN_FOLDERS = AIMP_RA_CMD_BASE + 17;
+
+// Execute "Open Playlist" dialog
+const int AIMP_RA_CMD_OPEN_PLAYLISTS = AIMP_RA_CMD_BASE + 18;
+
+// AlbumArt Request
+const int AIMP_RA_CMD_GET_ALBUMART = AIMP_RA_CMD_BASE + 19;
+
+// Start First Visualization
+const int AIMP_RA_CMD_VISUAL_START = AIMP_RA_CMD_BASE + 20;
+
+// Stop Visualization
+const int AIMP_RA_CMD_VISUAL_STOP = AIMP_RA_CMD_BASE + 21;
+
+//==============================================================================
+// Notifications ID for WM_AIMP_NOTIFY message: (Notification ID in WParam)
+//==============================================================================
+
+const int AIMP_RA_NOTIFY_BASE = 0;
+
+const int AIMP_RA_NOTIFY_TRACK_INFO = AIMP_RA_NOTIFY_BASE + 1;
+
+// Called, when audio stream starts playing or when an Internet radio station changes the track
+const int AIMP_RA_NOTIFY_TRACK_START = AIMP_RA_NOTIFY_BASE + 2;
+
+// Called, when property has been changed
+// LParam: Property ID
+const int AIMP_RA_NOTIFY_PROPERTY = AIMP_RA_NOTIFY_BASE + 3; 
+
+#endif // !apiRemoteH
\ В конце файла нет новой строки
--- git.orig/src/tools/tunecontroller/plugins/itunes/itunescontroller.cpp
+++ git/src/tools/tunecontroller/plugins/itunes/itunescontroller.cpp
@@ -1,113 +0,0 @@
-/*
- * itunescontroller.cpp
- * Copyright (C) 2006  Remko Troncon
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- */
-
-#include <QtGlobal>
-#include <QString>
-#include <QTime>
-#include <QDebug>
-
-#include <CoreFoundation/CoreFoundation.h>
-
-#include "itunescontroller.h"
-
-/**
- * \class ITunesController
- * \brief A controller for the Mac OS X version of iTunes.
- */
-
-static QString CFStringToQString(CFStringRef s)
-{
-	QString result;
-
-	if (s != NULL) {
-		CFIndex length = CFStringGetMaximumSizeForEncoding(CFStringGetLength(s), kCFStringEncodingUTF8) + 1;
-		char* buffer = new char[length];
-		if (CFStringGetCString(s, buffer, length, kCFStringEncodingUTF8)) {
-			result = QString::fromUtf8(buffer);
-		}
-		else {
-			qWarning("itunesplayer.cpp: CFString conversion failed.");
-		}
-		delete[] buffer;
-	}
-    return result;
-}
-
-
-ITunesController::ITunesController()
-{
-	// TODO: Poll iTunes for current playing tune
-	CFNotificationCenterRef center = CFNotificationCenterGetDistributedCenter();
-	CFNotificationCenterAddObserver(center, this, ITunesController::iTunesCallback, CFSTR("com.apple.iTunes.playerInfo"), NULL, CFNotificationSuspensionBehaviorDeliverImmediately);
-}
-
-ITunesController::~ITunesController()
-{
-	CFNotificationCenterRef center = CFNotificationCenterGetDistributedCenter();
-	CFNotificationCenterRemoveObserver(center, this, CFSTR("com.apple.iTunes.playerInfo"), NULL);
-}
-
-Tune ITunesController::currentTune() const
-{
-	return currentTune_;
-}
-
-void ITunesController::iTunesCallback(CFNotificationCenterRef,void* observer,CFStringRef,const void*, CFDictionaryRef info)
-{
-	Tune tune;
-	ITunesController* controller = (ITunesController*) observer;
-
-	CFStringRef cf_state = (CFStringRef) CFDictionaryGetValue(info, CFSTR("Player State"));
-	if (CFStringCompare(cf_state,CFSTR("Paused"),0) == kCFCompareEqualTo) {
-		//qDebug() << "itunesplayer.cpp: Paused";
-		emit controller->stopped();
-	}
-	else if (CFStringCompare(cf_state,CFSTR("Stopped"),0) == kCFCompareEqualTo) {
-		//qDebug() << "itunesplayer.cpp: Stopped";
-		emit controller->stopped();
-	}
-	else if (CFStringCompare(cf_state,CFSTR("Playing"),0) == kCFCompareEqualTo) {
-		//qDebug() << "itunesplayer.cpp: Playing";
-		tune.setArtist(CFStringToQString((CFStringRef) CFDictionaryGetValue(info, CFSTR("Artist"))));
-		tune.setName(CFStringToQString((CFStringRef) CFDictionaryGetValue(info, CFSTR("Name"))));
-		tune.setAlbum(CFStringToQString((CFStringRef) CFDictionaryGetValue(info, CFSTR("Album"))));
-
-		CFNumberRef cf_track = (CFNumberRef) CFDictionaryGetValue(info, CFSTR("Track Number"));
-		if (cf_track) {
-			int tracknr;
-			if (!CFNumberGetValue(cf_track,kCFNumberIntType,&tracknr)) {
-				qWarning("itunesplayer.cpp: Number value conversion failed.");
-			}
-			tune.setTrack(QString::number(tracknr));
-		}
-
-		CFNumberRef cf_time = (CFNumberRef) CFDictionaryGetValue(info, CFSTR("Total Time"));
-		int time = 0;
-		if (cf_time && !CFNumberGetValue(cf_time,kCFNumberIntType,&time)) {
-			qWarning("itunesplayer.cpp: Number value conversion failed.");
-		}
-		tune.setTime((unsigned int) (time / 1000));
-		controller->currentTune_ = tune;
-		emit controller->playing(tune);
-	}
-	else {
-		qWarning("itunesplayer.cpp: Unknown state.");
-	}
-}
--- git.orig/src/tools/tunecontroller/plugins/itunes/itunescontroller.h
+++ git/src/tools/tunecontroller/plugins/itunes/itunescontroller.h
@@ -1,22 +0,0 @@
-#ifndef ITUNESCONTROLLER_H
-#define ITUNESCONTROLLER_H
-
-#include <QString>
-#include <CoreFoundation/CoreFoundation.h>
-
-#include "tunecontrollerinterface.h"
-
-class ITunesController : public TuneController
-{
-public:
-	ITunesController();
-	~ITunesController();
-
-	virtual Tune currentTune() const;
-
-private:
-	static void iTunesCallback(CFNotificationCenterRef,void*,CFStringRef,const void*, CFDictionaryRef info);
-	Tune currentTune_;
-};
-
-#endif
--- git.orig/src/tools/tunecontroller/plugins/itunes/itunesplugin.cpp
+++ git/src/tools/tunecontroller/plugins/itunes/itunesplugin.cpp
@@ -26,7 +26,7 @@
 #include <QObject>
 #include <QString>
 
-#include "itunescontroller.h"
+#include "itunestunecontroller.h"
 #include "tunecontrollerplugin.h"
 
 class ITunesPlugin : public QObject, public TuneControllerPlugin
--- git.orig/src/tools/tunecontroller/plugins/winamp/winampcontroller.cpp
+++ git/src/tools/tunecontroller/plugins/winamp/winampcontroller.cpp
@@ -1,197 +0,0 @@
-/*
- * winampcontroller.cpp
- * Copyright (C) 2006  Remko Troncon
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- */
-
-#include <windows.h>
-
-#ifdef Q_CC_MSVC
-#pragma warning(push)
-#pragma warning(disable: 4100)
-#endif
-
-// this file generates eight C4100 warnings, when compiled with MSVC2003
-#include "third-party/wa_ipc.h"
-
-#ifdef Q_CC_MSVC
-#pragma warning(pop)
-#endif
-
-#include "winampcontroller.h"
-
-
-/**
- * \class WinAmpController
- * \brief A controller for WinAmp.
- */
-
-static const int NormInterval = 3000;
-static const int AntiscrollInterval = 100;
-
-/**
- * \brief Constructs the controller.
- */
-WinAmpController::WinAmpController()
-: PollingTuneController(),
-  antiscrollCounter_(0)
-{
-	startPoll();
-	setInterval(NormInterval);
-}
-
-template <typename char_type> const size_t length (const char_type * begin)
-{
-	const char_type * end = begin;
-	for (; *end; ++end);
-	return end - begin;
-}
-
-// Returns a title of a track currently being played by WinAmp with given HWND (passed in waWnd)
-QPair<bool, QString> WinAmpController::getTrackTitle(const HWND &waWnd) const
-{
-	TCHAR waTitle[2048];
-	QString title;
-
-	// Get WinAmp window title. It always contains name of the track
-	SendMessage (waWnd, WM_GETTEXT, static_cast<WPARAM> (sizeof (waTitle) / sizeof (waTitle[0])), reinterpret_cast<LPARAM> (waTitle));
-	// Now, waTitle contains WinAmp window title
-	title = QString ((const QChar *) waTitle, length<TCHAR> ((const TCHAR *) waTitle));
-	if (title[0] == '*' || (title.length () && title[title.length() - 1] == '*')) {
-		// request to be called again soon.
-		return QPair<bool, QString>(false, QString());
-	}
-
-	// Check whether there is a need to do the all stuff
-	if (!title.length()) {
-		return QPair<bool, QString>(true,title);
-	}
-
-	QString winamp (" - Winamp ***");
-	int winampLength = winamp.length();
-
-	// Is title scrolling on the taskbar enabled?
-	title += title + title;
-	int waLast = title.indexOf (winamp, -1);
-	if (waLast != -1) {
-		if (title.length()) {
-			title.remove (waLast, title.length () - waLast);
-		}
-		int waFirst;
-		while ((waFirst = title.indexOf (winamp)) != -1) {
-			title.remove (0, waFirst + winampLength);
-		}
-	}
-	else {
-		title = QString ((const QChar *) waTitle, length<TCHAR> ((const TCHAR *) waTitle)); // Title is not scrolling
-	}
-
-	// Remove leading and trailing spaces
-	title  = title.trimmed();
-
-	// Remove trailing " - Winamp" from title
-	if (title.length ()) {
-		winamp = " - Winamp";
-		winampLength = winamp.length ();
-		int waFirst = title.indexOf (winamp);
-		if (waFirst != -1)
-		{
-			title.remove (waFirst, waFirst + winampLength);
-		}
-	}
-
-	// Remove track number from title
-	if (title.length ()) {
-		QString dot(". ");
-		int dotFirst = title.indexOf (dot);
-		if (dotFirst != -1) {
-			// All symbols before the dot are digits?
-			bool allDigits = true;
-			for (int pos = dotFirst; pos > 0; --pos) {
-				allDigits = allDigits && title[pos].isNumber();
-			}
-			if (allDigits) {
-				title.remove(0, dotFirst + dot.length ());
-			}
-		}
-	}
-
-	// Remove leading and trailing spaces
-	if (title.length ()) {
-		while (title.length () && title[0] == ' ') {
-			title.remove (0, 1);
-		}
-		while (title.length () && title[title.length () - 1] == ' ') {
-			title.remove (title.length () - 1, 1);
-		}
-	}
-
-	return QPair<bool, QString>(true,title);
-}
-
-
-/**
- * Polls for new song info.
- */
-void WinAmpController::check()
-{
-
-	Tune tune;
-#ifdef UNICODE
-	HWND h = FindWindow(L"Winamp v1.x", NULL);
-#else
-	HWND h = FindWindow("Winamp v1.x", NULL);
-#endif
-	if (h && SendMessage(h, WM_WA_IPC, 0, IPC_ISPLAYING) == 1) {
-		tune = getTune(h);
-	}
-	prevTune_ = tune;
-	setInterval(NormInterval);
-	PollingTuneController::check();
-}
-
-Tune WinAmpController::getTune(const HWND &hWnd)
-{
-	Tune tune = Tune();
-	int position = (int)SendMessage(hWnd, WM_WA_IPC, 0, IPC_GETLISTPOS);
-	if (position != -1) {
-		if (hWnd && SendMessage(hWnd,WM_WA_IPC,0,IPC_ISPLAYING) == 1) {
-			QPair<bool, QString> trackpair(getTrackTitle(hWnd));
-			if (!trackpair.first) {
-				// getTrackTitle wants us to retry in a few ms...
-				int interval = AntiscrollInterval;
-				if (++antiscrollCounter_ > 10) {
-					antiscrollCounter_ = 0;
-					interval = NormInterval;
-				}
-				setInterval(interval);
-				return Tune();
-			}
-			antiscrollCounter_ = 0;
-			tune.setName(trackpair.second);
-			tune.setURL(trackpair.second);
-			tune.setTrack(QString::number(position + 1));
-			tune.setTime(SendMessage(hWnd, WM_WA_IPC, 1, IPC_GETOUTPUTTIME));
-		}
-	}
-	return tune;
-}
-
-Tune WinAmpController::currentTune() const
-{
-	return prevTune_;
-}
--- git.orig/src/tools/tunecontroller/plugins/winamp/winampcontroller.h
+++ git/src/tools/tunecontroller/plugins/winamp/winampcontroller.h
@@ -1,48 +0,0 @@
-/*
- * winampcontroller.h
- * Copyright (C) 2006  Remko Troncon
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- */
-
-#ifndef WINAMPCONTROLLER_H
-#define WINAMPCONTROLLER_H
-
-#include "pollingtunecontroller.h"
-
-#include <windows.h>
-#include <QPair>
-
-class WinAmpController : public PollingTuneController
-{
-	Q_OBJECT
-public:
-	WinAmpController();
-	virtual Tune currentTune() const;
-
-private:
-	Tune getTune(const HWND &hWnd);
-	QPair<bool, QString> getTrackTitle(const HWND &waWnd) const;
-
-protected slots:
-	void check();
-
-private:
-	Tune prevTune_;
-	int antiscrollCounter_;
-};
-
-#endif
--- git.orig/src/tools/tunecontroller/plugins/winamp/winampplugin.cpp
+++ git/src/tools/tunecontroller/plugins/winamp/winampplugin.cpp
@@ -28,7 +28,7 @@ QString WinAmpPlugin::name()
 
 TuneController* WinAmpPlugin::createController()
 {
-	return new WinAmpController();
+	return new WinAmpTuneController();
 }
 
 #ifndef HAVE_QT5
--- git.orig/src/tools/tunecontroller/plugins/winamp/winampplugin.h
+++ git/src/tools/tunecontroller/plugins/winamp/winampplugin.h
@@ -29,7 +29,7 @@
 #include <QObject>
 #include <QString>
 
-#include "winampcontroller.h"
+#include "winamptunecontroller.h"
 #include "tunecontrollerplugin.h"
 
 class WinAmpPlugin : public QObject, public TuneControllerPlugin
--- git.orig/src/tools/tunecontroller/tunecontrollermanager.cpp
+++ git/src/tools/tunecontroller/tunecontrollermanager.cpp
@@ -172,6 +172,14 @@ Q_IMPORT_PLUGIN(winampplugin)
 #endif
 #endif
 
+#ifdef TC_AIMP
+#ifdef HAVE_QT5
+Q_IMPORT_PLUGIN(AIMPPlugin)
+#else
+Q_IMPORT_PLUGIN(aimpplugin)
+#endif
+#endif
+
 #ifdef TC_PSIFILE
 #ifdef HAVE_QT5
 Q_IMPORT_PLUGIN(PsiFilePlugin)
--- git.orig/src/tools/tunecontroller/tunecontroller.pri
+++ git/src/tools/tunecontroller/tunecontroller.pri
@@ -25,10 +25,10 @@ tc_itunes {
 		INCLUDEPATH += $$ITUNES_PLUGIN_PATH
 
 		HEADERS += \
-			$$ITUNES_PLUGIN_PATH/itunescontroller.h
+			$$PWD/itunestunecontroller.h
 
 		SOURCES += \
-			$$ITUNES_PLUGIN_PATH/itunescontroller.cpp \
+			$$PWD/itunestunecontroller.cpp \
 			$$ITUNES_PLUGIN_PATH/itunesplugin.cpp
 
 		QMAKE_LFLAGS += -framework CoreFoundation
@@ -42,11 +42,11 @@ tc_winamp {
 	INCLUDEPATH += $$WINAMP_PLUGIN_PATH
 
 	HEADERS += \
-		$$WINAMP_PLUGIN_PATH/winampcontroller.h \
+		$$PWD/winamptunecontroller.h \
 		$$WINAMP_PLUGIN_PATH/winampplugin.h
 
 	SOURCES += \
-		$$WINAMP_PLUGIN_PATH/winampcontroller.cpp \
+		$$PWD/winamptunecontroller.cpp \
 		$$WINAMP_PLUGIN_PATH/winampplugin.cpp
 
 	LIBS += -lUser32
@@ -78,3 +78,17 @@ tc_mpris {
 		$$PWD/mpristunecontroller.cpp \
 		$$MPRIS_PLUGIN_PATH/mprisplugin.cpp
 }
+
+#AIMP
+tc_aimp {
+	DEFINES += TC_AIMP
+	AIMP_PLUGIN_PATH = $$PWD/plugins/aimp
+	INCLUDEPATH += $$AIMP_PLUGIN_PATH
+
+	HEADERS += \
+		$$PWD/aimptunecontroller.h
+
+	SOURCES += \
+		$$PWD/aimptunecontroller.cpp \
+		$$AIMP_PLUGIN_PATH/aimpplugin.cpp
+}
--- git.orig/src/tools/tunecontroller/winamptunecontroller.cpp
+++ git/src/tools/tunecontroller/winamptunecontroller.cpp
@@ -0,0 +1,197 @@
+/*
+ * winamptunecontroller.cpp
+ * Copyright (C) 2006  Remko Troncon
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include <windows.h>
+
+#ifdef Q_CC_MSVC
+#pragma warning(push)
+#pragma warning(disable: 4100)
+#endif
+
+// this file generates eight C4100 warnings, when compiled with MSVC2003
+#include "plugins/winamp/third-party/wa_ipc.h"
+
+#ifdef Q_CC_MSVC
+#pragma warning(pop)
+#endif
+
+#include "winamptunecontroller.h"
+
+
+/**
+ * \class WinAmpTuneController
+ * \brief A controller for WinAmp.
+ */
+
+static const int NormInterval = 3000;
+static const int AntiscrollInterval = 100;
+
+/**
+ * \brief Constructs the controller.
+ */
+WinAmpTuneController::WinAmpTuneController()
+: PollingTuneController(),
+  antiscrollCounter_(0)
+{
+	startPoll();
+	setInterval(NormInterval);
+}
+
+template <typename char_type> const size_t length (const char_type * begin)
+{
+	const char_type * end = begin;
+	for (; *end; ++end);
+	return end - begin;
+}
+
+// Returns a title of a track currently being played by WinAmp with given HWND (passed in waWnd)
+QPair<bool, QString> WinAmpTuneController::getTrackTitle(const HWND &waWnd) const
+{
+	TCHAR waTitle[2048];
+	QString title;
+
+	// Get WinAmp window title. It always contains name of the track
+	SendMessage (waWnd, WM_GETTEXT, static_cast<WPARAM> (sizeof (waTitle) / sizeof (waTitle[0])), reinterpret_cast<LPARAM> (waTitle));
+	// Now, waTitle contains WinAmp window title
+	title = QString ((const QChar *) waTitle, length<TCHAR> ((const TCHAR *) waTitle));
+	if (title[0] == '*' || (title.length () && title[title.length() - 1] == '*')) {
+		// request to be called again soon.
+		return QPair<bool, QString>(false, QString());
+	}
+
+	// Check whether there is a need to do the all stuff
+	if (!title.length()) {
+		return QPair<bool, QString>(true,title);
+	}
+
+	QString winamp (" - Winamp ***");
+	int winampLength = winamp.length();
+
+	// Is title scrolling on the taskbar enabled?
+	title += title + title;
+	int waLast = title.indexOf (winamp, -1);
+	if (waLast != -1) {
+		if (title.length()) {
+			title.remove (waLast, title.length () - waLast);
+		}
+		int waFirst;
+		while ((waFirst = title.indexOf (winamp)) != -1) {
+			title.remove (0, waFirst + winampLength);
+		}
+	}
+	else {
+		title = QString ((const QChar *) waTitle, length<TCHAR> ((const TCHAR *) waTitle)); // Title is not scrolling
+	}
+
+	// Remove leading and trailing spaces
+	title  = title.trimmed();
+
+	// Remove trailing " - Winamp" from title
+	if (title.length ()) {
+		winamp = " - Winamp";
+		winampLength = winamp.length ();
+		int waFirst = title.indexOf (winamp);
+		if (waFirst != -1)
+		{
+			title.remove (waFirst, waFirst + winampLength);
+		}
+	}
+
+	// Remove track number from title
+	if (title.length ()) {
+		QString dot(". ");
+		int dotFirst = title.indexOf (dot);
+		if (dotFirst != -1) {
+			// All symbols before the dot are digits?
+			bool allDigits = true;
+			for (int pos = dotFirst; pos > 0; --pos) {
+				allDigits = allDigits && title[pos].isNumber();
+			}
+			if (allDigits) {
+				title.remove(0, dotFirst + dot.length ());
+			}
+		}
+	}
+
+	// Remove leading and trailing spaces
+	if (title.length ()) {
+		while (title.length () && title[0] == ' ') {
+			title.remove (0, 1);
+		}
+		while (title.length () && title[title.length () - 1] == ' ') {
+			title.remove (title.length () - 1, 1);
+		}
+	}
+
+	return QPair<bool, QString>(true,title);
+}
+
+
+/**
+ * Polls for new song info.
+ */
+void WinAmpTuneController::check()
+{
+
+	Tune tune;
+#ifdef UNICODE
+	HWND h = FindWindow(L"Winamp v1.x", NULL);
+#else
+	HWND h = FindWindow("Winamp v1.x", NULL);
+#endif
+	if (h && SendMessage(h, WM_WA_IPC, 0, IPC_ISPLAYING) == 1) {
+		tune = getTune(h);
+	}
+	prevTune_ = tune;
+	setInterval(NormInterval);
+	PollingTuneController::check();
+}
+
+Tune WinAmpTuneController::getTune(const HWND &hWnd)
+{
+	Tune tune = Tune();
+	int position = (int)SendMessage(hWnd, WM_WA_IPC, 0, IPC_GETLISTPOS);
+	if (position != -1) {
+		if (hWnd && SendMessage(hWnd,WM_WA_IPC,0,IPC_ISPLAYING) == 1) {
+			QPair<bool, QString> trackpair(getTrackTitle(hWnd));
+			if (!trackpair.first) {
+				// getTrackTitle wants us to retry in a few ms...
+				int interval = AntiscrollInterval;
+				if (++antiscrollCounter_ > 10) {
+					antiscrollCounter_ = 0;
+					interval = NormInterval;
+				}
+				setInterval(interval);
+				return Tune();
+			}
+			antiscrollCounter_ = 0;
+			tune.setName(trackpair.second);
+			tune.setURL(trackpair.second);
+			tune.setTrack(QString::number(position + 1));
+			tune.setTime(SendMessage(hWnd, WM_WA_IPC, 1, IPC_GETOUTPUTTIME));
+		}
+	}
+	return tune;
+}
+
+Tune WinAmpTuneController::currentTune() const
+{
+	return prevTune_;
+}
--- git.orig/src/tools/tunecontroller/winamptunecontroller.h
+++ git/src/tools/tunecontroller/winamptunecontroller.h
@@ -0,0 +1,48 @@
+/*
+ * winamptunecontroller.h
+ * Copyright (C) 2006  Remko Troncon
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef WINAMPTUNECONTROLLER_H
+#define WINAMPTUNECONTROLLER_H
+
+#include "pollingtunecontroller.h"
+
+#include <windows.h>
+#include <QPair>
+
+class WinAmpTuneController : public PollingTuneController
+{
+	Q_OBJECT
+public:
+	WinAmpTuneController();
+	virtual Tune currentTune() const;
+
+private:
+	Tune getTune(const HWND &hWnd);
+	QPair<bool, QString> getTrackTitle(const HWND &waWnd) const;
+
+protected slots:
+	void check();
+
+private:
+	Tune prevTune_;
+	int antiscrollCounter_;
+};
+
+#endif
