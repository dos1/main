diff --git a/options/default.xml b/options/default.xml
index bfc7271..63be8e0 100644
--- a/options/default.xml
+++ b/options/default.xml
@@ -377,6 +377,9 @@
 			</service-discovery>
 			<tabs>
 				<show-tab-icons type="bool">true</show-tab-icons>
+				<disable-wheel-scroll type="bool">false</disable-wheel-scroll>
+				<can-close-inactive-tab type="bool">true</can-close-inactive-tab>
+				<show-tab-close-buttons type="bool">true</show-tab-close-buttons>
 				<put-tabs-at-bottom type="bool">false</put-tabs-at-bottom>
 				<use-tabs type="bool">true</use-tabs>
 				<size type="QString"></size> <!-- will be invalid when converted to QSize so we can detect first load -->
diff --git a/src/tabs/tabdlg.cpp b/src/tabs/tabdlg.cpp
index 39a4518..9ebbcd5 100644
--- a/src/tabs/tabdlg.cpp
+++ b/src/tabs/tabdlg.cpp
@@ -161,6 +161,7 @@ TabDlg::TabDlg(TabManager* tabManager, const QString& geometryOption, TabDlgDele
 	connect(tabWidget_, SIGNAL(tabContextMenu(int, QPoint, QContextMenuEvent*)), SLOT(showTabMenu(int, QPoint, QContextMenuEvent*)));
 	connect(tabWidget_, SIGNAL(closeButtonClicked()), SLOT(closeCurrentTab()));
 	connect(tabWidget_, SIGNAL(currentChanged(QWidget*)), SLOT(tabSelected(QWidget*)));
+	connect(tabWidget_, SIGNAL(tabCloseRequested(int)), SLOT(tabCloseRequested(int)));
 
 	if(delegate_)
 		delegate_->tabWidgetCreated(this, tabWidget_);
@@ -818,6 +819,23 @@ void TabDlg::setSimplifiedCaptionEnabled(bool enabled)
 }
 
 /**
+  * the slot is invoked, when small close button is clicked on a tab
+  * dont close tabs, that are not active.
+  * \param tab number requested to close
+  */
+void TabDlg::tabCloseRequested(int i)
+{
+	if (tabWidget_->currentPageIndex() == i)
+		closeTab(static_cast<TabbableWidget*>(tabWidget_->page(i)));
+	else {
+		if (PsiOptions::instance()->getOption("options.ui.tabs.can-close-inactive-tab").toBool())
+			closeTab(static_cast<TabbableWidget*>(tabWidget_->page(i)));
+		else
+			selectTab(static_cast<TabbableWidget*>(tabWidget_->page(i)));
+	}
+}
+
+/**
  * Set the icon of the tab.
  */
 void TabDlg::setTabIcon(QWidget *widget,const QIcon &icon)
diff --git a/src/tabs/tabdlg.h b/src/tabs/tabdlg.h
index a31b61d..3d036a1 100644
--- a/src/tabs/tabdlg.h
+++ b/src/tabs/tabdlg.h
@@ -121,6 +121,7 @@ public slots:
 	void optionsUpdate();
 	void detachTab(TabbableWidget*);
 	void sendTabTo(TabbableWidget*, TabDlg *);
+	void tabCloseRequested(int i);
 
 signals:
 	void resized(QSize size);
diff --git a/src/widgets/psitabbar.cpp b/src/widgets/psitabbar.cpp
index d5fca8d..5224e7e 100644
--- a/src/widgets/psitabbar.cpp
+++ b/src/widgets/psitabbar.cpp
@@ -24,6 +24,9 @@
 #include <QApplication>
 #include <QDrag>
 #include <QMimeData>
+#include <QPainter>
+
+#include "psioptions.h"
 
 /**
  * Constructor
@@ -32,6 +35,11 @@ PsiTabBar::PsiTabBar(PsiTabWidget *parent)
 		: QTabBar(parent)
 		, dragsEnabled_(true) {
 	//setAcceptDrops(true);
+
+	setMovable(true);
+	setTabsClosable(true);
+	setSelectionBehaviorOnRemove ( QTabBar::SelectPreviousTab );
+	currTab=-1;
 }
 
 /**
@@ -71,21 +79,23 @@ int PsiTabBar::findTabUnder(const QPoint &pos) {
 }
 
 void PsiTabBar::mousePressEvent(QMouseEvent *event) {
-	int tabno = findTabUnder(event->pos());
-	if (event->button() == Qt::LeftButton) {
-		dragStartPosition_ = event->pos();
-		dragTab_ = tabno;
-		if (tabno != -1) {
-			setCurrentIndex(tabno);
-		}
-	} else if (event->button() == Qt::MidButton) {
-		if (tabno != -1) {
-			emit mouseMiddleClickTab(tabno);
-		}
-	}
+	QTabBar::mousePressEvent(event);
 	event->accept();
 }
 
+void PsiTabBar::mouseReleaseEvent ( QMouseEvent * event )
+{
+	if (event->button() == Qt::MidButton && findTabUnder(event->pos())!=-1) {
+		emit mouseMiddleClickTab(findTabUnder(event->pos()));
+		event->accept();
+	}
+	QTabBar::mouseReleaseEvent(event);
+
+	if ((dragTab_ != -1) && (event->button() != Qt::MidButton)) {
+		this->setCurrentIndex(currentIndex());
+	}
+};
+
 /*
  * Used for starting drags of tabs
  */
@@ -94,6 +104,7 @@ void PsiTabBar::mouseMoveEvent(QMouseEvent *event) {
 		return;
 	}
 	if (!(event->buttons() & Qt::LeftButton)) {
+		currTab=-1;
 		return;
 	}
 	if ((event->pos() - dragStartPosition_).manhattanLength()
@@ -101,23 +112,7 @@ void PsiTabBar::mouseMoveEvent(QMouseEvent *event) {
 		return;
 	}
 
-	if (dragTab_ != -1) {
-		QDrag *drag = new QDrag(this);
-		QMimeData *mimeData = new QMimeData;
-		QByteArray data;
-		QPixmap icon;
-
-		data.setNum(dragTab_);
-
-		mimeData->setData(PSITABDRAGMIMETYPE, data);
-		drag->setMimeData(mimeData);
-		drag->setPixmap(icon);
-
-		Qt::DropAction dropAction = drag->start(Qt::MoveAction);
-		Q_UNUSED(dropAction);
-	}
-
-	event->accept();
+	QTabBar::mouseMoveEvent(event);
 }
 
 void PsiTabBar::contextMenuEvent(QContextMenuEvent *event) {
@@ -126,6 +121,9 @@ void PsiTabBar::contextMenuEvent(QContextMenuEvent *event) {
 }
 
 void PsiTabBar::wheelEvent(QWheelEvent *event) {
+	if (PsiOptions::instance()->getOption("options.ui.tabs.disable-wheel-scroll").toBool())
+		return;
+
 	int numDegrees = event->delta() / 8;
 	int numSteps = numDegrees / 15;
 
@@ -147,3 +145,13 @@ void PsiTabBar::wheelEvent(QWheelEvent *event) {
 void PsiTabBar::setDragsEnabled(bool enabled) {
 	dragsEnabled_ = enabled;
 }
+
+void PsiTabBar::paintEvent(QPaintEvent *event)
+{
+	QTabBar::paintEvent(event);
+};
+
+void PsiTabBar::resizeEvent(QResizeEvent * event)
+{
+	QTabBar::resizeEvent(event);
+};
diff --git a/src/widgets/psitabbar.h b/src/widgets/psitabbar.h
index 0c98dda..20e3363 100644
--- a/src/widgets/psitabbar.h
+++ b/src/widgets/psitabbar.h
@@ -52,11 +52,16 @@ protected:
 	void mousePressEvent(QMouseEvent *event);
 	void contextMenuEvent(QContextMenuEvent *event);
 	void wheelEvent(QWheelEvent *event);
+	void paintEvent(QPaintEvent *event);
+	void mouseReleaseEvent ( QMouseEvent * event );
+	void resizeEvent(QResizeEvent * event);
 
 private:
 	int findTabUnder(const QPoint &pos);
 	QPoint dragStartPosition_;
 	int dragTab_;
+	int currTab;
+	bool isOnTheLeft;
 	bool dragsEnabled_;
 };
 
diff --git a/src/widgets/psitabwidget.cpp b/src/widgets/psitabwidget.cpp
index 94cef66..b5483dc 100644
--- a/src/widgets/psitabwidget.cpp
+++ b/src/widgets/psitabwidget.cpp
@@ -79,11 +79,16 @@ PsiTabWidget::PsiTabWidget(QWidget *parent)
 		closeButton_->hide();
 		downButton_->hide();
 	}
+	if (!PsiOptions::instance()->getOption("options.ui.tabs.show-tab-close-buttons").toBool()){
+		tabBar_->setTabsClosable(false);
+	}
 	connect( tabBar_, SIGNAL(mouseDoubleClickTab(int)), SLOT(mouseDoubleClickTab(int)));
 	connect( tabBar_, SIGNAL(mouseMiddleClickTab(int)), SLOT(mouseMiddleClickTab(int)));
 	connect( tabBar_, SIGNAL( currentChanged(int)), SLOT(tab_currentChanged(int)));
 	connect( tabBar_, SIGNAL( contextMenu(QContextMenuEvent*,int)), SLOT( tab_contextMenu(QContextMenuEvent*,int)));
 	connect( closeButton_, SIGNAL(clicked()), SIGNAL(closeButtonClicked()));
+	connect(tabBar_, SIGNAL(tabMoved(int,int)),SLOT(widgetMoved(int,int)));
+	connect(tabBar_, SIGNAL(tabCloseRequested(int)),SIGNAL(tabCloseRequested(int)));
 }
 
 void PsiTabWidget::setCloseIcon(const QIcon& icon) {
@@ -348,3 +353,22 @@ void PsiTabWidget::setTabButtonsShown(bool shown) {
 void PsiTabWidget::setDragsEnabled(bool enabled) {
 	((PsiTabBar *)tabBar_)->setDragsEnabled(enabled);
 }
+
+void PsiTabWidget::widgetMoved(int from, int to)
+{
+	if (from > to) {
+		stacked_->removeWidget(widgets_[from]);
+		widgets_.insert(to, 1, widgets_[from]);
+		widgets_.remove(from+1);
+		stacked_->insertWidget(to,widgets_[to]);
+	}
+	else {
+		stacked_->removeWidget(widgets_[from]);
+		widgets_.insert(to+1, 1, widgets_[from]);
+		widgets_.remove(from,1);
+		stacked_->insertWidget(to,widgets_[to]);
+	}
+
+	emit currentChanged(currentPage());
+
+};
diff --git a/src/widgets/psitabwidget.h b/src/widgets/psitabwidget.h
index 1f623a9..73c7e4b 100644
--- a/src/widgets/psitabwidget.h
+++ b/src/widgets/psitabwidget.h
@@ -74,6 +74,7 @@ signals:
 	void currentChanged(QWidget *selected);
 	void closeButtonClicked();
 	void aboutToShowMenu(QMenu *);
+	void tabCloseRequested(int i);
 
 	// context menu on the blank space will have tab==-1
 	void tabContextMenu(int tab, QPoint pos, QContextMenuEvent *event);
@@ -85,6 +86,7 @@ private slots:
 	void tab_contextMenu(QContextMenuEvent *event, int tab);
 	void menu_aboutToShow();
 	void menu_triggered(QAction *act);
+	void widgetMoved(int from, int to);
 
 private:
 	QVector<QWidget*> widgets_;
