diff --git a/iris b/iris
--- a/iris
+++ b/iris
@@ -1 +1 @@
-Subproject commit 230575f0d2ad196840ddc785049be564e99b24aa
+Subproject commit 230575f0d2ad196840ddc785049be564e99b24aa-dirty
diff --git a/src/ahcservermanager.cpp b/src/ahcservermanager.cpp
index c690180..6c44922 100644
--- a/src/ahcservermanager.cpp
+++ b/src/ahcservermanager.cpp
@@ -87,9 +87,8 @@ bool JT_AHCServer::commandListQuery(const QDomElement& e)
 		}
 		else if (q.attribute("xmlns") == "http://jabber.org/protocol/disco#info" && q.attribute("node") == AHC_NS) {
 			QDomElement iq = createIQ(doc(), "result", e.attribute("from"), e.attribute("id"));
-			QDomElement query = doc()->createElement("query");
-			query.setAttribute("xmlns", "http://jabber.org/protocol/disco#info");
-			iq.appendChild(query);
+			DiscoItem item;
+			QDomElement query = query.appendChild(item.toDiscoInfoResult(doc())).toElement();
 			send(iq);
 			return true;
 		}
@@ -104,25 +103,11 @@ bool JT_AHCServer::commandListQuery(const QDomElement& e)
 		}
 		else if (q.attribute("xmlns") == "http://jabber.org/protocol/disco#info" && manager_->hasServer(q.attribute("node"), Jid(e.attribute("from")))) {
 			QDomElement iq = createIQ(doc(), "result", e.attribute("from"), e.attribute("id"));
-			QDomElement query = doc()->createElement("query");
-			query.setAttribute("xmlns", "http://jabber.org/protocol/disco#info");
-			query.setAttribute("node",q.attribute("node"));
-			iq.appendChild(query);
-
-			QDomElement identity;
-			identity = doc()->createElement("identity");
-			identity.setAttribute("category", "automation");
-			identity.setAttribute("type", "command-node");
-			query.appendChild(identity);
-
-			QDomElement feature;
-			feature = doc()->createElement("feature");
-			feature.setAttribute("var", AHC_NS);
-			query.appendChild(feature);
-
-			feature = doc()->createElement("feature");
-			feature.setAttribute("var", "jabber:x:data");
-			query.appendChild(feature);
+			DiscoItem item;
+			item.setNode(q.attribute("node"));
+			item.setIdentities(XMPP::DiscoItem::Identity("automation", "command-node"));
+			item.setFeatures(Features(QStringList() << AHC_NS << "jabber:x:data"));
+			QDomElement query = query.appendChild(item.toDiscoInfoResult(doc())).toElement();
 
 			send(iq);
 			return true;
diff --git a/src/applicationinfo.cpp b/src/applicationinfo.cpp
index 45346a7..456fc1f 100644
--- a/src/applicationinfo.cpp
+++ b/src/applicationinfo.cpp
@@ -46,7 +46,7 @@
 #define PROG_VERSION PSI_VERSION
 //#define PROG_VERSION "0.15-dev" " (" __DATE__ ")" //CVS Builds are dated
 //#define PROG_VERSION "0.15";
-#define PROG_CAPS_NODE "http://psi-im.org/caps"
+#define PROG_CAPS_NODE "http://psi-im.org"
 #define PROG_CAPS_VERSION "caps-b75d8d2b25"
 #define PROG_IPC_NAME "org.psi-im.Psi"	// must not contain '\\' character on Windows
 #define PROG_OPTIONS_NS "http://psi-im.org/options"
diff --git a/src/capabilities/capabilities.pri b/src/capabilities/capabilities.pri
index bc9c29f..b07aeab 100644
--- a/src/capabilities/capabilities.pri
+++ b/src/capabilities/capabilities.pri
@@ -2,11 +2,9 @@ INCLUDEPATH *= $$PWD
 DEPENDPATH *= $$PWD
 
 HEADERS += \
-	$$PWD/capsspec.h \
 	$$PWD/capsregistry.h \
 	$$PWD/capsmanager.h
 
 SOURCES += \
-	$$PWD/capsspec.cpp \
 	$$PWD/capsregistry.cpp \
 	$$PWD/capsmanager.cpp
diff --git a/src/capabilities/capsmanager.cpp b/src/capabilities/capsmanager.cpp
index 45ebf83..7e30a0f 100755
--- a/src/capabilities/capsmanager.cpp
+++ b/src/capabilities/capsmanager.cpp
@@ -33,6 +33,7 @@
 
 #include "capsregistry.h"
 #include "capsmanager.h"
+#include "xmpp_discoinfotask.h"
 
 
 //#define REQUEST_TIMEOUT 3000
@@ -87,56 +88,49 @@ void CapsManager::setEnabled(bool b)
  * @param ver The entity's caps version
  * @param ext The entity's caps extensions
  */
-void CapsManager::updateCaps(const Jid& jid, const QString& node, const QString& ver, const QString& ext)
+void CapsManager::updateCaps(const Jid& jid, const CapsSpec &c)
 {
 	if (jid.compare(jid_,false))
 		return;
 
-	CapsSpec c(node,ver,ext);
-	CapsSpecs caps = c.flatten();
+	QString fullNode = c.flatten();
 	if (capsSpecs_[jid.full()] != c) {
 		//qDebug() << QString("caps.cpp: Updating caps for %1 (node=%2,ver=%3,ext=%4)").arg(QString(jid.full()).replace('%',"%%")).arg(node).arg(ver).arg(ext);
 
-		// Unregister from all old caps nodes
-		CapsSpecs old_caps = capsSpecs_[jid.full()].flatten();
-		foreach(CapsSpec s, old_caps) {
-			if (s != CapsSpec()) {
-				capsJids_[s].removeAll(jid.full());
-			}
-		}
+		// Unregister from all old caps node
+		capsJids_[capsSpecs_[jid.full()].flatten()].removeAll(jid.full());
 
-		if (!node.isEmpty() && !ver.isEmpty()) {
+		if (c.isValid()) {
 			// Register with all new caps nodes
 			capsSpecs_[jid.full()] = c;
-			foreach(CapsSpec s, caps) {
-				if (!capsJids_[s].contains(jid.full())) {
-					capsJids_[s].push_back(jid.full());
-				}
+			if (!capsJids_[fullNode].contains(jid.full())) {
+				capsJids_[fullNode].push_back(jid.full());
 			}
 
 			emit capsChanged(jid);
 
 			// Register new caps and check if we need to discover features
 			if (isEnabled()) {
-				foreach(CapsSpec s, caps) {
-					if (!registry_->isRegistered(s) && capsJids_[s].count() == 1) {
-						//qDebug() << QString("caps.cpp: Sending disco request to %1, node=%2").arg(QString(jid.full()).replace('%',"%%")).arg(node + "#" + s.extensions());
-						discoInfoQuerier_->getDiscoInfo(jid,node + '#' + s.extensions());
-					}
+				if (!registry_->isRegistered(fullNode) && capsJids_[fullNode].count() == 1) {
+					//qDebug() << QString("caps.cpp: Sending disco request to %1, node=%2").arg(QString(jid.full()).replace('%',"%%")).arg(node + "#" + s.extensions());
+					JT_DiscoInfo* disco = new JT_DiscoInfo(client_->rootTask());
+					connect(disco, SIGNAL(finished()), SLOT(discoFinished()));
+					disco->get(jid, fullNode);
+					disco->go(true);
+
+					discoInfoQuerier_->getDiscoInfo(jid, fullNode);
 				}
 			}
 		}
 		else {
 			// Remove all caps specifications
-			qWarning() << QString("caps.cpp: Illegal caps info from %1: node=%2, ver=%3").arg(QString(jid.full()).replace('%',"%%")).arg(node).arg(ver);
+			qWarning() << QString("caps.cpp: Illegal caps info from %1: node=%2, ver=%3").arg(QString(jid.full()).replace('%',"%%")).arg(fullNode).arg(c.version());
 			capsSpecs_.remove(jid.full());
 		}
 	}
 	else {
 		// Add to the list of jids
-		foreach(CapsSpec s, caps) {
-			capsJids_[s].push_back(jid.full());
-		}
+		capsJids_[fullNode].push_back(jid.full());
 	}
 }
 
@@ -149,11 +143,9 @@ void CapsManager::disableCaps(const Jid& jid)
 {
 	//qDebug() << QString("caps.cpp: Disabling caps for %1.").arg(QString(jid.full()).replace('%',"%%"));
 	if (capsEnabled(jid)) {
-		CapsSpecs cs = capsSpecs_[jid.full()].flatten();
-		foreach(CapsSpec s, cs) {
-			if (s != CapsSpec()) {
-				capsJids_[s].removeAll(jid.full());
-			}
+		QString node = capsSpecs_[jid.full()].flatten();
+		if (!node.isEmpty()) {
+			capsJids_[node].removeAll(jid.full());
 		}
 		capsSpecs_.remove(jid.full());
 		emit capsChanged(jid);
@@ -166,43 +158,16 @@ void CapsManager::disableCaps(const Jid& jid)
  * features database for the requested node, and all the affected jids are
  * put in the queue for update notification.
  */
-void CapsManager::getDiscoInfo_success(const XMPP::Jid& jid, const QString& node, const XMPP::DiscoItem& item)
+void CapsManager::discoFinished()
 {
 	//qDebug() << QString("caps.cpp: Disco response from %1, node=%2").arg(QString(jid.full()).replace('%',"%%")).arg(node);
 	// Update features
-	bool ok = false;
-	CapsSpec cs(getCapsSpecForNode(jid, node, ok));
-	if (!ok) {
+	JT_DiscoInfo *task = (JT_DiscoInfo *)sender();
+	CapsSpec cs = capsSpecs_.value(task->jid().full());
+	if (!cs.isValid()) {
 		return;
 	}
-	registry_->registerCaps(cs,item.identities(),item.features().list());
-}
-
-void CapsManager::getDiscoInfo_error(const XMPP::Jid& jid, const QString& node, int, const QString&)
-{
-	qWarning() << QString("capsmanager.cpp: Disco to '%1' at node '%2' failed.").arg(jid.full()).arg(node);
-}
-
-
-CapsSpec CapsManager::getCapsSpecForNode(const XMPP::Jid& jid, const QString& disco_node, bool& ok) const
-{
-    int hash_index = disco_node.indexOf('#');
-    if (hash_index == -1) {
-		qWarning() << "CapsManager: Node" << disco_node << "invalid";
-		ok = false;
-		return CapsSpec();
-    }
-	QString node = disco_node.left(hash_index);
-	QString ext = disco_node.right(disco_node.length() - hash_index - 1);
-	CapsSpec jid_cs = capsSpecs_[jid.full()];
-	if (jid_cs.node() == node) {
-		ok = true;
-		return CapsSpec(node,jid_cs.version(),ext);
-	}
-	else {
-		ok = false;
-		return CapsSpec();
-	}
+	registry_->registerCaps(cs, task->item());
 }
 
 /**
@@ -212,7 +177,7 @@ CapsSpec CapsManager::getCapsSpecForNode(const XMPP::Jid& jid, const QString& di
 void CapsManager::capsRegistered(const CapsSpec& cs)
 {
 	// Notify affected jids.
-	foreach(QString s, capsJids_[cs]) {
+	foreach(const QString &s, capsJids_[cs.flatten()]) {
 		//qDebug() << QString("caps.cpp: Notifying %1.").arg(s.replace('%',"%%"));
 		emit capsChanged(s);
 	}
@@ -235,10 +200,11 @@ XMPP::Features CapsManager::features(const Jid& jid) const
 	//qDebug() << "caps.cpp: Retrieving features of " << jid.full();
 	QStringList f;
 	if (capsEnabled(jid)) {
-		CapsSpecs cs = capsSpecs_[jid.full()].flatten();
-		foreach(CapsSpec s, cs) {
+		QStringList nodes = capsSpecs_[jid.full()].flatten();
+		foreach(const QString &s, nodes) {
 			//qDebug() << QString("    %1").arg(registry_->features(s).list().join("\n"));
-			f += registry_->features(s).list();
+			DiscoItem disco = registry_->disco(s);
+			f += disco.features().list();
 		}
 	}
 	return Features(f);
@@ -251,11 +217,23 @@ XMPP::Features CapsManager::features(const Jid& jid) const
 QString CapsManager::clientName(const Jid& jid) const
 {
 	if (capsEnabled(jid)) {
-		QString name;
 		CapsSpec cs = capsSpecs_[jid.full()];
-		const DiscoItem::Identities& i = registry_->identities(CapsSpec(cs.node(),cs.version(),cs.version()));
-		if (i.count() > 0) {
-			name = i.first().name;
+		QString name;
+
+		QString cs_str = cs.flatten(false).first();
+		if (registry_->isRegistered(cs_str)) {
+			DiscoItem disco = registry_->disco(cs_str);
+			XData si = disco.registeredExtension(QLatin1String("urn:xmpp:dataforms:softwareinfo"));
+			if (si.isValid()) {
+				name = si.getField("software").value().value(0);
+			}
+
+			if (name.isEmpty()) {
+				const DiscoItem::Identities& i = disco.identities();
+				if (i.count() > 0) {
+					name = i.first().name;
+				}
+			}
 		}
 
 		// Try to be intelligent about the name
@@ -286,5 +264,40 @@ QString CapsManager::clientName(const Jid& jid) const
  */
 QString CapsManager::clientVersion(const Jid& jid) const
 {
-	return (capsEnabled(jid) ? capsSpecs_[jid.full()].version() : QString());
+	if (!capsEnabled(jid))
+		return QString();
+
+	QString version;
+	const CapsSpec &cs = capsSpecs_[jid.full()];
+	QString cs_str = cs.flatten(false).first();
+	if (registry_->isRegistered(cs_str)) {
+		XData form = registry_->disco(cs_str).registeredExtension("urn:xmpp:dataforms:softwareinfo");
+		version = form.getField("software_version").value().value(0);
+	}
+
+	if (version.isEmpty())
+		version = cs.version();
+
+	return version;
+}
+
+/**
+ * \brief Returns the OS version of a given jid.
+ */
+QString CapsManager::osVersion(const Jid &jid) const
+{
+	QString os_str;
+	if (capsEnabled(jid)) {
+		QString cs_str = capsSpecs_[jid.full()].flatten(false).first();
+		if (registry_->isRegistered(cs_str)) {
+			XData form = registry_->disco(cs_str).registeredExtension("urn:xmpp:dataforms:softwareinfo");
+			os_str = form.getField("os").value().value(0).trimmed();
+			if (!os_str.isEmpty()) {
+				QString os_ver = form.getField("os_version").value().value(0).trimmed();
+				if (!os_ver.isEmpty())
+					os_str.append(" " + os_ver);
+			}
+		}
+	}
+	return os_str;
 }
diff --git a/src/capabilities/capsmanager.h b/src/capabilities/capsmanager.h
index c779e30..c46f21e 100755
--- a/src/capabilities/capsmanager.h
+++ b/src/capabilities/capsmanager.h
@@ -28,7 +28,6 @@
 #include <QPointer>
 
 #include "protocol/discoinfoquerier.h"
-#include "capsspec.h"
 #include "capsregistry.h"
 #include "xmpp_features.h"
 
@@ -48,12 +47,13 @@ public:
 	bool isEnabled();
 	void setEnabled(bool);
 
-	void updateCaps(const Jid& jid, const QString& node, const QString& ver, const QString& ext);
+	void updateCaps(const Jid& jid, const CapsSpec& caps);
 	void disableCaps(const Jid& jid);
 	bool capsEnabled(const Jid& jid) const;
 	XMPP::Features features(const Jid& jid) const;
 	QString clientName(const Jid& jid) const;
 	QString clientVersion(const Jid& jid) const;
+	QString osVersion(const Jid& jid) const;
 
 signals:
 	/**
@@ -61,13 +61,8 @@ signals:
 	 */
 	void capsChanged(const Jid& jid);
 
-protected:
-	CapsSpec getCapsSpecForNode(const XMPP::Jid& jid, const QString& disco_node, bool& ok) const;
-
 protected slots:
-	void getDiscoInfo_success(const XMPP::Jid& jid, const QString& node, const XMPP::DiscoItem& item);
-	void getDiscoInfo_error(const XMPP::Jid& jid, const QString& node, int error_code, const QString& error_string);
-
+	void discoFinished();
 	void capsRegistered(const CapsSpec&);
 
 private:
@@ -76,7 +71,7 @@ private:
 	QPointer<Protocol::DiscoInfoQuerier> discoInfoQuerier_;
 	bool isEnabled_;
 	QMap<QString,CapsSpec> capsSpecs_;
-	QMap<CapsSpec,QList<QString> > capsJids_;
+	QMap<QString,QList<QString> > capsJids_;
 };
 
 
diff --git a/src/capabilities/capsregistry.cpp b/src/capabilities/capsregistry.cpp
index 01db836..f9fcc52 100755
--- a/src/capabilities/capsregistry.cpp
+++ b/src/capabilities/capsregistry.cpp
@@ -32,99 +32,25 @@ using namespace XMPP;
 
 // -----------------------------------------------------------------------------
 
-CapsRegistry::CapsInfo::CapsInfo()
-{
-	updateLastSeen();
-}
-
-const XMPP::Features& CapsRegistry::CapsInfo::features() const
-{
-	return features_;
-}
-
-const DiscoItem::Identities& CapsRegistry::CapsInfo::identities() const
-{
-	return identities_;
-}
-
-void CapsRegistry::CapsInfo::setIdentities(const DiscoItem::Identities& i)
-{
-	identities_ = i;
-}
 
-void CapsRegistry::CapsInfo::setFeatures(const XMPP::Features& f)
+QDomElement CapsInfo::toXml(QDomDocument *doc) const
 {
-	features_ = f;
+	QDomElement caps = doc->createElement("info");
+	caps.appendChild(doc->createElement("atime")).setNodeValue(_lastSeen.toString(Qt::ISODate));
+	caps.appendChild(_disco.toDiscoInfoResult(doc));
+	return caps;
 }
 
-void CapsRegistry::CapsInfo::updateLastSeen()
+CapsInfo CapsInfo::fromXml(const QDomElement &caps)
 {
-	lastSeen_ = QDateTime::currentDateTime();
+	QDateTime lastSeen = QDateTime::fromString(caps.firstChildElement("atime").nodeValue(), Qt::ISODate);
+	DiscoItem item = DiscoItem::fromDiscoInfoResult(caps.firstChildElement("query"));
+	return CapsInfo(item, lastSeen);
 }
 
-QDomElement CapsRegistry::CapsInfo::toXml(QDomDocument *doc) const
-{
-	QDomElement info = doc->createElement("info");
-	info.setAttribute("last-seen",lastSeen_.toString(Qt::ISODate));
-
-	// Identities
-	for (DiscoItem::Identities::ConstIterator i = identities_.begin(); i != identities_.end(); ++i) {
-		QDomElement identity = doc->createElement("identity");
-		identity.setAttribute("category",(*i).category);
-		identity.setAttribute("name",(*i).name);
-		identity.setAttribute("type",(*i).type);
-		info.appendChild(identity);
-	}
-
-	// Features
-	foreach(QString f, features_.list()) {
-		QDomElement feature = doc->createElement("feature");
-		feature.setAttribute("node",f);
-		info.appendChild(feature);
-	}
-
-	return info;
-}
-
-void CapsRegistry::CapsInfo::fromXml(const QDomElement& e)
-{
-	if (e.tagName() != "info") {
-		qWarning("caps.cpp: Invalid info element");
-		return;
-	}
-
-	if (!e.attribute("last-seen").isEmpty()) {
-		QDateTime last = QDateTime::fromString(e.attribute("last-seen"),Qt::ISODate);
-		if (last.isValid())
-			lastSeen_ = last;
-		else
-			qWarning("Invalid date in caps registry");
-	}
-
-	for(QDomNode n = e.firstChild(); !n.isNull(); n = n.nextSibling()) {
-		QDomElement i = n.toElement();
-		if(i.isNull()) {
-			qWarning("caps.cpp: Null element");
-			continue;
-		}
-
-		if(i.tagName() == "identity") {
-			DiscoItem::Identity id;
-			id.category = i.attribute("category");
-			id.name = i.attribute("name");
-			id.type = i.attribute("type");
-			identities_ += id;
-		}
-		else if (i.tagName() == "feature") {
-			features_.addFeature(i.attribute("node"));
-		}
-		else {
-			qWarning("caps.cpp: Unknown element");
-		}
-	}
-}
 
 // -----------------------------------------------------------------------------
+
 /**
  * \class CapsRegistry
  * \brief A singleton class managing the capabilities of clients.
@@ -146,12 +72,10 @@ void CapsRegistry::save(QIODevice& out)
 	QDomDocument doc;
 	QDomElement capabilities = doc.createElement("capabilities");
 	doc.appendChild(capabilities);
-	QMap<CapsSpec,CapsInfo>::ConstIterator i = capsInfo_.begin();
+	QHash<QString,CapsInfo>::ConstIterator i = capsInfo_.constBegin();
 	for( ; i != capsInfo_.end(); i++) {
 		QDomElement info = i.value().toXml(&doc);
-		info.setAttribute("node",i.key().node());
-		info.setAttribute("ver",i.key().version());
-		info.setAttribute("ext",i.key().extensions());
+		info.setAttribute("node",i.key());
 		capabilities.appendChild(info);
 	}
 
@@ -197,11 +121,15 @@ void CapsRegistry::load(QIODevice& in)
 		}
 
 		if(i.tagName() == "info") {
-			CapsInfo info;
-			info.fromXml(i);
-			CapsSpec spec(i.attribute("node"),i.attribute("ver"),i.attribute("ext"));
-			capsInfo_[spec] = info;
-			//qDebug() << QString("Read %1 %2 %3").arg(spec.node()).arg(spec.version()).arg(spec.extensions());
+			QString node = i.attribute("node");
+			int sep = node.indexOf('#');
+			if (sep > 0 && sep + 1 < node.length()) {
+				capsInfo_[node] = CapsInfo::fromXml(i);
+				//qDebug() << QString("Read %1 %2").arg(node).arg(ver);
+			}
+			else {
+				qWarning() << "capsregistry.cpp: Node" << node << "invalid";
+			}
 		}
 		else {
 			qWarning("capsregistry.cpp: Unknown element");
@@ -212,13 +140,12 @@ void CapsRegistry::load(QIODevice& in)
 /**
  * \brief Registers capabilities of a client.
  */
-void CapsRegistry::registerCaps(const CapsSpec& spec,const XMPP::DiscoItem::Identities& identities,const XMPP::Features& features)
+void CapsRegistry::registerCaps(const CapsSpec& spec, const DiscoItem &item)
 {
-	if (!isRegistered(spec)) {
-		CapsInfo info;
-		info.setIdentities(identities);
-		info.setFeatures(features);
-		capsInfo_[spec] = info;
+	QString dnode = spec.flatten();
+	if (!isRegistered(dnode)) {
+		CapsInfo info(item);
+		capsInfo_[dnode] = info;
 		emit registered(spec);
 	}
 }
@@ -226,24 +153,13 @@ void CapsRegistry::registerCaps(const CapsSpec& spec,const XMPP::DiscoItem::Iden
 /**
  * \brief Checks if capabilities have been registered.
  */
-bool CapsRegistry::isRegistered(const CapsSpec& spec) const
+bool CapsRegistry::isRegistered(const QString& spec) const
 {
 	return capsInfo_.contains(spec);
 }
 
-
-/**
- * \brief Retrieves the features of a given caps spec.
- */
-XMPP::Features CapsRegistry::features(const CapsSpec& spec) const
-{
-	return capsInfo_[spec].features();
-}
-
-/**
- * \brief Retrieves the identities of a given caps spec.
- */
-XMPP::DiscoItem::Identities CapsRegistry::identities(const CapsSpec& spec) const
+DiscoItem CapsRegistry::disco(const QString &spec) const
 {
-	return capsInfo_[spec].identities();
+	CapsInfo ci = capsInfo_.value(spec);
+	return ci.disco();
 }
diff --git a/src/capabilities/capsregistry.h b/src/capabilities/capsregistry.h
index b448796..ee68e07 100755
--- a/src/capabilities/capsregistry.h
+++ b/src/capabilities/capsregistry.h
@@ -31,12 +31,29 @@
 
 #include "xmpp_features.h"
 #include "xmpp_discoitem.h"
-
-#include "capsspec.h"
+#include "xmpp_status.h"
 
 class QDomDocument;
 class QDomElement;
 
+class CapsInfo
+{
+public:
+	inline CapsInfo() {}
+	inline CapsInfo(const XMPP::DiscoItem &disco, const QDateTime &lastSeen = QDateTime()) :
+		_lastSeen(lastSeen.isNull()? QDateTime::currentDateTime() : lastSeen),
+		_disco(disco) {}
+	inline bool isValid() const { return _lastSeen.isValid(); }
+	inline const QDateTime &lastSeen() const { return _lastSeen; }
+	inline const XMPP::DiscoItem &disco() const { return _disco; }
+	QDomElement toXml(QDomDocument *doc) const;
+	static CapsInfo fromXml(const QDomElement &ci);
+
+private:
+	QDateTime _lastSeen;
+	XMPP::DiscoItem _disco;
+};
+
 class CapsRegistry : public QObject
 {
 	Q_OBJECT
@@ -44,41 +61,19 @@ class CapsRegistry : public QObject
 public:
 	CapsRegistry();
 
-	void registerCaps(const CapsSpec&, const XMPP::DiscoItem::Identities&, const XMPP::Features& features);
-	bool isRegistered(const CapsSpec&) const;
-	XMPP::Features features(const CapsSpec&) const;
-	XMPP::DiscoItem::Identities identities(const CapsSpec&) const;
+	void registerCaps(const XMPP::CapsSpec&, const XMPP::DiscoItem &item);
+	bool isRegistered(const QString &) const;
+	XMPP::DiscoItem disco(const QString&) const;
 
 signals:
-	void registered(const CapsSpec&);
+	void registered(const XMPP::CapsSpec&);
 
 public slots:
 	void load(QIODevice& target);
 	void save(QIODevice& target);
 
 private:
-	class CapsInfo
-	{
-		public:
-			CapsInfo();
-			const XMPP::Features& features() const;
-			const XMPP::DiscoItem::Identities& identities() const;
-
-			void setIdentities(const XMPP::DiscoItem::Identities&);
-			void setFeatures(const XMPP::Features&);
-
-			QDomElement toXml(QDomDocument *) const;
-			void fromXml(const QDomElement&);
-
-		protected:
-			void updateLastSeen();
-
-		private:
-			XMPP::Features features_;
-			XMPP::DiscoItem::Identities identities_;
-			QDateTime lastSeen_;
-	};
-	QMap<CapsSpec,CapsInfo> capsInfo_;
+	QHash<QString,CapsInfo> capsInfo_;
 };
 
 
diff --git a/src/capabilities/capsspec.cpp b/src/capabilities/capsspec.cpp
deleted file mode 100755
index 880f8d8..0000000
--- a/src/capabilities/capsspec.cpp
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * capsspec.cpp
- * Copyright (C) 2006  Remko Troncon
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- */
-
-#include <QString>
-#include <QStringList>
-
-#include "capsspec.h"
-
-/**
- * \class CapsSpec
- * \brief A class representing an entity capability specification.
- * An entity capability is a combination of a node, a version, and a set of
- * extensions.
- */
-
-/**
- * Default constructor.
- */
-CapsSpec::CapsSpec()
-{
-}
-
-
-/**
- * \brief Basic constructor.
- * @param node the node
- * @param ven the version
- * @param ext the list of extensions (separated by spaces)
- */
-CapsSpec::CapsSpec(const QString& node, const QString& ver, const QString& ext) : node_(node), ver_(ver), ext_(ext)
-{
-}
-
-
-/**
- * \brief Returns the node of the capabilities specification.
- */
-const QString& CapsSpec::node() const
-{
-	return node_;
-}
-
-
-/**
- * \brief Returns the version of the capabilities specification.
- */
-const QString& CapsSpec::version() const
-{
-	return ver_;
-}
-
-
-/**
- * \brief Returns the extensions of the capabilities specification.
- */
-const QString& CapsSpec::extensions() const
-{
-	return ext_;
-}
-
-
-/**
- * \brief Flattens the caps specification into the set of 'simple'
- * specifications.
- * A 'simple' specification is a specification with exactly one extension,
- * or with the version number as the extension.
- *
- * Example: A caps specification with node=http://psi-im.org, version=0.10,
- * and ext='achat vchat' would be expanded into the following list of specs:
- *	node=http://psi-im.org, ver=0.10, ext=0.10
- *	node=http://psi-im.org, ver=0.10, ext=achat
- *	node=http://psi-im.org, ver=0.10, ext=vchat
- */
-CapsSpecs CapsSpec::flatten() const
-{
-	CapsSpecs l;
-	l.append(CapsSpec(node(),version(),version()));
-	QStringList exts(extensions().split(' ',QString::SkipEmptyParts));
-	for (QStringList::ConstIterator i = exts.begin(); i != exts.end(); ++i) {
-		l.append(CapsSpec(node(),version(),*i));
-	}
-	return l;
-}
-
-bool CapsSpec::operator==(const CapsSpec& s) const
-{
-	return (node() == s.node() && version() == s.version() && extensions() == s.extensions());
-}
-
-bool CapsSpec::operator!=(const CapsSpec& s) const
-{
-	return !((*this) == s);
-}
-
-bool CapsSpec::operator<(const CapsSpec& s) const
-{
-	return (node() != s.node() ? node() < s.node() :
-			(version() != s.version() ? version() < s.version() :
-			 extensions() < s.extensions()));
-}
-
diff --git a/src/capabilities/capsspec.h b/src/capabilities/capsspec.h
deleted file mode 100755
index bc8c114..0000000
--- a/src/capabilities/capsspec.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * capsspec.h
- * Copyright (C) 2006  Remko Troncon
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- */
-
-#ifndef CAPSSPEC_H
-#define CAPSSPEC_H
-
-#include <QList>
-#include <QString>
-
-class CapsSpec;
-typedef QList<CapsSpec> CapsSpecs;
-
-class CapsSpec
-{
-	public:
-		CapsSpec();
-		CapsSpec(const QString&, const QString&, const QString&);
-		const QString& node() const;
-		const QString& version() const;
-		const QString& extensions() const;
-		CapsSpecs flatten() const;
-
-		bool operator==(const CapsSpec&) const;
-		bool operator!=(const CapsSpec&) const;
-		bool operator<(const CapsSpec&) const;
-
-	private:
-		QString node_, ver_, ext_;
-};
-
-
-#endif
diff --git a/src/discodlg.cpp b/src/discodlg.cpp
index f97d680..5e8e6f2 100644
--- a/src/discodlg.cpp
+++ b/src/discodlg.cpp
@@ -497,6 +497,7 @@ void DiscoListItem::browseFinished()
 
 void DiscoListItem::doAgents(bool parentAutoItems)
 {
+	/* TODO remove jabber:iq:agents. it's obsoleted ince 2003 */
 	if ( parentAutoItems ) {
 		// save traffic
 		if ( alreadyItems )
diff --git a/src/groupchatdlg.cpp b/src/groupchatdlg.cpp
index bc136ed..26d2422 100644
--- a/src/groupchatdlg.cpp
+++ b/src/groupchatdlg.cpp
@@ -1661,9 +1661,9 @@ void GCMainDlg::presence(const QString &nick, const Status &s)
 		ui_.lv_users->removeEntry(nick);
 	}
 
-	if (!s.capsNode().isEmpty()) {
+	if (s.caps().isValid()) {
 		Jid caps_jid(s.mucItem().jid().isEmpty() || !d->nonAnonymous ? Jid(jid()).withResource(nick) : s.mucItem().jid());
-		account()->capsManager()->updateCaps(caps_jid,s.capsNode(),s.capsVersion(),s.capsExt());
+		account()->capsManager()->updateCaps(caps_jid, s.caps());
 	}
 
 	if(!nick.isEmpty())
diff --git a/src/psiaccount.cpp b/src/psiaccount.cpp
index 196410b..c15b838 100644
--- a/src/psiaccount.cpp
+++ b/src/psiaccount.cpp
@@ -2536,8 +2536,12 @@ void PsiAccount::client_resourceAvailable(const Jid &j, const Resource &r)
 
 			UserResource ur(r);
 			//ur.setSecurityEnabled(true);
-			if(local)
+			if(local) {
 				ur.setClient(ApplicationInfo::name(),ApplicationInfo::version(),SystemInfo::instance()->os());
+			}
+			else {
+				ur.setClient(capsManager()->clientName(j),capsManager()->clientVersion(j),capsManager()->osVersion(j));
+			}
 
 			u->userResourceList().append(ur);
 			rp = &u->userResourceList().last();
@@ -2600,15 +2604,14 @@ void PsiAccount::client_resourceAvailable(const Jid &j, const Resource &r)
 
 	// Update entity capabilities.
 	// This has to happen after the userlist item has been created.
-	if (!r.status().capsNode().isEmpty()) {
-		capsManager()->updateCaps(j,r.status().capsNode(),r.status().capsVersion(),r.status().capsExt());
+	if (r.status().caps().isValid()) {
+		capsManager()->updateCaps(j, r.status().caps());
 
 		// Update the client version
 		foreach(UserListItem* u, findRelevant(j)) {
 			UserResourceList::Iterator rit = u->userResourceList().find(j.resource());
 			if (rit != u->userResourceList().end()) {
-				//(*rit).setClient(capsManager()->clientName(j),capsManager()->clientVersion(j),"");
-				(*rit).setClient(QString(),QString(),"");
+				(*rit).setClient(capsManager()->clientName(j),capsManager()->clientVersion(j),capsManager()->osVersion(j));
 				cpUpdate(*u,(*rit).name());
 			}
 		}
@@ -3108,9 +3111,7 @@ void PsiAccount::setStatusActual(const Status &_s)
 
 	// Add entity capabilities information
 	if (capsManager()->isEnabled()) {
-		s.setCapsNode(d->client->capsNode());
-		s.setCapsVersion(d->client->capsVersion());
-		s.setCapsExt(d->client->capsExt());
+		s.setCaps(CapsSpec(d->client->capsNode(),d->client->capsVersion(),d->client->capsAlgorythm()));
 	}
 
 	if (!presenceSent) {
@@ -3168,14 +3169,19 @@ void PsiAccount::capsChanged(const Jid& j)
 
 	QString name = capsManager()->clientName(j);
 	QString version = (name.isEmpty() ? QString() : capsManager()->clientVersion(j));
+	QString os;
+
+	if (!name.isEmpty()) {
+		version = capsManager()->clientVersion(j);
+		os = capsManager()->osVersion(j);
+	}
 
 	foreach(UserListItem *u, findRelevant(j)) {
 		UserResourceList::Iterator rit = u->userResourceList().find(j.resource());
 		bool found = (rit == u->userResourceList().end()) ? false: true;
 		if(!found)
 			continue;
-		//(*rit).setClient(name,version,"");
-		(*rit).setClient(QString(),QString(),"");
+		(*rit).setClient(name,version,os);
 		cpUpdate(*u);
 	}
 }
diff --git a/src/psicon.cpp b/src/psicon.cpp
index eabbf28..c8f2c3a 100644
--- a/src/psicon.cpp
+++ b/src/psicon.cpp
@@ -750,14 +750,16 @@ void PsiCon::updateStatusPresets()
 
 void PsiCon::registerCaps(const QString& ext, const QStringList& features)
 {
-	DiscoItem::Identity identity = { "client", ApplicationInfo::name(), "pc" };
+	DiscoItem::Identity identity("client", "pc", NULL, ApplicationInfo::name() );
 	DiscoItem::Identities identities;
 	identities += identity;
+	DiscoItem item;
+	item.setIdentities(identities);
+	item.setFeatures(features);
 
 	d->capsRegistry->registerCaps(CapsSpec(ApplicationInfo::capsNode(),
-										   ApplicationInfo::capsVersion(), ext),
-								  identities,
-								  Features(features));
+										   ApplicationInfo::capsVersion(), ext, QString()),
+								  item);
 }
 
 void PsiCon::deinit()
