--- git.orig/admin/build/build_package.sh
+++ git/admin/build/build_package.sh
@@ -82,10 +82,13 @@ build_package_psi() {
 		cp $mqtdir/bin/QtNetwork4.dll $arch_prefix
 		cp $mqtdir/bin/QtXml4.dll $arch_prefix
 		cp $mqtdir/bin/QtGui4.dll $arch_prefix
+		cp $mqtdir/bin/QtSql4.dll $arch_prefix
 		mkdir -p $arch_prefix/imageformats
 		cp $mqtdir/plugins/imageformats/qgif4.dll $arch_prefix/imageformats
 		cp $mqtdir/plugins/imageformats/qjpeg4.dll $arch_prefix/imageformats
 		cp $mqtdir/plugins/imageformats/qmng4.dll $arch_prefix/imageformats
+		mkdir -p $arch_prefix/sqldrivers
+		cp $mqtdir/plugins/sqldrivers/qsqlite4.dll
 		cp $deps_base/$qca_win_dir/$target_arch/bin/qca2.dll $arch_prefix
 		mkdir -p $arch_prefix/crypto
 		cp $deps_base/$qca_win_dir/$target_arch/plugins/crypto/qca-gnupg2.dll $arch_prefix/crypto
@@ -126,8 +129,8 @@ build_package_psi() {
 			QT_LIB_PATH=$QTDIR/lib
 		fi
 		cd $psi_base
-		export DYLD_FRAMEWORK_PATH=$QT_LIB_PATH:$deps_base/$qca_mac_dir/lib:$deps_base/$growl_dir/Framework
-		./configure --with-qca-inc=$deps_base/$qca_mac_dir/include --with-qca-lib=$deps_base/$qca_mac_dir/lib --with-growl=$deps_base/$growl_dir/Framework --enable-universal
+		export DYLD_FRAMEWORK_PATH=$QT_LIB_PATH:$deps_base/$qca_mac_dir/lib:$deps_base/$growl_dir/Framework:$deps_base/$qjson_mac_dir/lib
+		./configure --with-qca-inc=$deps_base/$qca_mac_dir/include --with-qca-lib=$deps_base/$qca_mac_dir/lib --with-growl=$deps_base/$growl_dir/Framework --enable-universal --with-qjson-lib=$deps_base/$qjson_mac_dir/lib
 		make
 	fi
 }
--- git.orig/admin/build/devconfig.sh
+++ git/admin/build/devconfig.sh
@@ -60,7 +60,7 @@ if [ "$platform" == "win" ]; then
 	fi
 	mqtdir=`get_msys_path $qtdir`
 
-	PATH=$mqtdir/bin:$PATH ./configure.exe --qtdir=$qtdir --release --with-qca-inc=$deps_base/$qca_win_dir/$target_arch/include --with-qca-lib=$deps_base/$qca_win_dir/$target_arch/lib --with-zlib-inc=$deps_base/$zlib_win_dir/$target_arch/include --with-zlib-lib=$deps_base/$zlib_win_dir/$target_arch/lib --with-aspell-inc=$deps_base/$aspell_win_dir/$target_arch/include --with-aspell-lib=$deps_base/$aspell_win_dir/$target_arch/lib
+	PATH=$mqtdir/bin:$PATH ./configure.exe --qtdir=$qtdir --release --with-qca-inc=$deps_base/$qca_win_dir/$target_arch/include --with-qca-lib=$deps_base/$qca_win_dir/$target_arch/lib --with-zlib-inc=$deps_base/$zlib_win_dir/$target_arch/include --with-zlib-lib=$deps_base/$zlib_win_dir/$target_arch/lib --with-aspell-inc=$deps_base/$aspell_win_dir/$target_arch/include --with-aspell-lib=$deps_base/$aspell_win_dir/$target_arch/lib --with-qjson-inc=$deps_base/$qjson_win_dir/$target_arch/include --with-qjson-lib=$deps_base/$qjson_win_dir/$target_arch/lib
 
 	rm -f $build_base/devenv
 	touch $build_base/devenv
@@ -79,8 +79,8 @@ else
 	if [ "$QT_PLUGIN_PATH" == "" ]; then
 		QT_PLUGIN_PATH=$QTDIR/plugins
 	fi
-	export DYLD_FRAMEWORK_PATH=$QT_LIB_PATH:$deps_base/$qca_mac_dir/lib:$deps_base/$growl_dir/Framework
-	./configure --with-qca-inc=$deps_base/$qca_mac_dir/include --with-qca-lib=$deps_base/$qca_mac_dir/lib --with-growl=$deps_base/$growl_dir/Framework --enable-universal
+	export DYLD_FRAMEWORK_PATH=$QT_LIB_PATH:$deps_base/$qca_mac_dir/lib:$deps_base/$growl_dir/Framework:$deps_base/$qjson_mac_dir/lib
+	./configure --with-qca-inc=$deps_base/$qca_mac_dir/include --with-qca-lib=$deps_base/$qca_mac_dir/lib --with-growl=$deps_base/$growl_dir/Framework --enable-universal --with-qjson-lib=$deps_base/$qjson_mac_dir/lib
 
 	# remove some gstbundle problem files
 	rm -f $deps_base/$gstbundle_mac_dir/uni/lib/gstreamer-0.10/libgstximagesink.so
@@ -91,7 +91,7 @@ else
 	rm -f $build_base/devenv
 	touch $build_base/devenv
 	echo "export DYLD_LIBRARY_PATH=$deps_base/$gstbundle_mac_dir/uni/lib:\$DYLD_LIBRARY_PATH" >> $build_base/devenv
-	echo "export DYLD_FRAMEWORK_PATH=$QT_LIB_PATH:$deps_base/$qca_mac_dir/lib:$deps_base/$growl_dir/Framework:\$DYLD_FRAMEWORK_PATH" >> $build_base/devenv
+	echo "export DYLD_FRAMEWORK_PATH=$QT_LIB_PATH:$deps_base/$qca_mac_dir/lib:$deps_base/$growl_dir/Framework:$deps_base/$qjson_mac_dir/lib:\$DYLD_FRAMEWORK_PATH" >> $build_base/devenv
 	echo "export GST_PLUGIN_PATH=$deps_base/$gstbundle_mac_dir/uni/lib/gstreamer-0.10" >> $build_base/devenv
 	echo "export GST_REGISTRY_FORK=no" >> $build_base/devenv
 	echo "export QT_PLUGIN_PATH=$QT_PLUGIN_PATH:$deps_base/$qca_mac_dir/plugins" >> $build_base/devenv
--- git.orig/admin/build/package_info
+++ git/admin/build/package_info
@@ -39,3 +39,11 @@ psimedia_win_dir=psimedia-20120725-win
 psimedia_mac_file=psimedia-20120725-mac.tar.bz2
 psimedia_mac_url=http://psi-im.org/files/deps/psimedia-20120725-mac.tar.bz2
 psimedia_mac_dir=psimedia-20120725-mac
+
+qjson_win_file=qjson-0.8.1-win.zip
+qjson_win_url=http://psi-im.org/files/deps/qjson-0.8.1-win.zip
+qjson_win_dir=qjson-0.8.1-win
+
+qjson_mac_file=qjson-0.8.1-mac.tar.bz2
+qjson_mac_url=http://psi-im.org/files/deps/qjson-0.8.1-mac.tar.bz2
+qjson_mac_dir=qjson-0.8.1-mac
--- git.orig/admin/build/prep_dist.sh
+++ git/admin/build/prep_dist.sh
@@ -45,8 +45,8 @@ if [ "$platform" == "mac" ]; then
 
 	mkdir -p $target_dist_base
 
-	QT_FRAMEWORKS="QtCore QtNetwork QtXml QtGui"
-	QT_PLUGINS="imageformats/libqjpeg.dylib imageformats/libqgif.dylib imageformats/libqmng.dylib"
+	QT_FRAMEWORKS="QtCore QtNetwork QtXml QtGui QtSql"
+	QT_PLUGINS="imageformats/libqjpeg.dylib imageformats/libqgif.dylib imageformats/libqmng.dylib sqldrivers/libqsqlite.dylib"
 	QCA_PLUGINS="crypto/libqca-ossl.dylib crypto/libqca-gnupg.dylib"
 
 	cp -a $psi_base/psi.app $target_dist_base/Psi.app
@@ -57,6 +57,7 @@ if [ "$platform" == "mac" ]; then
 	done
 
 	install_name_tool -change qca.framework/Versions/2/qca @executable_path/../Frameworks/qca.framework/Versions/2/qca $contentsdir/MacOS/psi
+	install_name_tool -change qjson.framework/Versions/0.8.1/qjson @executable_path/../Frameworks/qjson.framework/Versions/0.8.1/qjson $contentsdir/MacOS/psi
 
 	mkdir -p $contentsdir/Frameworks
 	for f in $QT_FRAMEWORKS; do
@@ -80,8 +81,14 @@ if [ "$platform" == "mac" ]; then
 	cp -a $deps_base/$qca_mac_dir/lib/qca.framework $contentsdir/Frameworks
 	cleanup_framework $contentsdir/Frameworks/qca.framework qca 2
 	install_name_tool -id @executable_path/../Frameworks/qca.framework/Versions/2/qca $contentsdir/Frameworks/qca.framework/qca
+
+	cp -a $deps_base/$qjson_mac_dir/lib/qjson.framework $contentsdir/Frameworks
+	cleanup_framework $contentsdir/Frameworks/qjson.framework qjson 0.8.1
+	install_name_tool -id @executable_path/../Frameworks/qjson.framework/Versions/0.8.1/qjson $contentsdir/Frameworks/qjson.framework/qjson
+
 	for g in $QT_FRAMEWORKS; do
 		install_name_tool -change $g.framework/Versions/4/$g @executable_path/../Frameworks/$g.framework/Versions/4/$g $contentsdir/Frameworks/qca.framework/qca
+		install_name_tool -change $g.framework/Versions/4/$g @executable_path/../Frameworks/$g.framework/Versions/4/$g $contentsdir/Frameworks/qjson.framework/qjson
 	done
 
 	mkdir -p $contentsdir/Plugins/crypto
--- git.orig/options/default.xml
+++ git/options/default.xml
@@ -128,6 +128,9 @@
 				<status-with-priority comment="Show priority with status change" type="bool">false</status-with-priority>
 				<default-jid-mode comment="Default jid mode: barejid | auto" type="QString">auto</default-jid-mode>
 				<default-jid-mode-ignorelist comment="Default autojid mode ignore list: jid1,jid2,..." type="QString"></default-jid-mode-ignorelist>
+				<history comment="Message history options">
+					<preload-history-size comment="The number of preloaded messages" type="int">5</preload-history-size>
+				</history>
 			</chat>
 			<save>
 				<toolbars-state type="QByteArray"/>
@@ -672,6 +675,9 @@ QLineEdit#le_status_text {
 			</devices>
 			<video-support type="bool">false</video-support>
 		</media>
+		<history comment="General history options">
+			<store-muc-private comment="Keep a history of correspondence for MUC private" type="bool">false</store-muc-private>
+		</history>
 	</options>
 	<accounts comment="Account definitions and options"/>
 	<plugins comment="Plugin options"/>
--- git.orig/psi.qc
+++ git/psi.qc
@@ -17,6 +17,9 @@
   <dep type='qca'>
     <required/>
   </dep>
+  <dep type='qjson'>
+    <required/>
+  </dep>
   <dep type='zlib'>
     <required/>
   </dep>
--- git.orig/qcm/qjson.qcm
+++ git/qcm/qjson.qcm
@@ -0,0 +1,166 @@
+/*
+-----BEGIN QCMOD-----
+name: QJson
+arg: with-qjson-inc=[path],Path to QJson include files
+arg: with-qjson-lib=[path],Path to QJson library or framework files
+-----END QCMOD-----
+*/
+
+// adapted from json.prf
+static QString internal_json_prf(const QString &incdir, const QString &libdir, const QString &frameworkdir)
+{
+	QString out = QString(
+"QJSON_INCDIR = %1\n"
+"QJSON_LIBDIR = %2\n"
+"QJSON_FRAMEWORKDIR = %3\n"
+"\n"
+"CONFIG *= qt\n"
+"\n"
+"LINKAGE =\n"
+"\n"
+"!isEmpty(QJSON_FRAMEWORKDIR): {\n"
+"	framework_dir = $$QJSON_FRAMEWORKDIR\n"
+"	exists($$framework_dir/qjson.framework) {\n"
+"		QMAKE_FRAMEWORKPATH *= $$framework_dir\n"
+"		LIBS *= -F$$framework_dir\n"
+"		INCLUDEPATH += $$framework_dir/qjson.framework\n"
+"		LINKAGE = -framework qjson\n"
+"	}\n"
+"}\n"
+"\n"
+"# else, link normally\n"
+"isEmpty(LINKAGE) {\n"
+"	!isEmpty(QJSON_INCDIR):INCLUDEPATH += $$QJSON_INCDIR\n"
+"	!isEmpty(QJSON_LIBDIR):LIBS += -L$$QJSON_LIBDIR\n"
+"	LINKAGE = -lqjson\n"
+"	CONFIG(debug, debug|release) {\n"
+"		windows:LINKAGE = -lqjsond\n"
+"		mac:LINKAGE = -lqjson_debug\n"
+"	}\n"
+"}\n"
+"\n"
+"LIBS += $$LINKAGE\n"
+	).arg(incdir, libdir, frameworkdir);
+	return out;
+}
+
+// set either libdir or frameworkdir, but not both
+static bool qjson_try(Conf *conf, const QString &incdir, const QString &libdir, const QString &frameworkdir, bool release, bool debug, QString *_prf)
+{
+	QString proextra;
+	QString prf = internal_json_prf(incdir, libdir, frameworkdir);
+	proextra =
+	"CONFIG += qt\n"
+	"CONFIG -= debug_and_release debug release\n"
+	"QT -= gui\n";
+	proextra += prf;
+
+	QString str =
+	"#include <qjson/parser.h>\n"
+	"\n"
+	"int main()\n"
+	"{\n"
+	"	return 0;\n"
+	"}\n";
+
+	// test desired versions, potentially both release and debug
+
+	if(release)
+	{
+		int ret;
+		if(!conf->doCompileAndLink(str, QStringList(), QString(), proextra + "CONFIG += release\n", &ret) || ret != 0)
+			return false;
+	}
+
+	if(debug)
+	{
+		int ret;
+		if(!conf->doCompileAndLink(str, QStringList(), QString(), proextra + "CONFIG += debug\n", &ret) || ret != 0)
+			return false;
+	}
+
+	*_prf = prf;
+	return true;
+}
+
+static bool qjson_try_lib(Conf *conf, const QString &incdir, const QString &libdir, bool release, bool debug, QString *prf)
+{
+	return qjson_try(conf, incdir, libdir, QString(), release, debug, prf);
+}
+
+static bool qjson_try_framework(Conf *conf, const QString &frameworkdir, bool release, bool debug, QString *prf)
+{
+	return qjson_try(conf, QString(), QString(), frameworkdir, release, debug, prf);
+}
+
+//----------------------------------------------------------------------------
+// qc_qjson
+//----------------------------------------------------------------------------
+class qc_qjson : public ConfObj
+{
+public:
+	qc_qjson(Conf *c) : ConfObj(c) {}
+	QString name() const { return "QJson"; }
+	QString shortname() const { return "qjson"; }
+	bool exec()
+	{
+#if QT_VERSION < QT_VERSION_CHECK(5, 0, 0)
+		// get the build mode
+#ifdef QC_BUILDMODE
+		bool release = qc_buildmode_release;
+		bool debug = qc_buildmode_debug;
+#else
+		// else, default to just release mode
+		bool release = true;
+		bool debug = false;
+#endif
+
+		QString qjson_incdir, qjson_libdir, qjson_json_prf;
+		qjson_incdir = conf->getenv("QC_WITH_QJSON_INC");
+		qjson_libdir = conf->getenv("QC_WITH_QJSON_LIB");
+
+#if defined(Q_OS_MAC)
+		if(!qjson_libdir.isEmpty() && qjson_try_framework(conf, qjson_libdir, release, debug, &qjson_json_prf))
+		{
+			conf->addExtra(qjson_json_prf);
+			return true;
+		}
+#endif
+
+		if(!qjson_incdir.isEmpty() && !qjson_libdir.isEmpty() && qjson_try_lib(conf, qjson_incdir, qjson_libdir, release, debug, &qjson_json_prf))
+		{
+			conf->addExtra(qjson_json_prf);
+			return true;
+		}
+
+		QStringList incs;
+		QString version, libs, other;
+		if(conf->findPkgConfig("QJson", VersionAny, QString(), &version, &incs, &libs, &other))
+		{
+			for(int n = 0; n < incs.count(); ++n)
+				conf->addIncludePath(incs[n]);
+			if(!libs.isEmpty())
+				conf->addLib(libs);
+			return true;
+		}
+
+		QStringList prefixes;
+		prefixes += "/usr";
+		prefixes += "/usr/local";
+
+		for(int n = 0; n < prefixes.count(); ++n)
+		{
+			const QString &prefix = prefixes[n];
+			if(qjson_try_lib(conf, prefix + "/include", prefix + "/lib", release, debug, &qjson_json_prf))
+			{
+				conf->addExtra(qjson_json_prf);
+				return true;
+			}
+		}
+
+		return false;
+#else
+		return true;
+#endif
+	}
+};
--- git.orig/src/chatdlg.cpp
+++ git/src/chatdlg.cpp
@@ -73,8 +73,8 @@
 #include "psicontactlist.h"
 #include "accountlabel.h"
 #include "psirichtext.h"
-#include "messageview.h"
 #include "chatview.h"
+#include "eventdb.h"
 
 #ifdef Q_OS_WIN
 #include <windows.h>
@@ -98,6 +98,7 @@ ChatDlg* ChatDlg::create(const Jid& jid,
 ChatDlg::ChatDlg(const Jid& jid, PsiAccount* pa, TabManager* tabManager)
 	: TabbableWidget(jid, pa, tabManager)
 	, highlightersInstalled_(false)
+	, delayedMessages(0)
 {
 	pending_ = 0;
 	keepOpen_ = false;
@@ -110,6 +111,9 @@ ChatDlg::ChatDlg(const Jid& jid, PsiAcco
 
 	status_ = -1;
 
+	historyState = false;
+	preloadHistory();
+
 	autoSelectContact_ = false;
 	if (PsiOptions::instance()->getOption("options.ui.chat.default-jid-mode").toString() == "auto") {
 		UserListItem *uli = account()->findFirstRelevant(jid);
@@ -168,6 +172,8 @@ void ChatDlg::init()
 
 ChatDlg::~ChatDlg()
 {
+	if (delayedMessages)
+		delete delayedMessages;
 	account()->dialogUnregister(this);
 }
 
@@ -433,6 +439,43 @@ UserStatus ChatDlg::userStatusFor(const
 	return u;
 }
 
+void ChatDlg::preloadHistory()
+{
+	int cnt =PsiOptions::instance()->getOption("options.ui.chat.history.preload-history-size").toInt();
+	if (cnt > 0) {
+		holdMessages(true);
+		if (cnt > 100)
+			cnt = 100;
+		EDBHandle *h = new EDBHandle(account()->edb());
+		connect(h, SIGNAL(finished()), this, SLOT(getHistory()));
+		Jid j = jid();
+		if (!account()->findGCContact(j))
+			j = jid().bare();
+		int start = account()->eventQueue()->count(jid(), false);
+		h->get(account()->id(), j, QDateTime(), EDB::Backward, start, cnt);
+	}
+}
+
+void ChatDlg::getHistory()
+{
+	EDBHandle *h = qobject_cast<EDBHandle *>(sender());
+	if (!h)
+		return;
+
+	historyState = true;
+	const EDBResult &r = h->result();
+	for (int i = r.count() - 1; i >= 0; --i) {
+		const EDBItemPtr &item = r.at(i);
+		PsiEvent::Ptr e = item->event();
+		if (e->type() == PsiEvent::Message) {
+			MessageEvent::Ptr me = e.staticCast<MessageEvent>();
+			appendMessage(me->message(), me->originLocal());
+		}
+	}
+	delete h;
+	holdMessages(false);
+}
+
 void ChatDlg::ensureTabbedCorrectly()
 {
 	TabbableWidget::ensureTabbedCorrectly();
@@ -494,7 +537,7 @@ void ChatDlg::updateContact(const Jid &j
 			if (PsiOptions::instance()->getOption("options.ui.chat.show-status-changes").toBool()
 				&& fromPresence && statusChanged)
 			{
-				chatView()->dispatchMessage(MessageView::statusMessage(
+				dispatchMessage(MessageView::statusMessage(
 												dispNick_, status_,
 												statusString_, priority_));
 			}
@@ -789,6 +832,7 @@ void ChatDlg::doSend()
 
 void ChatDlg::doneSend()
 {
+	historyState = false;
 	appendMessage(m_, true);
 	disconnect(chatEdit(), SIGNAL(textChanged()), this, SLOT(setComposing()));
 	chatEdit()->clear();
@@ -817,6 +861,7 @@ void ChatDlg::encryptedMessageSent(int x
 
 void ChatDlg::incomingMessage(const Message &m)
 {
+	historyState = false;
 	if (m.body().isEmpty() && m.subject().isEmpty() && m.urlList().isEmpty()) {
 		// Event message
 		if (m.containsEvent(CancelEvent)) {
@@ -877,14 +922,16 @@ void ChatDlg::appendMessage(const Messag
 	// figure out the encryption state
 	bool encChanged = false;
 	bool encEnabled = false;
-	if (lastWasEncrypted_ != m.wasEncrypted()) {
-		encChanged = true;
+	if (!historyState) {
+		if (lastWasEncrypted_ != m.wasEncrypted()) {
+			encChanged = true;
+		}
+		lastWasEncrypted_ = m.wasEncrypted();
+		encEnabled = lastWasEncrypted_;
 	}
-	lastWasEncrypted_ = m.wasEncrypted();
-	encEnabled = lastWasEncrypted_;
 
 	if (encChanged) {
-		chatView()->dispatchMessage(MessageView::fromHtml(
+		dispatchMessage(MessageView::fromHtml(
 				encEnabled? QString("<icon name=\"psi/cryptoYes\"> ") + tr("Encryption Enabled"):
 							QString("<icon name=\"psi/cryptoNo\"> ") + tr("Encryption Disabled"),
 				MessageView::System
@@ -900,7 +947,9 @@ void ChatDlg::appendMessage(const Messag
 	}
 
 	if (!m.subject().isEmpty()) {
-		chatView()->dispatchMessage(MessageView::subjectMessage(m.subject()));
+		MessageView smv = MessageView::subjectMessage(m.subject());
+		smv.setSpooled(historyState);
+		dispatchMessage(smv);
 	}
 
 	MessageView mv(MessageView::Message);
@@ -930,10 +979,11 @@ void ChatDlg::appendMessage(const Messag
 	mv.setNick(whoNick(local));
 	mv.setUserId(local?account()->jid().full():jid().full()); // theoretically, this can be inferred from the chat dialog properties
 	mv.setDateTime(m.timeStamp());
-	mv.setSpooled(m.spooled());
+	mv.setSpooled(historyState);
 	mv.setAwaitingReceipt(local && m.messageReceipt() == ReceiptRequest);
 	mv.setReplaceId(m.replaceId());
-	chatView()->dispatchMessage(mv);
+	mv.setCarbonDirection(m.carbonDirection());
+	dispatchMessage(mv);
 
 	if (!m.urlList().isEmpty()) {
 		UrlList urls = m.urlList();
@@ -943,12 +993,52 @@ void ChatDlg::appendMessage(const Messag
 		}
 		// Some XMPP clients send links to HTTP uploaded files both in body and in jabber:x:oob.
 		// It's convenient to show only body if OOB data brings no additional information.
-		if (!(urlsMap.size() == 1 && urlsMap.contains(body) && urlsMap.value(body).isEmpty()))
-			chatView()->dispatchMessage(MessageView::urlsMessage(urlsMap));
+		if (!(urlsMap.size() == 1 && urlsMap.contains(body) && urlsMap.value(body).isEmpty())) {
+			MessageView umv = MessageView::urlsMessage(urlsMap);
+			umv.setSpooled(historyState);
+			dispatchMessage(umv);
+		}
 	}
+	emit messageAppended(body, chatView()->textWidget());
+}
+
+void ChatDlg::holdMessages(bool hold)
+{
+	if (hold) {
+		if (!delayedMessages)
+			delayedMessages = new QList<MessageView>();
+	}
+	else if (delayedMessages) {
+		foreach (const MessageView &mv, *delayedMessages)
+		{
+			if (mv.isSpooled())
+				displayMessage(mv);
+		}
+		foreach (const MessageView &mv, *delayedMessages)
+		{
+			if (!mv.isSpooled())
+				displayMessage(mv);
+		}
+		delete delayedMessages;
+		delayedMessages = 0;
+	}
+}
+
+void ChatDlg::dispatchMessage(const MessageView &mv)
+{
+	if (delayedMessages)
+		delayedMessages->append(mv);
+	else
+		displayMessage(mv);
+}
+
+void ChatDlg::displayMessage(const MessageView &mv)
+{
+	chatView()->dispatchMessage(mv);
 
 	// if we're not active, notify the user by changing the title
-	if (!isActiveTab() && m.carbonDirection() != Message::Sent) {
+	MessageView::Type type = mv.type();
+	if (type != MessageView::System && type != MessageView::Status && !mv.isSpooled() && !isActiveTab() && mv.carbonDirection() != Message::Sent) {
 		++pending_;
 		invalidateTab();
 		if (PsiOptions::instance()->getOption("options.ui.flash-windows").toBool()) {
@@ -970,11 +1060,10 @@ void ChatDlg::appendMessage(const Messag
 	//	messagesRead(jid());
 	//}
 
-	if (!local) {
+	if (!mv.isLocal()) {
 		keepOpen_ = true;
 		QTimer::singleShot(1000, this, SLOT(setKeepOpenFalse()));
 	}
-	emit messageAppended(body, chatView()->textWidget());
 }
 
 void ChatDlg::updateIsComposing(bool b)
--- git.orig/src/chatdlg.h
+++ git/src/chatdlg.h
@@ -33,6 +33,7 @@
 #include "advwidget.h"
 
 #include "tabbablewidget.h"
+#include "messageview.h"
 
 
 namespace XMPP
@@ -88,6 +89,7 @@ public:
 	Jid realJid() const;
 	bool autoSelectContact() const {return autoSelectContact_;};
 	static UserStatus userStatusFor(const Jid& jid, QList<UserListItem*> ul, bool forceEmptyResource);
+	void preloadHistory();
 
 signals:
 	void aInfo(const Jid &);
@@ -148,6 +150,7 @@ private slots:
 	void addEmoticon(QString text);
 	void initComposing();
 	void setComposing();
+	void getHistory();
 
 protected slots:
 	void checkComposing();
@@ -159,6 +162,9 @@ protected:
 	void updateRealJid();
 	void resetComposing();
 	void doneSend();
+	void holdMessages(bool hold);
+	void dispatchMessage(const MessageView &mv);
+	void displayMessage(const MessageView &mv);
 	virtual void setLooks();
 	void setSelfDestruct(int);
 	virtual void chatEditCreated();
@@ -214,9 +220,11 @@ private:
 	QTimer* composingTimer_;
 	bool isComposing_;
 	bool sendComposingEvents_;
+	bool historyState;
 	QString eventId_;
 	ChatState contactChatState_;
 	ChatState lastChatState_;
+	QList<MessageView> *delayedMessages;
 };
 
 #endif
--- git.orig/src/chatview_te.cpp
+++ git/src/chatview_te.cpp
@@ -88,6 +88,7 @@ ChatView::ChatView(QWidget *parent)
 			logIconTime = IconsetFactory::iconPixmap("psi/notification_chat_time").scaledToHeight(logIconsSize, Qt::SmoothTransformation);
 			logIconInfo = IconsetFactory::iconPixmap("psi/notification_chat_info").scaledToHeight(logIconsSize, Qt::SmoothTransformation);
 			logIconCorrected = IconsetFactory::iconPixmap("psi/action_templates_edit").scaledToHeight(logIconsSize, Qt::SmoothTransformation);
+			logIconHistory = IconsetFactory::iconPixmap("psi/history").scaledToHeight(logIconsSize, Qt::SmoothTransformation);
 		} else {
 			logIconReceive = IconsetFactory::iconPixmap("psi/notification_chat_receive");
 			logIconSend = IconsetFactory::iconPixmap("psi/notification_chat_send");
@@ -98,6 +99,7 @@ ChatView::ChatView(QWidget *parent)
 			logIconTime = IconsetFactory::iconPixmap("psi/notification_chat_time");
 			logIconInfo = IconsetFactory::iconPixmap("psi/notification_chat_info");
 			logIconCorrected = IconsetFactory::iconPixmap("psi/action_templates_edit");
+			logIconHistory = IconsetFactory::iconPixmap("psi/history");
 		}
 		addLogIconsResources();
 	}
@@ -177,6 +179,7 @@ void ChatView::addLogIconsResources()
 	document()->addResource(QTextDocument::ImageResource, QUrl("icon:log_icon_delivered"), logIconDelivered);
 	document()->addResource(QTextDocument::ImageResource, QUrl("icon:log_icon_delivered_pgp"), logIconDeliveredPgp);
 	document()->addResource(QTextDocument::ImageResource, QUrl("icon:log_icon_corrected"), logIconCorrected);
+	document()->addResource(QTextDocument::ImageResource, QUrl("icon:log_icon_history"), logIconHistory);
 }
 
 void ChatView::markReceived(QString id)
@@ -459,28 +462,49 @@ void ChatView::renderMucMessage(const Me
 void ChatView::renderMessage(const MessageView &mv)
 {
 	QString timestr = formatTimeStamp(mv.dateTime());
-	QString color = colorString(mv.isLocal(), mv.isSpooled());
+	QString color = colorString(mv.isLocal(), false);
 	if (useMessageIcons_ && mv.isAwaitingReceipt()) {
 		document()->addResource(QTextDocument::ImageResource, QUrl(QString("icon:delivery") + mv.messageId()),
 					isEncryptionEnabled_ ? logIconSendPgp : logIconSend);
 	}
-	QString icon = useMessageIcons_ ?
-		(QString("<img src=\"%1\" />").arg(mv.isLocal()?
-		(mv.isAwaitingReceipt() ? QString("icon:delivery") + mv.messageId()
-			: isEncryptionEnabled_ ? "icon:log_icon_send_pgp" : "icon:log_icon_send")
-		: isEncryptionEnabled_ ? "icon:log_icon_receive_pgp" : "icon:log_icon_receive")) : "";
+	QString icon;
+	if (useMessageIcons_) {
+		QString sRes;
+		if (mv.isSpooled())
+			sRes = "icon:log_icon_history";
+		else if (mv.isLocal()) {
+			if (mv.isAwaitingReceipt())
+				sRes = QString("icon:delivery") + mv.messageId();
+			else if (isEncryptionEnabled_)
+				sRes = "icon:log_icon_receive_pgp";
+			else
+				sRes = "icon:log_icon_send";
+		} else {
+			if (isEncryptionEnabled_)
+				sRes = "icon:log_icon_receive_pgp";
+			else
+				sRes = "icon:log_icon_receive";
+		}
+		icon = QString("<img src=\"%1\" />").arg(sRes);
+	}
+	QString str;
 
 	QString inner = mv.formattedText() + replaceMarker(mv);
 	if (mv.isEmote()) {
-		appendText(icon + QString("<span style=\"color: %1\">").arg(color) + QString("[%1]").arg(timestr) + QString(" *%1 ").arg(TextUtil::escape(mv.nick())) + inner + "</span>");
+		str = icon + QString("<span style=\"color: %1\">").arg(color) + QString("[%1]").arg(timestr) + QString(" *%1 ").arg(TextUtil::escape(mv.nick())) + inner + "</span>";
 	} else {
 		if (PsiOptions::instance()->getOption("options.ui.chat.use-chat-says-style").toBool()) {
-			appendText(icon + QString("<span style=\"color: %1\">").arg(color) + QString("[%1] ").arg(timestr) + tr("%1 says:").arg(TextUtil::escape(mv.nick())) + "</span><br>" + inner);
+			str = icon + QString("<span style=\"color: %1\">").arg(color) + QString("[%1] ").arg(timestr) + tr("%1 says:").arg(TextUtil::escape(mv.nick())) + "</span><br>";
 		}
 		else {
-			appendText(icon + QString("<span style=\"color: %1\">").arg(color) + QString("[%1] &lt;").arg(timestr) + TextUtil::escape(mv.nick()) + QString("&gt;</span> ") + inner);
+			str = icon + QString("<span style=\"color: %1\">").arg(color) + QString("[%1] &lt;").arg(timestr) + TextUtil::escape(mv.nick()) + QString("&gt;</span> ");
 		}
+		if (mv.isSpooled())
+			str.append(QString("<span style=\"color: %1\">%2</span>").arg(ColorOpt::instance()->color("options.ui.look.colors.messages.usertext").name()).arg(inner));
+		else
+			str.append(inner);
 	}
+	appendText(str);
 
 	if (mv.isLocal() && PsiOptions::instance()->getOption("options.ui.chat.auto-scroll-to-bottom").toBool() ) {
 		deferredScroll();
--- git.orig/src/chatview_te.h
+++ git/src/chatview_te.h
@@ -121,6 +121,7 @@ private:
 	QPixmap logIconTime;
 	QPixmap logIconInfo;
 	QPixmap logIconCorrected;
+	QPixmap logIconHistory;
 	QAction *actQuote_;
 };
 
--- git.orig/src/edbsqlite.cpp
+++ git/src/edbsqlite.cpp
@@ -0,0 +1,874 @@
+/*
+ * edbsqlite.cpp
+ * Copyright (C) 2011   Aleksey Andreev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include <QSqlError>
+#include <QSqlDriver>
+#ifndef HAVE_QT5
+#include <qjson/parser.h>
+#include "qjson/serializer.h"
+#else
+#include <QJsonArray>
+#include <QJsonDocument>
+#include <QJsonObject>
+#endif
+
+#include "edbsqlite.h"
+//#include "common.h"
+#include "applicationinfo.h"
+#include "psicontactlist.h"
+#include "jidutil.h"
+#include "historyimp.h"
+
+#define FAKEDELAY 0
+
+using namespace XMPP;
+
+//----------------------------------------------------------------------------
+// EDBSqLite
+//----------------------------------------------------------------------------
+
+EDBSqLite::EDBSqLite(PsiCon *psi) : EDB(psi),
+	transactionsCounter(0),
+	lastCommitTime(QDateTime::currentDateTime()),
+	commitTimer(NULL),
+	mirror_(NULL)
+{
+	status = NotActive;
+	QString path = ApplicationInfo::historyDir() + "/history.db";
+	QSqlDatabase db = QSqlDatabase::addDatabase("QSQLITE", "history");
+	db.setDatabaseName(path);
+	if (!db.open()) {
+		qWarning("EDBSqLite::EDBSqLite(): Can't open base.\n" + db.lastError().text().toLatin1());
+		return;
+	}
+	QSqlQuery query(db);
+	query.exec("PRAGMA foreign_keys = ON;");
+	setInsertingMode(Normal);
+	if (db.tables(QSql::Tables).size() == 0) {
+		// no tables found.
+		if (db.transaction()) {
+			query.exec("CREATE TABLE `system` ("
+				"`key` TEXT, "
+				"`value` TEXT"
+				");");
+			query.exec("CREATE TABLE `accounts` ("
+				"`id` TEXT, "
+				"`lifetime` INTEGER"
+				");");
+			query.exec("CREATE TABLE `contacts` ("
+				"`id` INTEGER NOT NULL PRIMARY KEY ASC, "
+				"`acc_id` TEXT, "
+				"`type` INTEGER, "
+				"`jid` TEXT, "
+				"`lifetime` INTEGER"
+				");");
+			query.exec("CREATE TABLE `events` ("
+				"`id` INTEGER NOT NULL PRIMARY KEY ASC, "
+				"`contact_id` INTEGER NOT NULL REFERENCES `contacts`(`id`) ON DELETE CASCADE, "
+				"`resource` TEXT, "
+				"`date` TEXT, "
+				"`type` INTEGER, "
+				"`direction` INTEGER, "
+				"`subject` TEXT, "
+				"`m_text` TEXT, "
+				"`lang` TEXT, "
+				"`extra_data` TEXT"
+				");");
+			query.exec("CREATE INDEX `key` ON `system` (`key`);");
+			query.exec("CREATE INDEX `jid` ON `contacts` (`jid`);");
+			query.exec("CREATE INDEX `contact_id` ON `events` (`contact_id`);");
+			query.exec("CREATE INDEX `date` ON `events` (`date`);");
+			if (db.commit()) {
+				status = Commited;
+				setStorageParam("version", "0.1");
+				setStorageParam("import_start", "yes");
+			}
+		}
+	}
+	else
+		status = Commited;
+}
+
+EDBSqLite::~EDBSqLite()
+{
+	commit();
+	{
+		QSqlDatabase db = QSqlDatabase::database("history", false);
+		if (db.isOpen())
+			db.close();
+	}
+	QSqlDatabase::removeDatabase("history");
+}
+
+bool EDBSqLite::init()
+{
+	if (status == NotActive)
+		return false;
+
+	if (!getStorageParam("import_start").isEmpty()) {
+		if (!importExecute()) {
+			status = NotActive;
+			return false;
+		}
+	}
+
+	setMirror(new EDBFlatFile(psi()));
+	return true;
+}
+
+int EDBSqLite::features() const
+{
+	return SeparateAccounts | PrivateContacts | AllContacts | AllAccounts;
+}
+
+int EDBSqLite::get(const QString &accId, const XMPP::Jid &jid, QDateTime date, int direction, int start, int len)
+{
+	item_query_req *r = new item_query_req;
+	r->accId = accId;
+	r->j     = jid;
+	r->type  = item_query_req::Type_get;
+	r->start = start;
+	r->len   = len < 1 ? 1 : len;
+	r->dir   = direction;
+	r->date  = date;
+	r->id    = genUniqueId();
+	rlist.append(r);
+
+	QTimer::singleShot(FAKEDELAY, this, SLOT(performRequests()));
+	return r->id;
+}
+
+int EDBSqLite::find(const QString &accId, const QString &str, const XMPP::Jid &jid, const QDateTime date, int direction)
+{
+	item_query_req *r = new item_query_req;
+	r->accId   = accId;
+	r->j       = jid;
+	r->type    = item_query_req::Type_find;
+	r->len     = 1;
+	r->dir     = direction;
+	r->findStr = str;
+	r->date    = date;
+	r->id      = genUniqueId();
+	rlist.append(r);
+
+	QTimer::singleShot(FAKEDELAY, this, SLOT(performRequests()));
+	return r->id;
+}
+
+int EDBSqLite::append(const QString &accId, const XMPP::Jid &jid, const PsiEvent::Ptr &e, int type)
+{
+	item_query_req *r = new item_query_req;
+	r->accId   = accId;
+	r->j       = jid;
+	r->jidType = type;
+	r->type    = item_query_req::Type_append;
+	r->event   = e;
+	if ( !r->event ) {
+		qWarning("EDBSqLite::append(): Attempted to append incompatible type.");
+		delete r;
+		return 0;
+	}
+	r->id      = genUniqueId();
+	rlist.append(r);
+
+	QTimer::singleShot(FAKEDELAY, this, SLOT(performRequests()));
+
+	if (mirror_)
+		mirror_->append(accId, jid, e, type);
+
+	return r->id;
+}
+
+int EDBSqLite::erase(const QString &accId, const XMPP::Jid &jid)
+{
+	item_query_req *r = new item_query_req;
+	r->accId = accId;
+	r->j     = jid;
+	r->type  = item_query_req::Type_erase;
+	r->id    = genUniqueId();
+	rlist.append(r);
+
+	QTimer::singleShot(FAKEDELAY, this, SLOT(performRequests()));
+
+	if (mirror_)
+		mirror_->erase(accId, jid);
+
+	return r->id;
+}
+
+QList<EDB::ContactItem> EDBSqLite::contacts(const QString &accId, int type)
+{
+	QList<ContactItem> res;
+	EDBSqLite::PreparedQuery *query = queryes.getPreparedQuery(QueryContactsList, accId.isEmpty(), true);
+	query->bindValue(":type", type);
+	if (!accId.isEmpty())
+		query->bindValue(":acc_id", accId);
+	if (query->exec()) {
+		while (query->next()) {
+			const QSqlRecord &rec = query->record();
+			res.append(ContactItem(rec.value("acc_id").toString(), XMPP::Jid(rec.value("jid").toString())));
+		}
+		query->freeResult();
+	}
+	return res;
+}
+
+quint64 EDBSqLite::eventsCount(const QString &accId, const XMPP::Jid &jid)
+{
+	quint64 res = 0;
+	bool fAccAll  = accId.isEmpty();
+	bool fContAll = jid.isEmpty();
+	EDBSqLite::PreparedQuery *query = queryes.getPreparedQuery(QueryRowCount, fAccAll, fContAll);
+	if (!fAccAll)
+		query->bindValue(":acc_id", accId);
+	if (!fContAll)
+		query->bindValue(":jid", jid.full());
+	if (query->exec()) {
+		if (query->next())
+			res = query->record().value("count").toULongLong();
+		query->freeResult();
+	}
+	return res;
+}
+
+QString EDBSqLite::getStorageParam(const QString &key)
+{
+	QSqlQuery query(QSqlDatabase::database("history"));
+	query.prepare("SELECT `value` FROM `system` WHERE `key` = :key;");
+	query.bindValue(":key", key);
+	if (query.exec() && query.next())
+		return query.record().value("value").toString();
+	return QString();
+}
+
+void EDBSqLite::setStorageParam(const QString &key, const QString &val)
+{
+	transaction(true);
+	QSqlQuery query(QSqlDatabase::database("history"));
+	if (val.isEmpty()) {
+		query.prepare("DELETE FROM `system` WHERE `key` = :key;");
+		query.bindValue(":key", key);
+		query.exec();
+	}
+	else {
+		query.prepare("SELECT COUNT(*) AS `count` FROM `system` WHERE `key` = :key;");
+		query.bindValue(":key", key);
+		if (query.exec() && query.next() && query.record().value("count").toULongLong() != 0) {
+			query.prepare("UPDATE `system` SET `value` = :val WHERE `key` = :key;");
+			query.bindValue(":key", key);
+			query.bindValue(":val", val);
+			query.exec();
+		}
+		else {
+			query.prepare("INSERT INTO `system` (`key`, `value`) VALUES (:key, :val);");
+			query.bindValue(":key", key);
+			query.bindValue(":val", val);
+			query.exec();
+		}
+	}
+	commit();
+}
+
+void EDBSqLite::setInsertingMode(InsertMode mode)
+{
+	// in the case of a flow of new records
+	if (mode == Import) {
+		// Commit after 10000 inserts and every 5 seconds
+		maxUncommitedRecs = 10000;
+		maxUncommitedSecs = 5;
+	} else {
+		// Commit after 3 inserts and every 1 second
+		maxUncommitedRecs = 3;
+		maxUncommitedSecs = 1;
+	}
+	// Commit if there were no new additions for 1 second
+	commitByTimeoutSecs = 1;
+	//--
+	commit();
+}
+
+void EDBSqLite::setMirror(EDBFlatFile *mirr)
+{
+	if (mirr != mirror_) {
+		if (mirror_)
+			delete mirror_;
+		mirror_ = mirr;
+	}
+}
+
+EDBFlatFile *EDBSqLite::mirror() const
+{
+	return mirror_;
+}
+
+void EDBSqLite::performRequests()
+{
+	if (rlist.isEmpty())
+		return;
+
+	item_query_req *r = rlist.takeFirst();
+	const int type = r->type;
+
+	if (type == item_query_req::Type_append) {
+		bool b = appendEvent(r->accId, r->j, r->event, r->jidType);
+		writeFinished(r->id, b);
+	}
+
+	else if (type == item_query_req::Type_get) {
+		commit();
+		bool fContAll = r->j.isEmpty();
+		bool fAccAll  = r->accId.isEmpty();
+		QueryType queryType;
+		if (r->date.isNull()) {
+			if (r->dir == Forward)
+				queryType = QueryOldest;
+			else
+				queryType = QueryLatest;
+		} else {
+			if (r->dir == Backward)
+				queryType = QueryDateBackward;
+			else
+				queryType = QueryDateForward;
+		}
+		EDBSqLite::PreparedQuery *query = queryes.getPreparedQuery(queryType, fAccAll, fContAll);
+		if (!fContAll)
+			query->bindValue(":jid", r->j.full());
+		if (!fAccAll)
+			query->bindValue(":acc_id", r->accId);
+		if (!r->date.isNull())
+			query->bindValue(":date", r->date);
+		query->bindValue(":start", r->start);
+		query->bindValue(":cnt", r->len);
+		EDBResult result;
+		if (query->exec()) {
+			while (query->next()) {
+				PsiEvent::Ptr e(getEvent(query->record()));
+				if (e) {
+					QString id = query->record().value("id").toString();
+					result.append(EDBItemPtr(new EDBItem(e, id)));
+				}
+			}
+			query->freeResult();
+		}
+		int beginRow;
+		if (r->dir == Forward && r->date.isNull()) {
+			beginRow = r->start;
+		} else {
+			int cnt = rowCount(r->accId, r->j, r->date);
+			if (r->dir == Backward) {
+				beginRow = cnt - r->len + 1;
+				if (beginRow < 0)
+					beginRow = 0;
+			} else {
+				beginRow = cnt + 1;
+			}
+		}
+		resultReady(r->id, result, beginRow);
+
+	} else if(type == item_query_req::Type_find) {
+		commit();
+		bool fContAll = r->j.isEmpty();
+		bool fAccAll  = r->accId.isEmpty();
+		EDBSqLite::PreparedQuery *query = queryes.getPreparedQuery(QueryFindText, fAccAll, fContAll);
+		if (!fContAll)
+			query->bindValue(":jid", r->j.full());
+		if (!fAccAll)
+			query->bindValue(":acc_id", r->accId);
+		EDBResult result;
+		if (query->exec()) {
+			QString str = r->findStr.toLower();
+			while (query->next()) {
+				const QSqlRecord rec = query->record();
+				if (!rec.value("m_text").toString().toLower().contains(str, Qt::CaseSensitive))
+					continue;
+				PsiEvent::Ptr e(getEvent(rec));
+				if (e) {
+					QString id = rec.value("id").toString();
+					EDBItemPtr eip = EDBItemPtr(new EDBItem(e, id));
+					result.append(eip);
+				}
+			}
+			query->freeResult();
+		}
+		resultReady(r->id, result, 0);
+
+	} else if(type == item_query_req::Type_erase) {
+		writeFinished(r->id, eraseHistory(r->accId, r->j));
+	}
+
+	delete r;
+}
+
+bool EDBSqLite::appendEvent(const QString &accId, const XMPP::Jid &jid, const PsiEvent::Ptr &e, int jidType)
+{
+	QSqlDatabase db = QSqlDatabase::database("history");
+	const qint64 contactId = ensureJidRowId(accId, jid, jidType);
+	if (contactId == 0)
+		return false;
+
+	QDateTime dTime;
+	int nType = 0;
+
+	if (e->type() == PsiEvent::Message) {
+		MessageEvent::Ptr me = e.staticCast<MessageEvent>();
+		const Message &m = me->message();
+		dTime = m.timeStamp();
+		if (m.type() == "chat")
+			nType = 1;
+		else if(m.type() == "error")
+			nType = 4;
+		else if(m.type() == "headline")
+			nType = 5;
+
+	} else if (e->type() == PsiEvent::Auth) {
+		AuthEvent::Ptr ae = e.staticCast<AuthEvent>();
+		dTime = ae->timeStamp();
+		QString subType = ae->authType();
+		if(subType == "subscribe")
+			nType = 3;
+		else if(subType == "subscribed")
+			nType = 6;
+		else if(subType == "unsubscribe")
+			nType = 7;
+		else if(subType == "unsubscribed")
+			nType = 8;
+	} else
+		return false;
+
+	int nDirection = e->originLocal() ? 1 : 2;
+	if (!transaction(false))
+		return false;
+
+	PreparedQuery *query = queryes.getPreparedQuery(QueryInsertEvent, false, false);
+	query->bindValue(":contact_id", contactId);
+	query->bindValue(":resource", (jidType != GroupChatContact) ? jid.resource() : "");
+	query->bindValue(":date", dTime);
+	query->bindValue(":type", nType);
+	query->bindValue(":direction", nDirection);
+	if (nType == 0 || nType == 1 || nType == 4 || nType == 5) {
+		MessageEvent::Ptr me = e.staticCast<MessageEvent>();
+		const Message &m = me->message();
+		QString lang = m.lang();
+		query->bindValue(":subject", m.subject(lang));
+		query->bindValue(":m_text", m.body(lang));
+		query->bindValue(":lang", lang);
+		QString extraData;
+		const UrlList &urls = m.urlList();
+		if (!urls.isEmpty()) {
+			QVariantMap xepList;
+			QVariantList urlList;
+			foreach (const Url &url, urls)
+				if (!url.url().isEmpty()) {
+					QVariantList urlItem;
+					urlItem.append(QVariant(url.url()));
+					if (!url.desc().isEmpty())
+						urlItem.append(QVariant(url.desc()));
+					urlList.append(QVariant(urlItem));
+				}
+			xepList["jabber:x:oob"] = QVariant(urlList);
+#ifndef HAVE_QT5
+			QJson::Serializer serializer;
+			extraData = QString::fromUtf8(serializer.serialize(xepList));
+#else
+			QJsonDocument doc(QJsonObject::fromVariantMap(xepList));
+			extraData = QString::fromUtf8(doc.toBinaryData());
+#endif
+		}
+		query->bindValue(":extra_data", extraData);
+	}
+	else {
+		query->bindValue(":subject", QVariant(QVariant::String));
+		query->bindValue(":m_text", QVariant(QVariant::String));
+		query->bindValue(":lang", QVariant(QVariant::String));
+		query->bindValue(":extra_data", QVariant(QVariant::String));
+	}
+	bool res = query->exec();
+	return res;
+}
+
+PsiEvent::Ptr EDBSqLite::getEvent(const QSqlRecord &record)
+{
+	PsiAccount *pa = psi()->contactList()->getAccount(record.value("acc_id").toString());
+
+	int type = record.value("type").toInt();
+
+	if(type == 0 || type == 1 || type == 4 || type == 5) {
+		Message m;
+		m.setTimeStamp(record.value("date").toDateTime());
+		if(type == 1)
+			m.setType("chat");
+		else if(type == 4)
+			m.setType("error");
+		else if(type == 5)
+			m.setType("headline");
+		else
+			m.setType("");
+		m.setFrom(Jid(record.value("jid").toString()));
+		QVariant text = record.value("m_text");
+		if (!text.isNull()) {
+			m.setBody(text.toString());
+			m.setLang(record.value("lang").toString());
+			m.setSubject(record.value("subject").toString());
+		}
+		m.setSpooled(true);
+		QString extraStr = record.value("extra_data").toString();
+		if (!extraStr.isEmpty()) {
+#ifndef HAVE_QT5
+			QJson::Parser parser;
+#endif
+			bool fOk;
+#ifndef HAVE_QT5
+			QVariantMap extraData = parser.parse(extraStr.toUtf8(), &fOk).toMap();
+#else
+			QJsonDocument doc = QJsonDocument::fromJson(extraStr.toUtf8());
+			fOk = !doc.isNull();
+			QVariantMap extraData = doc.object().toVariantMap();
+#endif
+			if (fOk) {
+				foreach (const QVariant &urlItem, extraData["jabber:x:oob"].toList()) {
+					QVariantList itemList = urlItem.toList();
+					if (!itemList.isEmpty()) {
+						QString url = itemList.at(0).toString();
+						QString desc;
+						if (itemList.size() > 1)
+							desc = itemList.at(1).toString();
+						m.urlAdd(Url(url, desc));
+					}
+				}
+			}
+		}
+		MessageEvent::Ptr me(new MessageEvent(m, pa));
+		me->setOriginLocal((record.value("direction").toInt() == 1));
+		return me.staticCast<PsiEvent>();
+	}
+
+	if(type == 2 || type == 3 || type == 6 || type == 7 || type == 8) {
+		QString subType = "subscribe";
+		// if(type == 2) { // Not used (stupid "system message" from Psi <= 0.8.6)
+		if(type == 3)
+			subType = "subscribe";
+		else if(type == 6)
+			subType = "subscribed";
+		else if(type == 7)
+			subType = "unsubscribe";
+		else if(type == 8)
+			subType = "unsubscribed";
+
+		AuthEvent::Ptr ae(new AuthEvent(Jid(record.value("jid").toString()), subType, pa));
+		ae->setTimeStamp(record.value("date").toDateTime());
+		return ae.staticCast<PsiEvent>();
+	}
+	return PsiEvent::Ptr();
+}
+
+qint64 EDBSqLite::ensureJidRowId(const QString &accId, const XMPP::Jid &jid, int type)
+{
+	if (jid.isEmpty())
+		return 0;
+	QString sJid = (type == GroupChatContact) ? jid.full() : jid.bare();
+	QString sKey = accId + "|" + sJid;
+	qint64 id = jidsCache.value(sKey, 0);
+	if (id != 0)
+		return id;
+
+	EDBSqLite::PreparedQuery *query = queryes.getPreparedQuery(QueryJidRowId, false, false);
+	query->bindValue(":jid", sJid);
+	query->bindValue(":acc_id", accId);
+	if (query->exec()) {
+		if (query->first()) {
+			id = query->record().value("id").toLongLong();
+		} else {
+			//
+			QSqlQuery queryIns(QSqlDatabase::database("history"));
+			queryIns.prepare("INSERT INTO `contacts` (`acc_id`, `type`, `jid`, `lifetime`)"
+				" VALUES (:acc_id, :type, :jid, -1);");
+			queryIns.bindValue(":acc_id", accId);
+			queryIns.bindValue(":type", type);
+			queryIns.bindValue(":jid", sJid);
+			if (queryIns.exec()) {
+				id  = queryIns.lastInsertId().toLongLong();
+			}
+		}
+		query->freeResult();
+		if (id != 0)
+			jidsCache[sKey] = id;
+	}
+	return id;
+}
+
+int EDBSqLite::rowCount(const QString &accId, const XMPP::Jid &jid, QDateTime before)
+{
+	bool fAccAll  = accId.isEmpty();
+	bool fContAll = jid.isEmpty();
+	QueryType type;
+	if (before.isNull())
+		type = QueryRowCount;
+	else
+		type = QueryRowCountBefore;
+	PreparedQuery *query = queryes.getPreparedQuery(type, fAccAll, fContAll);
+	if (!fContAll)
+		query->bindValue(":jid", jid.full());
+	if (!fAccAll)
+		query->bindValue(":acc_id", accId);
+	if (!before.isNull())
+		query->bindValue(":date", before);
+	int res = 0;
+	if (query->exec()) {
+		if (query->next()) {
+			res = query->record().value("count").toInt();
+		}
+		query->freeResult();
+	}
+	return res;
+}
+
+bool EDBSqLite::eraseHistory(const QString &accId, const XMPP::Jid &jid)
+{
+	bool res = false;
+	if (!transaction(true))
+		return false;
+
+	if (accId.isEmpty() && jid.isEmpty()) {
+		QSqlQuery query(QSqlDatabase::database("history"));
+		//if (query.exec("DELETE FROM `events`;"))
+			if (query.exec("DELETE FROM `contacts`;")) {
+				jidsCache.clear();
+				res = true;
+			}
+	}
+	else {
+		PreparedQuery *query = queryes.getPreparedQuery(QueryJidRowId, false, false);
+		query->bindValue(":jid", jid.full());
+		query->bindValue(":acc_id", accId);
+		if (query->exec()) {
+			if (query->next()) {
+				const qint64 id = query->record().value("id").toLongLong();
+				QSqlQuery query2(QSqlDatabase::database("history"));
+				query2.prepare("DELETE FROM `events` WHERE `contact_id` = :id;");
+				query2.bindValue(":id", id);
+				if (query2.exec()) {
+					res = true;
+					query2.prepare("DELETE FROM `contacts` WHERE `id` = :id AND `lifetime` = -1;");
+					query2.bindValue(":id", id);
+					if (query2.exec()) {
+						if (query2.numRowsAffected() > 0)
+							jidsCache.clear();
+					} else
+						res = false;
+				}
+			}
+			query->freeResult();
+		}
+	}
+	if (res)
+		res = commit();
+	else
+		rollback();
+	return res;
+}
+
+bool EDBSqLite::transaction(bool now)
+{
+	if (status == NotActive)
+		return false;
+	if (now || transactionsCounter >= maxUncommitedRecs
+			|| lastCommitTime.secsTo(QDateTime::currentDateTime()) >= maxUncommitedSecs)
+		if (!commit())
+			return false;
+
+	if (status == Commited) {
+		if (!QSqlDatabase::database("history").transaction())
+			return false;
+		status = NotCommited;
+	}
+	++transactionsCounter;
+
+	startAutocommitTimer();
+
+	return true;
+}
+
+bool EDBSqLite::commit()
+{
+	if (status != NotActive) {
+		if (status == Commited || QSqlDatabase::database("history").commit()) {
+			transactionsCounter = 0;
+			lastCommitTime = QDateTime::currentDateTime();
+			status = Commited;
+			stopAutocommitTimer();
+			return true;
+		}
+	}
+	return false;
+}
+
+bool EDBSqLite::rollback()
+{
+	if (status == NotCommited && QSqlDatabase::database("history").rollback()) {
+		transactionsCounter = 0;
+		lastCommitTime = QDateTime::currentDateTime();
+		status = Commited;
+		stopAutocommitTimer();
+		return true;
+	}
+	return false;
+}
+
+void EDBSqLite::startAutocommitTimer()
+{
+	if (!commitTimer) {
+		commitTimer = new QTimer(this);
+		connect(commitTimer, SIGNAL(timeout()), this, SLOT(commit()));
+		commitTimer->setSingleShot(true);
+		commitTimer->setInterval(commitByTimeoutSecs * 1000);
+	}
+	commitTimer->start();
+}
+
+void EDBSqLite::stopAutocommitTimer()
+{
+	if (commitTimer && commitTimer->isActive())
+		commitTimer->stop();
+}
+
+bool EDBSqLite::importExecute()
+{
+	bool res = true;
+	HistoryImport *imp = new HistoryImport(psi());
+	if (imp->isNeeded()) {
+		if (imp->exec() != HistoryImport::ResultNormal) {
+			res = false;
+		}
+	}
+	delete imp;
+	return res;
+}
+
+// ****************** class PreparedQueryes ********************
+
+EDBSqLite::QueryStorage::QueryStorage()
+{
+}
+
+EDBSqLite::QueryStorage::~QueryStorage()
+{
+	foreach (EDBSqLite::PreparedQuery *q, queryList.values()) {
+		if (q)
+			delete q;
+	}
+}
+
+EDBSqLite::PreparedQuery *EDBSqLite::QueryStorage::getPreparedQuery(QueryType type, bool allAccounts, bool allContacts)
+{
+	QueryProperty queryProp(type, allAccounts, allContacts);
+	EDBSqLite::PreparedQuery *q = queryList.value(queryProp, NULL);
+	if (q != NULL)
+		return q;
+
+	q = new EDBSqLite::PreparedQuery(QSqlDatabase::database("history"));
+	q->setForwardOnly(true);
+	q->prepare(getQueryString(type, allAccounts, allContacts));
+	queryList[queryProp] = q;
+	return q;
+}
+
+EDBSqLite::PreparedQuery::PreparedQuery(QSqlDatabase db) : QSqlQuery(db)
+{
+}
+
+QString EDBSqLite::QueryStorage::getQueryString(QueryType type, bool allAccounts, bool allContacts)
+{
+	QString queryStr;
+	switch (type)
+	{
+		case QueryContactsList:
+			queryStr = "SELECT `acc_id`, `jid` FROM `contacts` WHERE `type` = :type";
+			if (!allAccounts)
+				queryStr.append(" AND `acc_id` = :acc_id");
+			queryStr.append(" ORDER BY `jid`;");
+			break;
+		case QueryLatest:
+		case QueryOldest:
+		case QueryDateBackward:
+		case QueryDateForward:
+			queryStr = "SELECT `acc_id`, `events`.`id`, `jid`, `date`, `events`.`type`, `direction`, `subject`, `m_text`, `lang`, `extra_data`"
+				" FROM `events`, `contacts`"
+				" WHERE `contacts`.`id` = `contact_id`";
+			if (!allContacts)
+				queryStr.append(" AND `jid` = :jid");
+			if (!allAccounts)
+				queryStr.append(" AND `acc_id` = :acc_id");
+			if (type == QueryDateBackward)
+				queryStr.append(" AND `date` < :date");
+			else if (type == QueryDateForward)
+				queryStr.append(" AND `date` >= :date");
+			if (type == QueryLatest || type == QueryDateBackward)
+				queryStr.append(" ORDER BY `date` DESC");
+			else
+				queryStr.append(" ORDER BY `date` ASC");
+			queryStr.append(" LIMIT :start, :cnt;");
+			break;
+		case QueryRowCount:
+		case QueryRowCountBefore:
+			queryStr = "SELECT count(*) AS `count`"
+				" FROM `events`, `contacts`"
+				" WHERE `contacts`.`id` = `contact_id`";
+			if (!allContacts)
+				queryStr.append(" AND `jid` = :jid");
+			if (!allAccounts)
+				queryStr.append(" AND `acc_id` = :acc_id");
+			if (type == QueryRowCountBefore)
+				queryStr.append(" AND `date` < :date");
+			queryStr.append(";");
+			break;
+		case QueryJidRowId:
+			queryStr = "SELECT `id` FROM `contacts` WHERE `jid` = :jid AND acc_id = :acc_id;";
+			break;
+		case QueryFindText:
+			queryStr = "SELECT `acc_id`, `events`.`id`, `jid`, `date`, `events`.`type`, `direction`, `subject`, `m_text`, `lang`, `extra_data`"
+				" FROM `events`, `contacts`"
+				" WHERE `contacts`.`id` = `contact_id`";
+			if (!allContacts)
+				queryStr.append(" AND `jid` = :jid");
+			if (!allAccounts)
+				queryStr.append(" AND `acc_id` = :acc_id");
+			queryStr.append(" AND `m_text` IS NOT NULL");
+			queryStr.append(" ORDER BY `date`;");
+			break;
+		case QueryInsertEvent:
+			queryStr = "INSERT INTO `events` ("
+				"`contact_id`, `resource`, `date`, `type`, `direction`, `subject`, `m_text`, `lang`, `extra_data`"
+				") VALUES ("
+				":contact_id, :resource, :date, :type, :direction, :subject, :m_text, :lang, :extra_data"
+				");";
+			break;
+	}
+	return queryStr;
+}
+
+uint qHash(const QueryProperty &struc)
+{
+	uint res = struc.type;
+	res <<= 8;
+	res |=  struc.allAccounts;
+	res <<= 8;
+	res |=  struc.allContacts;
+	return res;
+}
--- git.orig/src/edbsqlite.h
+++ git/src/edbsqlite.h
@@ -0,0 +1,165 @@
+/*
+ * edbsqlite.h
+ * Copyright (C) 2011   Aleksey Andreev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef EDBSQLITE_H
+#define EDBSQLITE_H
+
+#include <QObject>
+#include <QDateTime>
+#include <QTimer>
+#include <QSqlDatabase>
+#include <QSqlQuery>
+#include <QSqlRecord>
+#include <QHash>
+#include <QVariant>
+
+#include "eventdb.h"
+#include "xmpp_jid.h"
+#include "psievent.h"
+#include "edbflatfile.h"
+
+enum QueryType {
+	QueryContactsList,
+	QueryLatest, QueryOldest,
+	QueryDateForward, QueryDateBackward,
+	QueryFindText,
+	QueryRowCount, QueryRowCountBefore,
+	QueryJidRowId,
+	QueryInsertEvent
+};
+
+struct QueryProperty
+{
+	QueryType type;
+	bool      allAccounts;
+	bool      allContacts;
+	QueryProperty(QueryType tp, bool allAcc, bool allCont) {
+		type        = tp;
+		allAccounts = allAcc;
+		allContacts = allCont;
+	}
+	bool operator==(const QueryProperty &other) const {
+		return (type == other.type && allAccounts == other.allAccounts && allContacts == other.allContacts);
+	}
+};
+uint qHash(const QueryProperty &struc);
+
+class EDBSqLite : public EDB
+{
+	Q_OBJECT
+
+	class QueryStorage;
+	class PreparedQuery : private QSqlQuery
+	{
+	public:
+		void bindValue(const QString &placeholder, const QVariant &val) { QSqlQuery::bindValue(placeholder, val); }
+		bool exec() { return QSqlQuery::exec(); }
+		bool first() { return QSqlQuery::first(); }
+		bool next() { return QSqlQuery::next(); }
+		QSqlRecord record() const { return QSqlQuery::record(); }
+		void freeResult() { QSqlQuery::finish(); }
+	private:
+		friend class QueryStorage;
+		PreparedQuery(QSqlDatabase db);
+		~PreparedQuery() {}
+	};
+	//--------
+	class QueryStorage
+	{
+	public:
+		QueryStorage();
+		~QueryStorage();
+		PreparedQuery *getPreparedQuery(QueryType type, bool allAccounts, bool allContacts);
+	private:
+		QString getQueryString(QueryType type, bool allAccounts, bool allContacts);
+	private:
+		QHash<QueryProperty, PreparedQuery *> queryList;
+	};
+	//--------
+
+public:
+	enum InsertMode { Normal, Import };
+
+	EDBSqLite(PsiCon *psi);
+	~EDBSqLite();
+	bool init();
+
+	int features() const;
+	int get(const QString &accId, const XMPP::Jid &jid, const QDateTime date, int direction, int start, int len);
+	int find(const QString &accId, const QString &str, const XMPP::Jid &jid, const QDateTime date, int direction);
+	int append(const QString &accId, const XMPP::Jid &jid, const PsiEvent::Ptr &e, int type);
+	int erase(const QString &accId, const XMPP::Jid &jid);
+	QList<ContactItem> contacts(const QString &accId, int type);
+	quint64 eventsCount(const QString &accId, const XMPP::Jid &jid);
+	QString getStorageParam(const QString &key);
+	void setStorageParam(const QString &key, const QString &val);
+
+	void setInsertingMode(InsertMode mode);
+	void setMirror(EDBFlatFile *mirr);
+	EDBFlatFile *mirror() const;
+
+private:
+	enum { NotActive, NotCommited, Commited };
+	struct item_query_req
+	{
+		QString accId;
+		XMPP::Jid j;
+		int jidType;
+		int type; // 0 = latest, 1 = oldest, 2 = random, 3 = write
+		int start;
+		int len;
+		int dir;
+		int id;
+		QDateTime date;
+		QString findStr;
+		PsiEvent::Ptr event;
+
+		enum Type { Type_get, Type_append, Type_find, Type_erase };
+	};
+	int  status;
+	unsigned int transactionsCounter;
+	QDateTime lastCommitTime;
+	unsigned int maxUncommitedRecs;
+	int maxUncommitedSecs;
+	unsigned int commitByTimeoutSecs;
+	QTimer *commitTimer;
+	EDBFlatFile *mirror_;
+	QList<item_query_req*> rlist;
+	QHash<QString, qint64>jidsCache;
+	QueryStorage queryes;
+
+private:
+	bool appendEvent(const QString &accId, const XMPP::Jid &, const PsiEvent::Ptr &, int);
+	PsiEvent::Ptr getEvent(const QSqlRecord &record);
+	qint64 ensureJidRowId(const QString &accId, const XMPP::Jid &jid, int type);
+	int  rowCount(const QString &accId, const XMPP::Jid &jid, const QDateTime before);
+	bool eraseHistory(const QString &accId, const XMPP::Jid &);
+	bool transaction(bool now);
+	bool rollback();
+	void startAutocommitTimer();
+	void stopAutocommitTimer();
+	bool importExecute();
+
+private slots:
+	void performRequests();
+	bool commit();
+};
+
+#endif // EDBSQLITE_H
--- git.orig/src/historyimp.cpp
+++ git/src/historyimp.cpp
@@ -0,0 +1,304 @@
+/*
+ * historyimp.cpp
+ * Copyright (C) 2011   Aleksey Andreev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include <QDir>
+#include <QTimer>
+#include <QMessageBox>
+#include <QLayout>
+
+#include "historyimp.h"
+#include "edbsqlite.h"
+#include "edbflatfile.h"
+#include "applicationinfo.h"
+#include "psicontactlist.h"
+#include "psiaccount.h"
+#include "psicontact.h"
+
+HistoryImport::HistoryImport(PsiCon *psi) : QObject(),
+	psi_(psi),
+	srcEdb(NULL),
+	dstEdb(NULL),
+	hErase(NULL),
+	hRead(NULL),
+	hWrite(NULL),
+	active(false),
+	result_(ResultNone),
+	recordsCount(0),
+	dlg(NULL)
+{
+}
+
+HistoryImport::~HistoryImport()
+{
+	clear();
+}
+
+bool HistoryImport::isNeeded()
+{
+	bool res = false;
+	EDBSqLite *stor = static_cast<EDBSqLite *>(psi_->edb());
+	if (!stor->getStorageParam("import_start").isEmpty()) {
+		EDB *src = stor->mirror();
+		if (!src)
+			src = new EDBFlatFile(psi_);
+		//if (sou && sou->eventsCount(QString(), XMPP::Jid()) != 0)
+		if (!src->contacts(QString(), EDB::Contact).isEmpty())
+			res = true;
+		else
+			stor->setStorageParam("import_start", QString());
+		if (src != stor->mirror())
+			delete src;
+	}
+	return res;
+}
+
+void HistoryImport::clear()
+{
+	if (dstEdb) {
+		((EDBSqLite *)dstEdb)->setInsertingMode(EDBSqLite::Normal);
+		((EDBSqLite *)dstEdb)->setMirror(new EDBFlatFile(psi_));
+	}
+	if (hErase) {
+		delete hErase;
+		hErase = NULL;
+	}
+	if (hRead) {
+		delete hRead;
+		hRead = NULL;
+	}
+	if (srcEdb) {
+		delete srcEdb;
+		srcEdb = NULL;
+	}
+	if (hWrite) {
+		delete hWrite;
+		hWrite = NULL;
+	}
+	if (dlg) {
+		delete dlg;
+		dlg = NULL;
+	}
+}
+
+int HistoryImport::exec()
+{
+	active = true;
+
+	dstEdb = psi_->edb();
+	((EDBSqLite *)dstEdb)->setMirror(NULL);
+	((EDBSqLite *)dstEdb)->setInsertingMode(EDBSqLite::Import);
+
+	dstEdb->setStorageParam("import_start", "yes");
+
+	if (!srcEdb)
+		srcEdb = new EDBFlatFile(psi_);
+
+	foreach (const EDB::ContactItem &ci, srcEdb->contacts(QString(), EDB::Contact)) {
+		const XMPP::Jid &jid = ci.jid;
+		QStringList accIds;
+		foreach (PsiAccount *acc, psi_->contactList()->accounts()) {
+			foreach (PsiContact *contact, acc->contactList()) {
+				if (contact->jid() == jid)
+					accIds.append(acc->id());
+			}
+		}
+		if (accIds.isEmpty()) {
+			PsiAccount *pa = psi_->contactList()->defaultAccount();
+			if (pa)
+				accIds.append(pa->id());
+			else
+				accIds.append(psi_->contactList()->accounts().first()->id());
+		}
+		importList.append(ImportItem(accIds, jid));
+	}
+
+	if (importList.isEmpty())
+		stop(ResultNormal);
+	else
+		showDialog();
+
+	return result_;
+}
+
+void HistoryImport::stop(int reason)
+{
+	stopTime = QDateTime::currentDateTime();
+	result_ = reason;
+	if (reason == ResultNormal) {
+		dstEdb->setStorageParam("import_start", QString());
+		int sec = importDuration();
+		int min = sec / 60;
+		sec = sec % 60;
+		qWarning(QString("Import is finished. Duration is %1 min. %2 sec.").arg(min).arg(sec).toLatin1());
+	}
+	else if (reason == ResultCancel)
+		qWarning("Import canceled");
+	else
+		qWarning("Import error");
+
+	active = false;
+	emit finished(reason);
+}
+
+int HistoryImport::importDuration()
+{
+	return startTime.secsTo(stopTime);
+}
+
+void HistoryImport::readFromFiles()
+{
+	if (!active)
+		return;
+	if (hWrite != NULL) {
+		if (!hWrite->writeSuccess()) {
+			stop(ResultError); // Write error
+			return;
+		}
+	}
+	else if (hErase != NULL && !hErase->writeSuccess()) {
+		stop(ResultError);
+		return;
+	}
+	if (importList.isEmpty()) {
+		stop(ResultNormal);
+		return;
+	}
+	if (hRead == NULL) {
+		hRead = new EDBHandle(srcEdb);
+		connect(hRead, SIGNAL(finished()), this, SLOT(writeToSqlite()));
+	}
+
+	const ImportItem &item = importList.first();
+	int start = item.startNum;
+	if (start == 0)
+		qWarning(QString("Importing %1").arg(JIDUtil::toString(item.jid, true)).toLatin1());
+	--recordsCount;
+	if (dlg && (recordsCount % 100) == 0)
+		progressBar->setValue(progressBar->value() + 1);
+	hRead->get(item.accIds.first(), item.jid, QDateTime(), EDB::Forward, start, 1);
+}
+
+void HistoryImport::writeToSqlite()
+{
+	if (!active)
+		return;
+	const EDBResult r = hRead->result();
+	if (hRead->lastRequestType() != EDBHandle::Read || r.size() > 1) {
+		stop(ResultError);
+		return;
+	}
+	if (r.isEmpty()) {
+		importList.first().accIds.removeFirst();
+		if (importList.first().accIds.isEmpty())
+			importList.removeFirst();
+		QTimer::singleShot(0, this, SLOT(readFromFiles()));
+		return;
+	}
+	if (hWrite == NULL) {
+		hWrite = new EDBHandle(dstEdb);
+		connect(hWrite, SIGNAL(finished()), this, SLOT(readFromFiles()));
+	}
+	EDBItemPtr it = r.first();
+	ImportItem &item = importList.first();
+	hWrite->append(item.accIds.first(), item.jid, it->event(), EDB::Contact);
+	item.startNum += 1;
+}
+
+void HistoryImport::showDialog()
+{
+	dlg = new QDialog();
+	dlg->setModal(true);
+	dlg->setWindowTitle(tr("Psi+ Import history"));
+	QVBoxLayout *mainLayout = new QVBoxLayout(dlg);
+	stackedWidget = new QStackedWidget(dlg);
+
+	QWidget *page1 = new QWidget();
+	QGridLayout *page1Layout = new QGridLayout(page1);
+	QLabel *lbMessage = new QLabel(page1);
+	lbMessage->setWordWrap(true);
+	lbMessage->setText(tr("Found %1 files for import.\nContinue?").arg(importList.size()));
+	page1Layout->addWidget(lbMessage, 0, 0, 1, 1);
+	stackedWidget->addWidget(page1);
+
+	QWidget *page2 = new QWidget();
+	QHBoxLayout *page2Layout = new QHBoxLayout(page2);
+	QGridLayout *page2GridLayout = new QGridLayout();
+	page2GridLayout->addWidget(new QLabel(tr("Status:"), page2), 0, 0, 1, 1);
+	lbStatus = new QLabel(page2);
+	page2GridLayout->addWidget(lbStatus, 0, 1, 1, 1);
+	page2GridLayout->addWidget(new QLabel(tr("Progress:"), page2), 1, 0, 1, 1);
+	progressBar = new QProgressBar(page2);
+	progressBar->setMaximum(1);
+	progressBar->setValue(0);
+	page2GridLayout->addWidget(progressBar, 1, 1, 1, 1);
+	page2Layout->addLayout(page2GridLayout);
+	stackedWidget->addWidget(page2);
+
+	mainLayout->addWidget(stackedWidget);
+	QHBoxLayout *buttonsLayout = new QHBoxLayout();
+	QSpacerItem *buttonsSpacer = new QSpacerItem(0, 0, QSizePolicy::Expanding, QSizePolicy::Minimum);
+	buttonsLayout->addItem(buttonsSpacer);
+	btnOk = new QPushButton(dlg);
+	connect(btnOk, SIGNAL(clicked()), this, SLOT(start()));
+	btnOk->setText(tr("Ok"));
+	buttonsLayout->addWidget(btnOk);
+	QPushButton *btnCancel = new QPushButton(dlg);
+	connect(btnCancel, SIGNAL(clicked()), this, SLOT(cancel()));
+	btnCancel->setText(tr("Exit"));
+	buttonsLayout->addWidget(btnCancel);
+	mainLayout->addLayout(buttonsLayout);
+
+	dlg->adjustSize();
+	dlg->exec();
+}
+
+void HistoryImport::start()
+{
+	qWarning("Import start");
+	startTime = QDateTime::currentDateTime();
+	btnOk->setEnabled(false);
+	stackedWidget->setCurrentIndex(1);
+
+	lbStatus->setText(tr("Counting records"));
+	qApp->processEvents();
+	recordsCount = srcEdb->eventsCount(QString(), XMPP::Jid());
+	int max = recordsCount / 100;
+	if ((recordsCount % 100) != 0)
+		++max;
+	progressBar->setMaximum(max);
+	progressBar->setValue(0);
+
+	lbStatus->setText(tr("Import"));
+	hErase = new EDBHandle(dstEdb);
+	connect(hErase, SIGNAL(finished()), this, SLOT(readFromFiles()));
+	hErase->erase(QString(), QString());
+	while (active)
+		qApp->processEvents();
+	if (result_ == ResultNormal)
+		dlg->accept();
+	else
+		lbStatus->setText(tr("Error"));
+}
+
+void HistoryImport::cancel()
+{
+	stop();
+	dlg->reject();
+}
--- git.orig/src/historyimp.h
+++ git/src/historyimp.h
@@ -0,0 +1,91 @@
+/*
+ * historyimp.h
+ * Copyright (C) 2011   Aleksey Andreev
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef HISTORYIMP_H
+#define HISTORYIMP_H
+
+#include <QObject>
+#include <QDialog>
+#include <QLabel>
+#include <QProgressBar>
+#include <QStackedWidget>
+#include <QPushButton>
+
+#include "xmpp/jid/jid.h"
+#include "jidutil.h"
+#include "psicon.h"
+#include "eventdb.h"
+
+struct ImportItem
+{
+	QStringList   accIds;
+	XMPP::Jid     jid;
+	int           startNum;
+	ImportItem(const QStringList &ids, const XMPP::Jid &j) { accIds = ids; jid = j; startNum = 0; }
+};
+
+class HistoryImport : public QObject
+{
+	Q_OBJECT
+
+public:
+	enum {ResultNone, ResultNormal, ResultCancel, ResultError};
+	HistoryImport(PsiCon *psi);
+	~HistoryImport();
+	bool isNeeded();
+	int exec();
+	int importDuration();
+
+private:
+	PsiCon *psi_;
+	QList<ImportItem> importList;
+	EDB *srcEdb;
+	EDB *dstEdb;
+	EDBHandle *hErase;
+	EDBHandle *hRead;
+	EDBHandle *hWrite;
+	QDateTime startTime;
+	QDateTime stopTime;
+	bool active;
+	int result_;
+	quint64 recordsCount;
+	QDialog *dlg;
+	QLabel *lbStatus;
+	QProgressBar *progressBar;
+	QStackedWidget *stackedWidget;
+	QPushButton *btnOk;
+
+private:
+	void clear();
+	void showDialog();
+
+private slots:
+	void readFromFiles();
+	void writeToSqlite();
+	void start();
+	void stop(int reason = ResultCancel);
+	void cancel();
+
+signals:
+	void finished(int);
+
+};
+
+#endif
--- git.orig/src/messageview.cpp
+++ git/src/messageview.cpp
@@ -32,7 +32,8 @@ MessageView::MessageView(Type t) :
     _flags(0),
 	_status(0),
 	_statusPriority(0),
-	_dateTime(QDateTime::currentDateTime())
+	_dateTime(QDateTime::currentDateTime()),
+	_carbon(XMPP::Message::NoCarbon)
 {
 }
 
--- git.orig/src/messageview.h
+++ git/src/messageview.h
@@ -24,6 +24,8 @@
 #include <QDateTime>
 #include <QVariantMap>
 
+#include "xmpp_message.h"
+
 #if QT_VERSION < QT_VERSION_CHECK(5,7,0)
 # define SET_QFLAG(flags, flag, state) if (state) flags |= flag; else flags &= ~flag
 #else
@@ -123,6 +125,8 @@ public:
 	inline QMap<QString, QString> urls() const { return _urls; }
 	inline void setReplaceId(const QString &id) { _replaceId = id; }
 	inline const QString &replaceId() const { return _replaceId; }
+	inline void setCarbonDirection(XMPP::Message::CarbonDir c) {_carbon = c; }
+	inline XMPP::Message::CarbonDir carbonDirection() const { return _carbon; }
 
 	QVariantMap toVariantMap(bool isMuc, bool formatted = false) const;
 
@@ -139,6 +143,7 @@ private:
 	QDateTime _dateTime;
 	QMap<QString, QString> _urls;
 	QString _replaceId;
+	XMPP::Message::CarbonDir _carbon;
 };
 
 Q_DECLARE_OPERATORS_FOR_FLAGS(MessageView::Flags)
--- git.orig/src/psichatdlg.cpp
+++ git/src/psichatdlg.cpp
@@ -925,7 +925,7 @@ bool PsiChatDlg::isEncryptionEnabled() c
 
 void PsiChatDlg::appendSysMsg(const QString &str)
 {
-	chatView()->dispatchMessage(MessageView::fromHtml(str, MessageView::System));
+	dispatchMessage(MessageView::fromHtml(str, MessageView::System));
 }
 
 ChatView* PsiChatDlg::chatView() const
--- git.orig/src/psicon.cpp
+++ git/src/psicon.cpp
@@ -62,7 +62,7 @@
 #ifdef HAVE_PGPUTIL
 #include "pgputil.h"
 #endif
-#include "edbflatfile.h"
+#include "edbsqlite.h"
 #include "proxy.h"
 #ifdef PSIMNG
 #include "psimng.h"
@@ -359,8 +359,7 @@ PsiCon::PsiCon()
 	d->ftwin = 0;
 #endif
 
-	d->edb = new EDBFlatFile(this);
-
+	d->edb = 0;
 	d->s5bServer = 0;
 	d->tuneManager = 0;
 	d->autoUpdater = 0;
@@ -381,7 +380,8 @@ PsiCon::~PsiCon()
 
 	delete d->autoUpdater;
 	delete d->actionList;
-	delete d->edb;
+	if (d->edb)
+		delete d->edb;
 	delete d->defaultMenuBar;
 	delete d->tabManager;
 	delete d->popupManager;
@@ -656,6 +656,12 @@ bool PsiCon::init()
 
 	checkAccountsEmpty();
 
+	// Import for SQLite history
+	EDBSqLite *edb = new EDBSqLite(this);
+	d->edb = edb;
+	if (!edb->init())
+		return false;
+
 	// try autologin if needed
 	foreach(PsiAccount* account, d->contactList->accounts()) {
 		account->autoLogin();
--- git.orig/src/src.pri
+++ git/src/src.pri
@@ -1,4 +1,4 @@
-QT += xml network
+QT += xml network sql
 
 greaterThan(QT_MAJOR_VERSION, 4) {
   QT += widgets multimedia concurrent
@@ -156,7 +156,9 @@ HEADERS += \
 	$$PWD/translationmanager.h \
 	$$PWD/eventdb.h \
 	$$PWD/edbflatfile.h \
+	$$PWD/edbsqlite.h \
 	$$PWD/historydlg.h \
+	$$PWD/historyimp.h \
 	$$PWD/historycontactlistmodel.h \
 	$$PWD/tipdlg.h \
 	$$PWD/searchdlg.h \
@@ -295,7 +297,9 @@ SOURCES += \
 	$$PWD/translationmanager.cpp \
 	$$PWD/eventdb.cpp \
 	$$PWD/edbflatfile.cpp \
+	$$PWD/edbsqlite.cpp \
 	$$PWD/historydlg.cpp \
+	$$PWD/historyimp.cpp \
 	$$PWD/historycontactlistmodel.cpp \
 	$$PWD/searchdlg.cpp \
 	$$PWD/registrationdlg.cpp \
--- git.orig/themes/chatview/psi/adapter.js
+++ git/themes/chatview/psi/adapter.js
@@ -271,7 +271,11 @@ function psiThemeAdapter(chat) {
                             }
                             if (!template) {
                                 data.nextOfGroup = false; //can't group w/o template
-                                template = data.local?shared.templates.sentMessage:shared.templates.receivedMessage;
+								if (data.spooled) {
+									template = shared.templates.spooledMessage;
+								} else {
+									template = data.local?shared.templates.sentMessage:shared.templates.receivedMessage;
+								}
                             }
                             break;
                         case "join":
--- git.orig/themes/chatview/psi/classic/index.html
+++ git/themes/chatview/psi/classic/index.html
@@ -80,7 +80,9 @@ function startPsiTheme(shared) {
             receivedMessage: shared.isMuc?
                 "<div class='msg'>%icon%<span style='color:%nickcolor%'>[%time%] %sender%</span> %alertedmessage%</div>"
                 : null,
-            spooledMessage: "<div class='infmsg'>%icon%[%time%] %sender% %message%</div>",
+            spooledMessage: shared.isMuc?
+                "<div class='usertext'>%icon%<span style='color:%nickcolor%'>[%time%] %sender%</span> %message%</div>"
+                : "<div class='usertext'>%icon%<span class='%sentrec%'>[%time%] %sender%</span> %message%</div>",
             sys: "<div class='infmsg'>%icon%%message%</div>",
             sysMessage: "<div class='infmsg'>%icon%[%time%] *** %message%</div>",
             sysMessageUT: "<div class='infmsg'>%icon%[%time%] *** %message%: <span class='usertext'>%usertext%</span></div>",
@@ -104,7 +106,7 @@ function startPsiTheme(shared) {
             }
             if (shared.cdata.mtype == "message") {
                 var template = shared.cdata.emote && shared.templates.messageNC ||
-                    (shared.cdata.spooled && shared.templates.message || null);
+                    (shared.cdata.spooled && shared.templates.spooledMessage || null);
                 if (template) {
                     shared.appendHtml(template.toString(), shared.cdata.local?true:null);
                     return false;
@@ -127,8 +129,7 @@ function startPsiTheme(shared) {
                     shared.cdata.message+"</span>":shared.cdata.message;
                 return shared.cdata.id? util.replaceableMessage(shared.isMuc, shared.cdata.local, shared.cdata.sender, shared.cdata.id, msg) : msg;
             },
-            sentrec : function() {return shared.cdata.spooled?"infmsg":
-                (shared.cdata.local?"sent":"received");},
+            sentrec : function() {return shared.cdata.local?"sent":"received";},
             nickcolor : function() {
                 return util.nickColor(shared.cdata.sender);
             },
@@ -137,6 +138,10 @@ function startPsiTheme(shared) {
                 if (useMessageIcons) {
                     switch (shared.cdata.mtype) {
                         case "message":
+                            if (shared.cdata.spooled) {
+                                icon = "psi/history";
+                                break;
+                            }
                             icon = shared.cdata.local?(shared.cdata.awaitingReceipt?
                                 "psi/notification_chat_send":"psi/notification_chat_delivery_ok")
                                 : "psi/notification_chat_receive";
