diff --git a/iris b/iris
--- a/iris
+++ b/iris
@@ -1 +1 @@
-Subproject commit 230575f0d2ad196840ddc785049be564e99b24aa
+Subproject commit 230575f0d2ad196840ddc785049be564e99b24aa-dirty
diff --git a/src/ahcservermanager.cpp b/src/ahcservermanager.cpp
index c690180..6c44922 100644
--- a/src/ahcservermanager.cpp
+++ b/src/ahcservermanager.cpp
@@ -87,9 +87,8 @@ bool JT_AHCServer::commandListQuery(const QDomElement& e)
 		}
 		else if (q.attribute("xmlns") == "http://jabber.org/protocol/disco#info" && q.attribute("node") == AHC_NS) {
 			QDomElement iq = createIQ(doc(), "result", e.attribute("from"), e.attribute("id"));
-			QDomElement query = doc()->createElement("query");
-			query.setAttribute("xmlns", "http://jabber.org/protocol/disco#info");
-			iq.appendChild(query);
+			DiscoItem item;
+			QDomElement query = query.appendChild(item.toDiscoInfoResult(doc())).toElement();
 			send(iq);
 			return true;
 		}
@@ -104,25 +103,11 @@ bool JT_AHCServer::commandListQuery(const QDomElement& e)
 		}
 		else if (q.attribute("xmlns") == "http://jabber.org/protocol/disco#info" && manager_->hasServer(q.attribute("node"), Jid(e.attribute("from")))) {
 			QDomElement iq = createIQ(doc(), "result", e.attribute("from"), e.attribute("id"));
-			QDomElement query = doc()->createElement("query");
-			query.setAttribute("xmlns", "http://jabber.org/protocol/disco#info");
-			query.setAttribute("node",q.attribute("node"));
-			iq.appendChild(query);
-
-			QDomElement identity;
-			identity = doc()->createElement("identity");
-			identity.setAttribute("category", "automation");
-			identity.setAttribute("type", "command-node");
-			query.appendChild(identity);
-
-			QDomElement feature;
-			feature = doc()->createElement("feature");
-			feature.setAttribute("var", AHC_NS);
-			query.appendChild(feature);
-
-			feature = doc()->createElement("feature");
-			feature.setAttribute("var", "jabber:x:data");
-			query.appendChild(feature);
+			DiscoItem item;
+			item.setNode(q.attribute("node"));
+			item.setIdentities(XMPP::DiscoItem::Identity("automation", "command-node"));
+			item.setFeatures(Features(QStringList() << AHC_NS << "jabber:x:data"));
+			QDomElement query = query.appendChild(item.toDiscoInfoResult(doc())).toElement();
 
 			send(iq);
 			return true;
diff --git a/src/applicationinfo.cpp b/src/applicationinfo.cpp
index 45346a7..456fc1f 100644
--- a/src/applicationinfo.cpp
+++ b/src/applicationinfo.cpp
@@ -46,7 +46,7 @@
 #define PROG_VERSION PSI_VERSION
 //#define PROG_VERSION "0.15-dev" " (" __DATE__ ")" //CVS Builds are dated
 //#define PROG_VERSION "0.15";
-#define PROG_CAPS_NODE "http://psi-im.org/caps"
+#define PROG_CAPS_NODE "http://psi-im.org"
 #define PROG_CAPS_VERSION "caps-b75d8d2b25"
 #define PROG_IPC_NAME "org.psi-im.Psi"	// must not contain '\\' character on Windows
 #define PROG_OPTIONS_NS "http://psi-im.org/options"
diff --git a/src/capabilities/capabilities.pri b/src/capabilities/capabilities.pri
deleted file mode 100644
index bc9c29f..0000000
--- a/src/capabilities/capabilities.pri
+++ /dev/null
@@ -1,12 +0,0 @@
-INCLUDEPATH *= $$PWD
-DEPENDPATH *= $$PWD
-
-HEADERS += \
-	$$PWD/capsspec.h \
-	$$PWD/capsregistry.h \
-	$$PWD/capsmanager.h
-
-SOURCES += \
-	$$PWD/capsspec.cpp \
-	$$PWD/capsregistry.cpp \
-	$$PWD/capsmanager.cpp
diff --git a/src/capabilities/capsmanager.cpp b/src/capabilities/capsmanager.cpp
deleted file mode 100755
index 45ebf83..0000000
--- a/src/capabilities/capsmanager.cpp
+++ /dev/null
@@ -1,290 +0,0 @@
-/*
- * capsmanager.cpp
- * Copyright (C) 2006  Remko Troncon
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- */
-
-// TODO:
-//  - Fallback on another jid if a disco request should fail. This can be
-//    done by keeping a second list of candidate jids to query
-//  - Implement Server Optimization support (Section 5).
-//  - Implement consistency checking (Section 8).
-
-
-#include <QString>
-#include <QStringList>
-#include <QTimer>
-#include <QPair>
-#include <QtDebug>
-
-#include "capsregistry.h"
-#include "capsmanager.h"
-
-
-//#define REQUEST_TIMEOUT 3000
-
-using namespace XMPP;
-
-
-/**
- * \class CapsManager
- * \brief A class managing all the capabilities of JIDs and their
- * clients.
- */
-
-/**
- * \brief Default constructor.
- */
-CapsManager::CapsManager(const Jid& jid, CapsRegistry* registry, Protocol::DiscoInfoQuerier* discoInfoQuerier) : jid_(jid), registry_(registry), discoInfoQuerier_(discoInfoQuerier), isEnabled_(true)
-{
-	connect(registry_,SIGNAL(registered(const CapsSpec&)),SLOT(capsRegistered(const CapsSpec&)));
-	connect(discoInfoQuerier_, SIGNAL(getDiscoInfo_success(const XMPP::Jid&, const QString&, const XMPP::DiscoItem&)), SLOT(getDiscoInfo_success(const XMPP::Jid&, const QString&, const XMPP::DiscoItem&)));
-	connect(discoInfoQuerier_, SIGNAL(getDiscoInfo_error(const XMPP::Jid&, const QString&, int, const QString&)), SLOT(getDiscoInfo_error(const XMPP::Jid&, const QString&, int, const QString&)));
-}
-
-CapsManager::~CapsManager()
-{
-	delete discoInfoQuerier_;
-}
-
-/**
- * \brief Checks whether the caps manager is enabled (and does lookups).
- */
-bool CapsManager::isEnabled()
-{
-	return isEnabled_;
-}
-
-/**
- * \brief Enables or disables the caps manager.
- */
-void CapsManager::setEnabled(bool b)
-{
-	isEnabled_ = b;
-}
-
-/**
- * \brief Registers new incoming capabilities information of a JID.
- * If the features of the entity are unknown, discovery requests are sent to
- * retrieve the information.
- *
- * @param jid The entity's JID
- * @param node The entity's caps node
- * @param ver The entity's caps version
- * @param ext The entity's caps extensions
- */
-void CapsManager::updateCaps(const Jid& jid, const QString& node, const QString& ver, const QString& ext)
-{
-	if (jid.compare(jid_,false))
-		return;
-
-	CapsSpec c(node,ver,ext);
-	CapsSpecs caps = c.flatten();
-	if (capsSpecs_[jid.full()] != c) {
-		//qDebug() << QString("caps.cpp: Updating caps for %1 (node=%2,ver=%3,ext=%4)").arg(QString(jid.full()).replace('%',"%%")).arg(node).arg(ver).arg(ext);
-
-		// Unregister from all old caps nodes
-		CapsSpecs old_caps = capsSpecs_[jid.full()].flatten();
-		foreach(CapsSpec s, old_caps) {
-			if (s != CapsSpec()) {
-				capsJids_[s].removeAll(jid.full());
-			}
-		}
-
-		if (!node.isEmpty() && !ver.isEmpty()) {
-			// Register with all new caps nodes
-			capsSpecs_[jid.full()] = c;
-			foreach(CapsSpec s, caps) {
-				if (!capsJids_[s].contains(jid.full())) {
-					capsJids_[s].push_back(jid.full());
-				}
-			}
-
-			emit capsChanged(jid);
-
-			// Register new caps and check if we need to discover features
-			if (isEnabled()) {
-				foreach(CapsSpec s, caps) {
-					if (!registry_->isRegistered(s) && capsJids_[s].count() == 1) {
-						//qDebug() << QString("caps.cpp: Sending disco request to %1, node=%2").arg(QString(jid.full()).replace('%',"%%")).arg(node + "#" + s.extensions());
-						discoInfoQuerier_->getDiscoInfo(jid,node + '#' + s.extensions());
-					}
-				}
-			}
-		}
-		else {
-			// Remove all caps specifications
-			qWarning() << QString("caps.cpp: Illegal caps info from %1: node=%2, ver=%3").arg(QString(jid.full()).replace('%',"%%")).arg(node).arg(ver);
-			capsSpecs_.remove(jid.full());
-		}
-	}
-	else {
-		// Add to the list of jids
-		foreach(CapsSpec s, caps) {
-			capsJids_[s].push_back(jid.full());
-		}
-	}
-}
-
-/**
- * \brief Removes all feature information for a given JID.
- *
- * @param jid The entity's JID
- */
-void CapsManager::disableCaps(const Jid& jid)
-{
-	//qDebug() << QString("caps.cpp: Disabling caps for %1.").arg(QString(jid.full()).replace('%',"%%"));
-	if (capsEnabled(jid)) {
-		CapsSpecs cs = capsSpecs_[jid.full()].flatten();
-		foreach(CapsSpec s, cs) {
-			if (s != CapsSpec()) {
-				capsJids_[s].removeAll(jid.full());
-			}
-		}
-		capsSpecs_.remove(jid.full());
-		emit capsChanged(jid);
-	}
-}
-
-/**
- * \brief Called when a reply to disco#info request was received.
- * If the result was succesful, the resulting features are recorded in the
- * features database for the requested node, and all the affected jids are
- * put in the queue for update notification.
- */
-void CapsManager::getDiscoInfo_success(const XMPP::Jid& jid, const QString& node, const XMPP::DiscoItem& item)
-{
-	//qDebug() << QString("caps.cpp: Disco response from %1, node=%2").arg(QString(jid.full()).replace('%',"%%")).arg(node);
-	// Update features
-	bool ok = false;
-	CapsSpec cs(getCapsSpecForNode(jid, node, ok));
-	if (!ok) {
-		return;
-	}
-	registry_->registerCaps(cs,item.identities(),item.features().list());
-}
-
-void CapsManager::getDiscoInfo_error(const XMPP::Jid& jid, const QString& node, int, const QString&)
-{
-	qWarning() << QString("capsmanager.cpp: Disco to '%1' at node '%2' failed.").arg(jid.full()).arg(node);
-}
-
-
-CapsSpec CapsManager::getCapsSpecForNode(const XMPP::Jid& jid, const QString& disco_node, bool& ok) const
-{
-    int hash_index = disco_node.indexOf('#');
-    if (hash_index == -1) {
-		qWarning() << "CapsManager: Node" << disco_node << "invalid";
-		ok = false;
-		return CapsSpec();
-    }
-	QString node = disco_node.left(hash_index);
-	QString ext = disco_node.right(disco_node.length() - hash_index - 1);
-	CapsSpec jid_cs = capsSpecs_[jid.full()];
-	if (jid_cs.node() == node) {
-		ok = true;
-		return CapsSpec(node,jid_cs.version(),ext);
-	}
-	else {
-		ok = false;
-		return CapsSpec();
-	}
-}
-
-/**
- * \brief This slot is called whenever capabilities of a client were discovered.
- * All jids with the corresponding client are updated.
- */
-void CapsManager::capsRegistered(const CapsSpec& cs)
-{
-	// Notify affected jids.
-	foreach(QString s, capsJids_[cs]) {
-		//qDebug() << QString("caps.cpp: Notifying %1.").arg(s.replace('%',"%%"));
-		emit capsChanged(s);
-	}
-}
-
-/**
- * \brief Checks whether a given JID is broadcastingn its entity capabilities.
- */
-bool CapsManager::capsEnabled(const Jid& jid) const
-{
-	return capsSpecs_.contains(jid.full());
-}
-
-
-/**
- * \brief Requests the list of features of a given JID.
- */
-XMPP::Features CapsManager::features(const Jid& jid) const
-{
-	//qDebug() << "caps.cpp: Retrieving features of " << jid.full();
-	QStringList f;
-	if (capsEnabled(jid)) {
-		CapsSpecs cs = capsSpecs_[jid.full()].flatten();
-		foreach(CapsSpec s, cs) {
-			//qDebug() << QString("    %1").arg(registry_->features(s).list().join("\n"));
-			f += registry_->features(s).list();
-		}
-	}
-	return Features(f);
-}
-
-/**
- * \brief Returns the client name of a given jid.
- * \param jid the jid to retrieve the client name of
- */
-QString CapsManager::clientName(const Jid& jid) const
-{
-	if (capsEnabled(jid)) {
-		QString name;
-		CapsSpec cs = capsSpecs_[jid.full()];
-		const DiscoItem::Identities& i = registry_->identities(CapsSpec(cs.node(),cs.version(),cs.version()));
-		if (i.count() > 0) {
-			name = i.first().name;
-		}
-
-		// Try to be intelligent about the name
-		if (name.isEmpty()) {
-			name = cs.node();
-			if (name.startsWith("http://"))
-				name = name.right(name.length() - 7);
-			else if (name.startsWith("https://"))
-				name = name.right(name.length() - 8);
-
-			if (name.startsWith("www."))
-				name = name.right(name.length() - 4);
-
-			int cut_pos = name.indexOf("/");
-			if (cut_pos != -1)
-				name = name.left(cut_pos);
-		}
-
-		return name;
-	}
-	else {
-		return QString();
-	}
-}
-
-/**
- * \brief Returns the client version of a given jid.
- */
-QString CapsManager::clientVersion(const Jid& jid) const
-{
-	return (capsEnabled(jid) ? capsSpecs_[jid.full()].version() : QString());
-}
diff --git a/src/capabilities/capsmanager.h b/src/capabilities/capsmanager.h
deleted file mode 100755
index c779e30..0000000
--- a/src/capabilities/capsmanager.h
+++ /dev/null
@@ -1,83 +0,0 @@
-/*
- * capsmanager.h
- * Copyright (C) 2006  Remko Troncon
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- */
-
-#ifndef CAPSMANAGER_H
-#define CAPSMANAGER_H
-
-#include <QMap>
-#include <QList>
-#include <QString>
-#include <QObject>
-#include <QPointer>
-
-#include "protocol/discoinfoquerier.h"
-#include "capsspec.h"
-#include "capsregistry.h"
-#include "xmpp_features.h"
-
-namespace XMPP {
-	class Jid;
-}
-using namespace XMPP;
-
-class CapsManager : public QObject
-{
-	Q_OBJECT
-
-public:
-	CapsManager(const XMPP::Jid&, CapsRegistry* registry, Protocol::DiscoInfoQuerier* discoInfoQuerier);
-	~CapsManager();
-
-	bool isEnabled();
-	void setEnabled(bool);
-
-	void updateCaps(const Jid& jid, const QString& node, const QString& ver, const QString& ext);
-	void disableCaps(const Jid& jid);
-	bool capsEnabled(const Jid& jid) const;
-	XMPP::Features features(const Jid& jid) const;
-	QString clientName(const Jid& jid) const;
-	QString clientVersion(const Jid& jid) const;
-
-signals:
-	/**
-	 * This signal is emitted when the feature list of a given JID have changed.
-	 */
-	void capsChanged(const Jid& jid);
-
-protected:
-	CapsSpec getCapsSpecForNode(const XMPP::Jid& jid, const QString& disco_node, bool& ok) const;
-
-protected slots:
-	void getDiscoInfo_success(const XMPP::Jid& jid, const QString& node, const XMPP::DiscoItem& item);
-	void getDiscoInfo_error(const XMPP::Jid& jid, const QString& node, int error_code, const QString& error_string);
-
-	void capsRegistered(const CapsSpec&);
-
-private:
-	XMPP::Jid jid_;
-	QPointer<CapsRegistry> registry_;
-	QPointer<Protocol::DiscoInfoQuerier> discoInfoQuerier_;
-	bool isEnabled_;
-	QMap<QString,CapsSpec> capsSpecs_;
-	QMap<CapsSpec,QList<QString> > capsJids_;
-};
-
-
-#endif
diff --git a/src/capabilities/capsregistry.cpp b/src/capabilities/capsregistry.cpp
deleted file mode 100755
index 01db836..0000000
--- a/src/capabilities/capsregistry.cpp
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * capsregistry.cpp
- * Copyright (C) 2006  Remko Troncon
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- */
-
-#include <QCoreApplication>
-#include <QDebug>
-#include <QTextCodec>
-#include <QFile>
-#include <QDomElement>
-
-#include "xmpp_features.h"
-#include "capsregistry.h"
-#include "iodeviceopener.h"
-
-using namespace XMPP;
-
-// -----------------------------------------------------------------------------
-
-CapsRegistry::CapsInfo::CapsInfo()
-{
-	updateLastSeen();
-}
-
-const XMPP::Features& CapsRegistry::CapsInfo::features() const
-{
-	return features_;
-}
-
-const DiscoItem::Identities& CapsRegistry::CapsInfo::identities() const
-{
-	return identities_;
-}
-
-void CapsRegistry::CapsInfo::setIdentities(const DiscoItem::Identities& i)
-{
-	identities_ = i;
-}
-
-void CapsRegistry::CapsInfo::setFeatures(const XMPP::Features& f)
-{
-	features_ = f;
-}
-
-void CapsRegistry::CapsInfo::updateLastSeen()
-{
-	lastSeen_ = QDateTime::currentDateTime();
-}
-
-QDomElement CapsRegistry::CapsInfo::toXml(QDomDocument *doc) const
-{
-	QDomElement info = doc->createElement("info");
-	info.setAttribute("last-seen",lastSeen_.toString(Qt::ISODate));
-
-	// Identities
-	for (DiscoItem::Identities::ConstIterator i = identities_.begin(); i != identities_.end(); ++i) {
-		QDomElement identity = doc->createElement("identity");
-		identity.setAttribute("category",(*i).category);
-		identity.setAttribute("name",(*i).name);
-		identity.setAttribute("type",(*i).type);
-		info.appendChild(identity);
-	}
-
-	// Features
-	foreach(QString f, features_.list()) {
-		QDomElement feature = doc->createElement("feature");
-		feature.setAttribute("node",f);
-		info.appendChild(feature);
-	}
-
-	return info;
-}
-
-void CapsRegistry::CapsInfo::fromXml(const QDomElement& e)
-{
-	if (e.tagName() != "info") {
-		qWarning("caps.cpp: Invalid info element");
-		return;
-	}
-
-	if (!e.attribute("last-seen").isEmpty()) {
-		QDateTime last = QDateTime::fromString(e.attribute("last-seen"),Qt::ISODate);
-		if (last.isValid())
-			lastSeen_ = last;
-		else
-			qWarning("Invalid date in caps registry");
-	}
-
-	for(QDomNode n = e.firstChild(); !n.isNull(); n = n.nextSibling()) {
-		QDomElement i = n.toElement();
-		if(i.isNull()) {
-			qWarning("caps.cpp: Null element");
-			continue;
-		}
-
-		if(i.tagName() == "identity") {
-			DiscoItem::Identity id;
-			id.category = i.attribute("category");
-			id.name = i.attribute("name");
-			id.type = i.attribute("type");
-			identities_ += id;
-		}
-		else if (i.tagName() == "feature") {
-			features_.addFeature(i.attribute("node"));
-		}
-		else {
-			qWarning("caps.cpp: Unknown element");
-		}
-	}
-}
-
-// -----------------------------------------------------------------------------
-/**
- * \class CapsRegistry
- * \brief A singleton class managing the capabilities of clients.
- */
-
-/**
- * \brief Default constructor.
- */
-CapsRegistry::CapsRegistry()
-{
-}
-
-/**
- * \brief Convert all capabilities info to XML.
- */
-void CapsRegistry::save(QIODevice& out)
-{
-	// Generate XML
-	QDomDocument doc;
-	QDomElement capabilities = doc.createElement("capabilities");
-	doc.appendChild(capabilities);
-	QMap<CapsSpec,CapsInfo>::ConstIterator i = capsInfo_.begin();
-	for( ; i != capsInfo_.end(); i++) {
-		QDomElement info = i.value().toXml(&doc);
-		info.setAttribute("node",i.key().node());
-		info.setAttribute("ver",i.key().version());
-		info.setAttribute("ext",i.key().extensions());
-		capabilities.appendChild(info);
-	}
-
-	IODeviceOpener opener(&out, QIODevice::WriteOnly);
-	if (!opener.isOpen()) {
-		qWarning() << "Caps: Unable to open IO device";
-		return;
-	}
-	QTextStream t;
-	t.setDevice(&out);
-	t.setCodec(QTextCodec::codecForName("UTF-8"));
-	t << doc.toString();
-}
-
-/**
- * \brief Sets the file to save the capabilities info to
- */
-void CapsRegistry::load(QIODevice& in)
-{
-	// Load settings
-	QDomDocument doc;
-	IODeviceOpener opener(&in, QIODevice::ReadOnly);
-	if (!opener.isOpen()) {
-		qWarning() << "CapsRegistry: Cannot open input device";
-		return;
-	}
-	if (!doc.setContent(&in)) {
-		qWarning() << "CapsRegistry: Cannnot parse input";
-		return;
-	}
-
-	QDomElement caps = doc.documentElement();
-	if (caps.tagName() != "capabilities") {
-		qWarning("caps.cpp: Invalid capabilities element");
-		return;
-	}
-
-	for(QDomNode n = caps.firstChild(); !n.isNull(); n = n.nextSibling()) {
-		QDomElement i = n.toElement();
-		if(i.isNull()) {
-			qWarning("capsregistry.cpp: Null element");
-			continue;
-		}
-
-		if(i.tagName() == "info") {
-			CapsInfo info;
-			info.fromXml(i);
-			CapsSpec spec(i.attribute("node"),i.attribute("ver"),i.attribute("ext"));
-			capsInfo_[spec] = info;
-			//qDebug() << QString("Read %1 %2 %3").arg(spec.node()).arg(spec.version()).arg(spec.extensions());
-		}
-		else {
-			qWarning("capsregistry.cpp: Unknown element");
-		}
-	}
-}
-
-/**
- * \brief Registers capabilities of a client.
- */
-void CapsRegistry::registerCaps(const CapsSpec& spec,const XMPP::DiscoItem::Identities& identities,const XMPP::Features& features)
-{
-	if (!isRegistered(spec)) {
-		CapsInfo info;
-		info.setIdentities(identities);
-		info.setFeatures(features);
-		capsInfo_[spec] = info;
-		emit registered(spec);
-	}
-}
-
-/**
- * \brief Checks if capabilities have been registered.
- */
-bool CapsRegistry::isRegistered(const CapsSpec& spec) const
-{
-	return capsInfo_.contains(spec);
-}
-
-
-/**
- * \brief Retrieves the features of a given caps spec.
- */
-XMPP::Features CapsRegistry::features(const CapsSpec& spec) const
-{
-	return capsInfo_[spec].features();
-}
-
-/**
- * \brief Retrieves the identities of a given caps spec.
- */
-XMPP::DiscoItem::Identities CapsRegistry::identities(const CapsSpec& spec) const
-{
-	return capsInfo_[spec].identities();
-}
diff --git a/src/capabilities/capsregistry.h b/src/capabilities/capsregistry.h
deleted file mode 100755
index b448796..0000000
--- a/src/capabilities/capsregistry.h
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * capsregistry.h
- * Copyright (C) 2006  Remko Troncon
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- */
-
-#ifndef CAPSREGISTRY_H
-#define CAPSREGISTRY_H
-
-#include <QObject>
-#include <QString>
-#include <QList>
-#include <QMap>
-#include <QDateTime>
-#include <QPair>
-#include <QIODevice>
-
-#include "xmpp_features.h"
-#include "xmpp_discoitem.h"
-
-#include "capsspec.h"
-
-class QDomDocument;
-class QDomElement;
-
-class CapsRegistry : public QObject
-{
-	Q_OBJECT
-
-public:
-	CapsRegistry();
-
-	void registerCaps(const CapsSpec&, const XMPP::DiscoItem::Identities&, const XMPP::Features& features);
-	bool isRegistered(const CapsSpec&) const;
-	XMPP::Features features(const CapsSpec&) const;
-	XMPP::DiscoItem::Identities identities(const CapsSpec&) const;
-
-signals:
-	void registered(const CapsSpec&);
-
-public slots:
-	void load(QIODevice& target);
-	void save(QIODevice& target);
-
-private:
-	class CapsInfo
-	{
-		public:
-			CapsInfo();
-			const XMPP::Features& features() const;
-			const XMPP::DiscoItem::Identities& identities() const;
-
-			void setIdentities(const XMPP::DiscoItem::Identities&);
-			void setFeatures(const XMPP::Features&);
-
-			QDomElement toXml(QDomDocument *) const;
-			void fromXml(const QDomElement&);
-
-		protected:
-			void updateLastSeen();
-
-		private:
-			XMPP::Features features_;
-			XMPP::DiscoItem::Identities identities_;
-			QDateTime lastSeen_;
-	};
-	QMap<CapsSpec,CapsInfo> capsInfo_;
-};
-
-
-#endif
diff --git a/src/capabilities/capsspec.cpp b/src/capabilities/capsspec.cpp
deleted file mode 100755
index 880f8d8..0000000
--- a/src/capabilities/capsspec.cpp
+++ /dev/null
@@ -1,118 +0,0 @@
-/*
- * capsspec.cpp
- * Copyright (C) 2006  Remko Troncon
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- */
-
-#include <QString>
-#include <QStringList>
-
-#include "capsspec.h"
-
-/**
- * \class CapsSpec
- * \brief A class representing an entity capability specification.
- * An entity capability is a combination of a node, a version, and a set of
- * extensions.
- */
-
-/**
- * Default constructor.
- */
-CapsSpec::CapsSpec()
-{
-}
-
-
-/**
- * \brief Basic constructor.
- * @param node the node
- * @param ven the version
- * @param ext the list of extensions (separated by spaces)
- */
-CapsSpec::CapsSpec(const QString& node, const QString& ver, const QString& ext) : node_(node), ver_(ver), ext_(ext)
-{
-}
-
-
-/**
- * \brief Returns the node of the capabilities specification.
- */
-const QString& CapsSpec::node() const
-{
-	return node_;
-}
-
-
-/**
- * \brief Returns the version of the capabilities specification.
- */
-const QString& CapsSpec::version() const
-{
-	return ver_;
-}
-
-
-/**
- * \brief Returns the extensions of the capabilities specification.
- */
-const QString& CapsSpec::extensions() const
-{
-	return ext_;
-}
-
-
-/**
- * \brief Flattens the caps specification into the set of 'simple'
- * specifications.
- * A 'simple' specification is a specification with exactly one extension,
- * or with the version number as the extension.
- *
- * Example: A caps specification with node=http://psi-im.org, version=0.10,
- * and ext='achat vchat' would be expanded into the following list of specs:
- *	node=http://psi-im.org, ver=0.10, ext=0.10
- *	node=http://psi-im.org, ver=0.10, ext=achat
- *	node=http://psi-im.org, ver=0.10, ext=vchat
- */
-CapsSpecs CapsSpec::flatten() const
-{
-	CapsSpecs l;
-	l.append(CapsSpec(node(),version(),version()));
-	QStringList exts(extensions().split(' ',QString::SkipEmptyParts));
-	for (QStringList::ConstIterator i = exts.begin(); i != exts.end(); ++i) {
-		l.append(CapsSpec(node(),version(),*i));
-	}
-	return l;
-}
-
-bool CapsSpec::operator==(const CapsSpec& s) const
-{
-	return (node() == s.node() && version() == s.version() && extensions() == s.extensions());
-}
-
-bool CapsSpec::operator!=(const CapsSpec& s) const
-{
-	return !((*this) == s);
-}
-
-bool CapsSpec::operator<(const CapsSpec& s) const
-{
-	return (node() != s.node() ? node() < s.node() :
-			(version() != s.version() ? version() < s.version() :
-			 extensions() < s.extensions()));
-}
-
diff --git a/src/capabilities/capsspec.h b/src/capabilities/capsspec.h
deleted file mode 100755
index bc8c114..0000000
--- a/src/capabilities/capsspec.h
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * capsspec.h
- * Copyright (C) 2006  Remko Troncon
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
- *
- */
-
-#ifndef CAPSSPEC_H
-#define CAPSSPEC_H
-
-#include <QList>
-#include <QString>
-
-class CapsSpec;
-typedef QList<CapsSpec> CapsSpecs;
-
-class CapsSpec
-{
-	public:
-		CapsSpec();
-		CapsSpec(const QString&, const QString&, const QString&);
-		const QString& node() const;
-		const QString& version() const;
-		const QString& extensions() const;
-		CapsSpecs flatten() const;
-
-		bool operator==(const CapsSpec&) const;
-		bool operator!=(const CapsSpec&) const;
-		bool operator<(const CapsSpec&) const;
-
-	private:
-		QString node_, ver_, ext_;
-};
-
-
-#endif
diff --git a/src/capabilities/unittest/capsmanagertest.cpp b/src/capabilities/unittest/capsmanagertest.cpp
deleted file mode 100644
index 3a95510..0000000
--- a/src/capabilities/unittest/capsmanagertest.cpp
+++ /dev/null
@@ -1,149 +0,0 @@
-/**
- * Copyright (C) 2007, Remko Troncon
- * See COPYING file for the detailed license.
- */
-
-// FIXME: This test suite is far from complete
-
-#include <QObject>
-#include <QtTest/QtTest>
-
-#include "qttestutil/qttestutil.h"
-#include "protocol/discoinfoquerier.h"
-#include "xmpp/jid/jid.h"
-#include "capabilities/capsmanager.h"
-
-using namespace XMPP;
-
-// -----------------------------------------------------------------------------
-
-class TestDiscoInfoQuerier : public Protocol::DiscoInfoQuerier
-{
-public:
-	struct DiscoInfo {
-		XMPP::Jid jid;
-		QString node;
-		XMPP::DiscoItem item;
-	};
-
-	TestDiscoInfoQuerier() {
-		nb_getdiscoinfo_called_ = 0;
-	}
-
-	void getDiscoInfo(const Jid& j, const QString& n) {
-		emitDiscoInfo(j,n);
-	}
-
-	void emitDiscoInfo(const XMPP::Jid& j, const QString& n) {
-		nb_getdiscoinfo_called_++;
-		foreach(DiscoInfo info, infos_) {
-			if (info.jid.compare(j,true) && info.node == n) {
-				emit getDiscoInfo_success(j,n,info.item);
-				return;
-			}
-		}
-	}
-
-	void addInfo(const XMPP::Jid& j, const QString& n, const XMPP::DiscoItem& it) {
-		DiscoInfo i;
-		i.jid = j;
-		i.node = n;
-		i.item = it;
-		infos_ += i;
-	}
-
-	unsigned int nb_getdiscoinfo_called_;
-	QList<DiscoInfo> infos_;
-};
-
-// -----------------------------------------------------------------------------
-
-class CapsManagerTest : public QObject
-{
-		Q_OBJECT
-
-	private slots:
-		void initTestCase() {
-			manager_ = NULL;
-			querier_ = new TestDiscoInfoQuerier();
-		}
-
-		void cleanupTestCase() {
-			delete manager_;
-		}
-
-		void testUpdateCaps()
-		{
-			QStringList capabilities;
-			capabilities << "c1" << "c2" << "c3";
-			addContact("you@example.com/a", "myclient", "myversion", capabilities);
-			CapsManager* manager = createManager("me@example.com");
-
-			manager->updateCaps("you@example.com/a", "myclient", "myversion", "c1 c2");
-			XMPP::Features features(manager->features("you@example.com/a"));
-
-			QCOMPARE(querier_->nb_getdiscoinfo_called_, 3U);
-			QVERIFY(features.test(QStringList("myversion_f1")));
-			QVERIFY(features.test(QStringList("c1_f1")));
-			QVERIFY(features.test(QStringList("c1_f2")));
-			QVERIFY(features.test(QStringList("c2_f1")));
-			QVERIFY(features.test(QStringList("c2_f2")));
-		}
-
-		void testCapsEnabled() {
-			QStringList capabilities;
-			capabilities << "c1" << "c2";
-			addContact("you@example.com/a", "myclient", "myversion", capabilities);
-			CapsManager* manager = createManager("me@example.com");
-
-			manager->updateCaps("you@example.com/a", "myclient", "myversion", "c1 c2");
-
-			QVERIFY(manager->capsEnabled("you@example.com/a"));
-		}
-
-		void testCapsEnabled_NoCaps() {
-			CapsManager* manager = createManager("me@example.com/a");
-
-			QVERIFY(!manager->capsEnabled("you@example.com/b"));
-		}
-
-		void testDisableCaps() {
-			QStringList capabilities;
-			capabilities << "c1" << "c2";
-			addContact("you@example.com/a", "myclient", "myversion", capabilities);
-			CapsManager* manager = createManager("me@example.com");
-			manager->updateCaps("you@example.com/a", "myclient", "myversion", "c1 c2");
-
-			manager->disableCaps("you@example.com/a");
-
-			QVERIFY(!manager->capsEnabled("you@example.com/a"));
-		}
-
-	private:
-		void addContact(const QString& jid, const QString& client, const QString& version, const QStringList& capabilities) {
-			XMPP::DiscoItem i;
-			i.setFeatures(XMPP::Features(version + "_f1"));
-			querier_->addInfo(jid, client + '#' + version, i);
-
-			foreach(QString s, capabilities) {
-				XMPP::DiscoItem i2;
-				QStringList f;
-				f << s + "_f1" << s + "_f2";
-				i2.setFeatures(XMPP::Features(f));
-				querier_->addInfo(jid, client + '#' + s, i2);
-			}
-		}
-
-		CapsManager* createManager(const QString& jid) {
-			manager_ = new CapsManager(jid, &registry_, querier_);
-			return manager_;
-		}
-
-	private:
-		CapsRegistry registry_;
-		TestDiscoInfoQuerier* querier_;
-		CapsManager* manager_;
-};
-
-QTTESTUTIL_REGISTER_TEST(CapsManagerTest);
-#include "capsmanagertest.moc"
diff --git a/src/capabilities/unittest/capsspectest.cpp b/src/capabilities/unittest/capsspectest.cpp
deleted file mode 100644
index eadcd21..0000000
--- a/src/capabilities/unittest/capsspectest.cpp
+++ /dev/null
@@ -1,85 +0,0 @@
-/**
- * Copyright (C) 2007, Remko Troncon
- */
-
-#include <QObject>
-#include <QtTest/QtTest>
-
-#include "qttestutil/qttestutil.h"
-#include "capabilities/capsspec.h"
-
-class CapsSpecTest : public QObject
-{
-		Q_OBJECT
-
-	private slots:
-		void testConstructor() {
-			CapsSpec c("a","b","c d");
-
-			QVERIFY(c.node() == "a");
-			QVERIFY(c.version() == "b");
-			QVERIFY(c.extensions() == "c d");
-		}
-
-		void testEqualsNotEquals_Equal() {
-			CapsSpec c1("a","b","c d");
-			CapsSpec c2("a","b","c d");
-
-			QVERIFY(c1 == c2);
-			QVERIFY(!(c1 != c2));
-		}
-
-		void testEqualsNotEquals_NotEqual() {
-			CapsSpec c1("a","b","c d");
-			CapsSpec c2("a","e","c d");
-
-			QVERIFY(!(c1 == c2));
-			QVERIFY(c1 != c2);
-		}
-
-		void testSmallerThan() {
-			CapsSpec c1("a","b","c");
-			CapsSpec c2("d","e","f");
-
-			QVERIFY(c1 < c2);
-			QVERIFY(!(c2 < c1));
-		}
-
-		void testSmallerThan_SameNode() {
-			CapsSpec c1("a","b","c");
-			CapsSpec c2("a","e","f");
-
-			QVERIFY(c1 < c2);
-			QVERIFY(!(c2 < c1));
-		}
-
-		void testSmallerThan_SameNodeVersion() {
-			CapsSpec c1("a","b","c");
-			CapsSpec c2("a","b","f");
-
-			QVERIFY(c1 < c2);
-			QVERIFY(!(c2 < c1));
-		}
-
-		void testSmallerThan_Equals() {
-			CapsSpec c1("a","b","c");
-			CapsSpec c2("a","b","c");
-
-			QVERIFY(!(c1 < c2));
-			QVERIFY(!(c2 < c1));
-		}
-
-		void testFlatten() {
-			CapsSpec c("a","b","c d");
-
-			CapsSpecs cs = c.flatten();
-
-			QCOMPARE(cs.count(), 3);
-			QVERIFY(cs[0] == CapsSpec("a", "b", "b"));
-			QVERIFY(cs[1] == CapsSpec("a", "b", "c"));
-			QVERIFY(cs[2] == CapsSpec("a", "b", "d"));
-		}
-};
-
-QTTESTUTIL_REGISTER_TEST(CapsSpecTest);
-#include "capsspectest.moc"
diff --git a/src/capabilities/unittest/unittest.pri b/src/capabilities/unittest/unittest.pri
deleted file mode 100644
index fd3a81d..0000000
--- a/src/capabilities/unittest/unittest.pri
+++ /dev/null
@@ -1,3 +0,0 @@
-SOURCES += \
-	$$PWD/capsmanagertest.cpp \
-	$$PWD/capsspectest.cpp
diff --git a/src/capabilities/unittest/unittest.pro b/src/capabilities/unittest/unittest.pro
deleted file mode 100644
index f38da78..0000000
--- a/src/capabilities/unittest/unittest.pro
+++ /dev/null
@@ -1,19 +0,0 @@
-include(../../modules.pri)
-include($$IRIS_XMPP_JID_MODULE)
-include($$IRIS_XMPP_QA_UNITTEST_MODULE)
-include($$PSI_CAPABILITIES_MODULE)
-include($$PSI_UTILITIES_MODULE)
-include($$PSI_PROTOCOL_MODULE)
-include(unittest.pri)
-
-QT += xml
-
-# FIXME
-INCLUDEPATH += \
-	$$PWD/../../../iris/src/xmpp/xmpp-im
-DEPENDPATH += \
-	$$PWD/../../../iris/src/xmpp/xmpp-im
-
-SOURCES += \
-	$$PWD/../../../iris/src/xmpp/xmpp-im/xmpp_features.cpp \
-	$$PWD/../../../iris/src/xmpp/xmpp-im/xmpp_discoitem.cpp
diff --git a/src/chatdlg.cpp b/src/chatdlg.cpp
index d0711f4..d88c7d9 100644
--- a/src/chatdlg.cpp
+++ b/src/chatdlg.cpp
@@ -63,7 +63,6 @@
 #include "pgputil.h"
 #include "psicon.h"
 #include "iconlabel.h"
-#include "capsmanager.h"
 #include "iconaction.h"
 #include "avatars.h"
 #include "jidutil.h"
diff --git a/src/discodlg.cpp b/src/discodlg.cpp
index f97d680..5e8e6f2 100644
--- a/src/discodlg.cpp
+++ b/src/discodlg.cpp
@@ -497,6 +497,7 @@ void DiscoListItem::browseFinished()
 
 void DiscoListItem::doAgents(bool parentAutoItems)
 {
+	/* TODO remove jabber:iq:agents. it's obsoleted ince 2003 */
 	if ( parentAutoItems ) {
 		// save traffic
 		if ( alreadyItems )
diff --git a/src/gcuserview.cpp b/src/gcuserview.cpp
index 39db8b3..8ddad7b 100644
--- a/src/gcuserview.cpp
+++ b/src/gcuserview.cpp
@@ -27,7 +27,6 @@
 #include <QMimeData>
 #include <QMenu>
 
-#include "capsmanager.h"
 #include "psitooltip.h"
 #include "psiaccount.h"
 #include "userlist.h"
@@ -38,6 +37,7 @@
 #include "coloropt.h"
 #include "avcall/avcall.h"
 #include "xmpp_muc.h"
+#include "xmpp_caps.h"
 #include "avatars.h"
 
 static bool caseInsensitiveLessThan(const QString &s1, const QString &s2)
@@ -204,8 +204,9 @@ public:
 				UserListItem u;
 				const QString &nick = item->text(0);
 				Jid caps_jid(/*s.mucItem().jid().isEmpty() ? */ dlg->jid().withResource(nick) /* : s.mucItem().jid()*/);
-				QString client_name = dlg->account()->capsManager()->clientName(caps_jid);
-				QString client_version = (client_name.isEmpty() ? QString() : dlg->account()->capsManager()->clientVersion(caps_jid));
+				CapsManager *cm = dlg->account()->client()->capsManager();
+				QString client_name = cm->clientName(caps_jid);
+				QString client_version = (client_name.isEmpty() ? QString() : cm->clientVersion(caps_jid));
 				UserResource ur;
 				ur.setClient(client_name,client_version,"");
 				u.userResourceList().append(ur);
diff --git a/src/groupchatdlg.cpp b/src/groupchatdlg.cpp
index bc136ed..25c7a24 100644
--- a/src/groupchatdlg.cpp
+++ b/src/groupchatdlg.cpp
@@ -57,7 +57,6 @@
 #include "psiactionlist.h"
 #include "psicon.h"
 #include "psiaccount.h"
-#include "capsmanager.h"
 #include "userlist.h"
 #include "mucconfigdlg.h"
 #include "textutil.h"
@@ -1661,9 +1660,9 @@ void GCMainDlg::presence(const QString &nick, const Status &s)
 		ui_.lv_users->removeEntry(nick);
 	}
 
-	if (!s.capsNode().isEmpty()) {
+	if (s.caps().isValid()) {
 		Jid caps_jid(s.mucItem().jid().isEmpty() || !d->nonAnonymous ? Jid(jid()).withResource(nick) : s.mucItem().jid());
-		account()->capsManager()->updateCaps(caps_jid,s.capsNode(),s.capsVersion(),s.capsExt());
+		account()->capsManager()->updateCaps(caps_jid, s.caps());
 	}
 
 	if(!nick.isEmpty())
diff --git a/src/main.cpp b/src/main.cpp
index c546fd9..478c604 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -454,6 +454,8 @@ void psiMessageOutput(QtMsgType type, const QMessageLogContext &context, const Q
 	case QtFatalMsg:
 		fprintf(stderr, "[%s] F:%s (%s:%u, %s)\n", qPrintable(time), localMsg.constData(), context.file, context.line, context.function);
 		abort();
+	case QtInfoMsg:
+		fprintf(stderr, "[%s] I:%s (%s:%u, %s)\n", qPrintable(time), localMsg.constData(), context.file, context.line, context.function);
 	}
 }
 #else
diff --git a/src/psiaccount.cpp b/src/psiaccount.cpp
index 196410b..262c42c 100644
--- a/src/psiaccount.cpp
+++ b/src/psiaccount.cpp
@@ -91,7 +91,6 @@
 #include "infodlg.h"
 #include "adduserdlg.h"
 #include "historydlg.h"
-#include "capsmanager.h"
 #include "registrationdlg.h"
 #include "searchdlg.h"
 #include "discodlg.h"
@@ -1062,7 +1061,7 @@ public:
 	bool reconnectInfrequently_;
 };
 
-PsiAccount* PsiAccount::create(const UserAccount &acc, PsiContactList *parent, CapsRegistry* capsRegistry, TabManager *tabManager)
+PsiAccount* PsiAccount::create(const UserAccount &acc, PsiContactList *parent, TabManager *tabManager)
 {
 #ifdef NEWCONTACTLIST
 	PsiAccount* account = new PsiAccount(acc, parent, capsRegistry, tabManager);
@@ -1077,7 +1076,7 @@ void PsiAccount::init()
 {
 }
 
-PsiAccount::PsiAccount(const UserAccount &acc, PsiContactList *parent, CapsRegistry* capsRegistry, TabManager *tabManager)
+PsiAccount::PsiAccount(const UserAccount &acc, PsiContactList *parent, TabManager *tabManager)
 	: QObject(parent)
 {
 	d = new Private( this );
@@ -1185,8 +1184,7 @@ PsiAccount::PsiAccount(const UserAccount &acc, PsiContactList *parent, CapsRegis
 	d->privacyManager = new PsiPrivacyManager(d->account, d->client->rootTask());
 
 	// Caps manager
-	d->capsManager = new CapsManager(d->client->jid(), capsRegistry, new IrisProtocol::DiscoInfoQuerier(d->client));
-	d->capsManager->setEnabled(PsiOptions::instance()->getOption("options.service-discovery.enable-entity-capabilities").toBool());
+	d->client->capsManager->setEnabled(PsiOptions::instance()->getOption("options.service-discovery.enable-entity-capabilities").toBool());
 
 	// Roster item exchange task
 	d->rosterItemExchangeTask = new RosterItemExchangeTask(d->client->rootTask());
@@ -2536,8 +2534,12 @@ void PsiAccount::client_resourceAvailable(const Jid &j, const Resource &r)
 
 			UserResource ur(r);
 			//ur.setSecurityEnabled(true);
-			if(local)
+			if(local) {
 				ur.setClient(ApplicationInfo::name(),ApplicationInfo::version(),SystemInfo::instance()->os());
+			}
+			else {
+				ur.setClient(capsManager()->clientName(j),capsManager()->clientVersion(j),capsManager()->osVersion(j));
+			}
 
 			u->userResourceList().append(ur);
 			rp = &u->userResourceList().last();
@@ -2600,15 +2602,14 @@ void PsiAccount::client_resourceAvailable(const Jid &j, const Resource &r)
 
 	// Update entity capabilities.
 	// This has to happen after the userlist item has been created.
-	if (!r.status().capsNode().isEmpty()) {
-		capsManager()->updateCaps(j,r.status().capsNode(),r.status().capsVersion(),r.status().capsExt());
+	if (r.status().caps().isValid()) {
+		capsManager()->updateCaps(j, r.status().caps());
 
 		// Update the client version
 		foreach(UserListItem* u, findRelevant(j)) {
 			UserResourceList::Iterator rit = u->userResourceList().find(j.resource());
 			if (rit != u->userResourceList().end()) {
-				//(*rit).setClient(capsManager()->clientName(j),capsManager()->clientVersion(j),"");
-				(*rit).setClient(QString(),QString(),"");
+				(*rit).setClient(capsManager()->clientName(j),capsManager()->clientVersion(j),capsManager()->osVersion(j));
 				cpUpdate(*u,(*rit).name());
 			}
 		}
@@ -3108,9 +3109,7 @@ void PsiAccount::setStatusActual(const Status &_s)
 
 	// Add entity capabilities information
 	if (capsManager()->isEnabled()) {
-		s.setCapsNode(d->client->capsNode());
-		s.setCapsVersion(d->client->capsVersion());
-		s.setCapsExt(d->client->capsExt());
+		s.setCaps(CapsSpec(d->client->capsNode(),d->client->capsVersion(),d->client->capsAlgorythm()));
 	}
 
 	if (!presenceSent) {
@@ -3168,14 +3167,19 @@ void PsiAccount::capsChanged(const Jid& j)
 
 	QString name = capsManager()->clientName(j);
 	QString version = (name.isEmpty() ? QString() : capsManager()->clientVersion(j));
+	QString os;
+
+	if (!name.isEmpty()) {
+		version = capsManager()->clientVersion(j);
+		os = capsManager()->osVersion(j);
+	}
 
 	foreach(UserListItem *u, findRelevant(j)) {
 		UserResourceList::Iterator rit = u->userResourceList().find(j.resource());
 		bool found = (rit == u->userResourceList().end()) ? false: true;
 		if(!found)
 			continue;
-		//(*rit).setClient(name,version,"");
-		(*rit).setClient(QString(),QString(),"");
+		(*rit).setClient(name,version,os);
 		cpUpdate(*u);
 	}
 }
diff --git a/src/psiaccount.h b/src/psiaccount.h
index 32bfaa2..61e30b1 100644
--- a/src/psiaccount.h
+++ b/src/psiaccount.h
@@ -66,7 +66,6 @@ class BookmarkManager;
 class URLBookmark;
 class ConferenceBookmark;
 class VoiceCaller;
-class CapsRegistry;
 class UserAccount;
 class ContactProfile;
 class QWidget;
@@ -78,7 +77,6 @@ class UserList;
 class EventDlg;
 class ChatDlg;
 class PrivacyManager;
-class CapsManager;
 class EDB;
 class QSSLCert;
 class QHostAddress;
@@ -104,11 +102,11 @@ class PsiAccount : public QObject
 {
 	Q_OBJECT
 protected:
-	PsiAccount(const UserAccount &acc, PsiContactList *parent, CapsRegistry* capsRegistry, TabManager *tabManager);
+	PsiAccount(const UserAccount &acc, PsiContactList *parent, TabManager *tabManager);
 	virtual void init();
 
 public:
-	static PsiAccount* create(const UserAccount &acc, PsiContactList *parent, CapsRegistry* capsRegistry, TabManager *tabManager);
+	static PsiAccount* create(const UserAccount &acc, PsiContactList *parent, TabManager *tabManager);
 	virtual ~PsiAccount();
 
 	bool enabled() const;
@@ -136,7 +134,6 @@ public:
 	PsiCon *psi() const;
 	AvatarFactory *avatarFactory() const;
 	PrivacyManager* privacyManager() const;
-	CapsManager* capsManager() const;
 	VoiceCaller* voiceCaller() const;
 #ifdef WHITEBOARDING
 	WbManager* wbManager() const;
diff --git a/src/psicapsregsitry.cpp b/src/psicapsregsitry.cpp
new file mode 100644
index 0000000..d43cd32
--- /dev/null
+++ b/src/psicapsregsitry.cpp
@@ -0,0 +1,31 @@
+#include "psicapsregsitry.h"
+#include "iodeviceopener.h"
+#include "applicationinfo.h"
+
+PsiCapsRegsitry::PsiCapsRegsitry(QObject *parent) :
+	CapsRegistry(parent)
+{
+
+}
+
+void PsiCapsRegsitry::saveData(const QByteArray &data)
+{
+	QFile file(ApplicationInfo::homeDir(ApplicationInfo::CacheLocation) + "/caps.xml");
+	IODeviceOpener opener(&file, QIODevice::WriteOnly);
+	if (!opener.isOpen()) {
+		qWarning("Caps: Unable to open IO device");
+		return;
+	}
+	file.write(data);
+}
+
+QByteArray PsiCapsRegsitry::loadData()
+{
+	QFile file(ApplicationInfo::homeDir(ApplicationInfo::CacheLocation) + "/caps.xml");
+	IODeviceOpener opener(&file, QIODevice::ReadOnly);
+	if (!opener.isOpen()) {
+		qWarning("CapsRegistry: Cannot open input device");
+		return QByteArray();
+	}
+	return file.readAll();
+}
diff --git a/src/psicapsregsitry.h b/src/psicapsregsitry.h
new file mode 100644
index 0000000..7392fab
--- /dev/null
+++ b/src/psicapsregsitry.h
@@ -0,0 +1,17 @@
+#ifndef PSICAPSREGSITRY_H
+#define PSICAPSREGSITRY_H
+
+#include "xmpp_caps.h"
+
+class PsiCapsRegsitry : public XMPP::CapsRegistry
+{
+	Q_OBJECT
+
+public:
+	PsiCapsRegsitry(QObject *parent);
+
+	void saveData(const QByteArray &data);
+	QByteArray loadData();
+};
+
+#endif // PSICAPSREGSITRY_H
diff --git a/src/psichatdlg.cpp b/src/psichatdlg.cpp
index 4cb2334..1793785 100644
--- a/src/psichatdlg.cpp
+++ b/src/psichatdlg.cpp
@@ -39,7 +39,6 @@
 #include "shortcutmanager.h"
 #include "accountlabel.h"
 #include "iconlabel.h"
-#include "capsmanager.h"
 #include "psicontactlist.h"
 #include "userlist.h"
 #include "psicontact.h"
@@ -245,7 +244,7 @@ void PsiChatDlg::initUi()
 	ui_.tb_actions->setIcon(IconsetFactory::icon("psi/select").icon());
 	ui_.tb_actions->setStyleSheet(" QToolButton::menu-indicator { image:none } ");
 
-	connect(account()->capsManager(), SIGNAL(capsChanged(const Jid&)), SLOT(capsChanged(const Jid&)));
+	connect(account()->client()->capsManager(), SIGNAL(capsChanged(const Jid&)), SLOT(capsChanged(const Jid&)));
 
 	QList<int> list;
 	list << 324;
diff --git a/src/psicon.cpp b/src/psicon.cpp
index eabbf28..fdef0c2 100644
--- a/src/psicon.cpp
+++ b/src/psicon.cpp
@@ -36,6 +36,7 @@
 #include <QDir>
 
 #include "s5b.h"
+#include "xmpp_caps.h"
 #include "psiaccount.h"
 #include "activeprofiles.h"
 #include "accountadddlg.h"
@@ -88,7 +89,6 @@
 #include "networkaccessmanager.h"
 #include "webview.h"
 #endif
-#include "capsregistry.h"
 #include "urlobject.h"
 #include "anim.h"
 #include "psioptions.h"
@@ -106,7 +106,6 @@
 #include "xmpp_xmlcommon.h"
 #include "psicontact.h"
 #include "contactupdatesmanager.h"
-#include "capsmanager.h"
 #include "avcall/avcall.h"
 #include "avcall/calldlg.h"
 #include "alertmanager.h"
@@ -300,7 +299,6 @@ public:
 	//GlobalAccelManager *globalAccelManager;
 	TuneControllerManager* tuneManager;
 	QMenuBar* defaultMenuBar;
-	CapsRegistry* capsRegistry;
 	TabManager *tabManager;
 	bool quitting;
 	QTimer* updatedAccountTimer_;
@@ -363,7 +361,7 @@ PsiCon::PsiCon()
 	d->actionList = 0;
 	d->defaultMenuBar = new QMenuBar(0);
 
-	d->capsRegistry = new CapsRegistry();
+	XMPP::CapsRegistry::setInstance(new PsiCapsRegistry(this));
 	connect(d->capsRegistry, SIGNAL(registered(const CapsSpec&)), SLOT(saveCapabilities()));
 }
 
@@ -750,14 +748,16 @@ void PsiCon::updateStatusPresets()
 
 void PsiCon::registerCaps(const QString& ext, const QStringList& features)
 {
-	DiscoItem::Identity identity = { "client", ApplicationInfo::name(), "pc" };
+	DiscoItem::Identity identity("client", "pc", NULL, ApplicationInfo::name() );
 	DiscoItem::Identities identities;
 	identities += identity;
+	DiscoItem item;
+	item.setIdentities(identities);
+	item.setFeatures(features);
 
 	d->capsRegistry->registerCaps(CapsSpec(ApplicationInfo::capsNode(),
-										   ApplicationInfo::capsVersion(), ext),
-								  identities,
-								  Features(features));
+										   ApplicationInfo::capsVersion(), ext, QString()),
+								  item);
 }
 
 void PsiCon::deinit()
@@ -1019,7 +1019,7 @@ PsiAccount* PsiCon::createAccount(const QString &name, const Jid &j, const QStri
 PsiAccount *PsiCon::createAccount(const UserAccount& _acc)
 {
 	UserAccount acc = _acc;
-	PsiAccount *pa = new PsiAccount(acc, d->contactList, d->capsRegistry, d->tabManager);
+	PsiAccount *pa = new PsiAccount(acc, d->contactList, d->tabManager);
 //	connect(&d->idle, SIGNAL(secondsIdle(int)), pa, SLOT(secondsIdle(int)));
 	connect(pa, SIGNAL(updatedActivity()), SLOT(pa_updatedActivity()));
 	connect(pa, SIGNAL(updatedAccount()), SLOT(pa_updatedAccount()));
@@ -1236,8 +1236,7 @@ void PsiCon::saveAccounts()
 
 void PsiCon::saveCapabilities()
 {
-	QFile file(ApplicationInfo::homeDir(ApplicationInfo::CacheLocation) + "/caps.xml");
-	d->capsRegistry->save(file);
+	CapsRegistry::instance()->save();
 }
 
 void PsiCon::updateMainwinStatus()
diff --git a/src/src.pri b/src/src.pri
index a95cf72..efa07d9 100644
--- a/src/src.pri
+++ b/src/src.pri
@@ -15,7 +15,6 @@ unix:!mac:DEFINES += HAVE_X11
 include($$PWD/protocol/protocol.pri)
 include($$PWD/irisprotocol/irisprotocol.pri)
 include($$PWD/privacy/privacy.pri)
-include($$PWD/capabilities/capabilities.pri)
 include($$PWD/tabs/tabs.pri)
 include($$PWD/Certificates/Certificates.pri)
 
@@ -212,20 +211,12 @@ HEADERS += \
 	$$PWD/psicli.h \
 	$$PWD/coloropt.h \
 	$$PWD/geolocationdlg.h \
-	$$PWD/rosteravatarframe.h
-
-
-HEADERS += tabcompletion.h
-SOURCES += tabcompletion.cpp
-
-HEADERS += alertmanager.h
-SOURCES += alertmanager.cpp
-
-HEADERS += accountloginpassword.h
-SOURCES += accountloginpassword.cpp
-
-HEADERS += mcmdcompletion.h
-SOURCES += mcmdcompletion.cpp
+	$$PWD/rosteravatarframe.h \
+	$$PWD/psicapsregsitry.h \
+	$$PWD/tabcompletion.h \
+	$$PWD/alertmanager.h \
+	$$PWD/accountloginpassword.h \
+	$$PWD/mcmdcompletion.h
 
 # Source files
 SOURCES += \
@@ -351,7 +342,13 @@ SOURCES += \
 	$$PWD/vcardphotodlg.cpp \
 	$$PWD/coloropt.cpp \
 	$$PWD/geolocationdlg.cpp \
-	$$PWD/rosteravatarframe.cpp
+	$$PWD/rosteravatarframe.cpp \
+	$$PWD/tabcompletion.cpp \
+	$$PWD/psicapsregsitry.cpp \
+	$$PWD/alertmanager.cpp \
+	$$PWD/accountloginpassword.cpp \
+	$$PWD/mcmdcompletion.cpp
+
 
 CONFIG += filetransfer
 filetransfer {
