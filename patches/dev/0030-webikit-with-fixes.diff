--- psi.orig/options/default.xml
+++ psi/options/default.xml
@@ -26,6 +26,9 @@
 			<chat comment="HTML in chats">
 				<render comment="Display received HTML" type="bool">true</render>
 			</chat>
+			<muc comment="HTML in group chats">
+				<render comment="Display received HTML" type="bool">false</render>
+			</muc>
 		</html>
 		<extended-presence comment="Extended presence options">
 			<notify comment="Get notified of extended presence changes" type="bool">true</notify>
@@ -90,6 +93,7 @@
 				<size type="QString"></size> <!-- will be invalid when converted to QSize so we can detect first load -->
 			</message>
 			<chat comment="Chat dialog options">
+				<theme comment="The theme used for messages rendering" type="QString">psi/classic</theme>
 				<central-toolbar comment="Have a central toolbar" type="bool">false</central-toolbar>
 				<size comment="Remembered window size" type="QSize">
 				</size><!-- will be invalid when converted to QSize so we can detect first load -->
@@ -260,6 +264,7 @@
 						<received type="QColor" comment="Color used to indicate received messages.">#0000ff</received>
 						<sent type="QColor" comment="Color used to indicate sent messages.">#ff0000</sent>
 						<informational type="QColor" comment="Color used to indicate informational (status change, spooled) messages.">#008000</informational>
+						<usertext type="QColor" comment="Color used to indicate additional text for informational messages.">#606060</usertext>
 					</messages>
 					<passive-popup>
 						<border type="QColor">#5297f9</border>
--- psi.orig/psi.qc
+++ psi/psi.qc
@@ -29,6 +29,9 @@
     <required/>
   </dep>
   <dep type='qdbus'/>
+  <dep type='webkit'>
+    <disabled/>
+  </dep>
   <dep type='growl'/>
   <dep type='whiteboarding'>
     <disabled/>
--- psi.orig/qcm/webkit.qcm
+++ psi/qcm/webkit.qcm
@@ -0,0 +1,38 @@
+/*
+-----BEGIN QCMOD-----
+name: QtWebKit
+-----END QCMOD-----
+*/
+
+//----------------------------------------------------------------------------
+// qc_webkit
+//----------------------------------------------------------------------------
+class qc_webkit : public ConfObj
+{
+public:
+	qc_webkit(Conf *c) : ConfObj(c) {}
+	QString name() const { return "QtWebKit"; }
+	QString shortname() const { return "webkit"; }
+	bool exec()
+	{
+		QString proextra =
+		"CONFIG += qt webkit\n"
+		"QT += webkit\n";
+
+		QString str =
+		"\n"
+		"int main()\n"
+		"{\n"
+		"	return 0;\n"
+		"}\n";
+
+		int ret;
+		if(!conf->doCompileAndLink(str, QStringList(), QString(), proextra, &ret))
+			return false;
+		if(ret != 0)
+			return false;
+
+		conf->addExtra("CONFIG += webkit");
+		return true;
+	}
+};
--- psi.orig/src/bytearrayreply.cpp
+++ psi/src/bytearrayreply.cpp
@@ -0,0 +1,84 @@
+/*
+ * bytearrayreply.cpp - Base class for QNetworReply'es returning QByteArray
+ * Copyright (C) 2010 senu, Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include "bytearrayreply.h"
+
+#include <QTimer>
+
+ByteArrayReply::ByteArrayReply(const QNetworkRequest &request,
+							   const QByteArray &ba, const QString& mimeType,
+							   QObject *parent) :
+	QNetworkReply(parent),
+	origLen(ba.size()),
+	data(ba)
+{
+	setRequest(request);
+	setOpenMode(QIODevice::ReadOnly);
+
+	if (ba.isNull()) {
+		setError(QNetworkReply::ContentNotFoundError, "Not found");
+		QTimer::singleShot(0, this, SIGNAL(metaDataChanged()));
+		QTimer::singleShot(0, this, SIGNAL(error()));
+		QTimer::singleShot(0, this, SIGNAL(finished()));
+	} else {
+		if (mimeType.isEmpty()) {
+			setHeader(QNetworkRequest::ContentTypeHeader, "application/octet-stream");
+		} else {
+			setHeader(QNetworkRequest::ContentTypeHeader, mimeType);
+		}
+		setHeader(QNetworkRequest::ContentLengthHeader, QByteArray::number(origLen));
+		QTimer::singleShot(0, this, SIGNAL(metaDataChanged()));
+		QTimer::singleShot(0, this, SIGNAL(readyRead()));
+	}
+}
+
+ByteArrayReply::~ByteArrayReply() {
+
+}
+
+void ByteArrayReply::abort() {
+	// its ok for abort here. webkit calls it in any case on finish
+}
+
+qint64 ByteArrayReply::bytesAvailable() const
+{
+	return data.length() + QNetworkReply::bytesAvailable();
+}
+
+
+qint64 ByteArrayReply::readData(char *buffer, qint64 maxlen)
+{
+	qint64 len = qMin(qint64(data.length()), maxlen);
+	if (len) {
+		memcpy(buffer, data.constData(), len);
+		data.remove(0, len);
+	}
+	if (!data.length())
+		QTimer::singleShot(0, this, SIGNAL(finished()));
+	return len;
+
+}
+
+
+bool ByteArrayReply::open(OpenMode mode) {
+	Q_UNUSED(mode);
+	Q_ASSERT(0); //should never happened
+	return true;
+}
--- psi.orig/src/bytearrayreply.h
+++ psi/src/bytearrayreply.h
@@ -0,0 +1,53 @@
+/*
+ * bytearrayreply.h - Base class for QNetworReply'es returning QByteArray
+ * Copyright (C) 2010 senu, Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef BYTEARRAYREPLY_H
+#define BYTEARRAYREPLY_H
+
+#include <QNetworkReply>
+#include <QBuffer>
+
+
+class ByteArrayReply : public QNetworkReply {
+
+	Q_OBJECT
+
+public:
+	ByteArrayReply(const QNetworkRequest &request,
+				   const QByteArray &ba = QByteArray(),
+				   const QString &mimeType = QString(),
+				   QObject * parent = 0);
+
+	/** Construct IconReply that fails with ContentAccessDenied error */
+	//ByteArrayReply();
+	~ByteArrayReply();
+
+	//reimplemented
+	void abort();
+	qint64 readData(char *buffer, qint64 maxlen);
+	qint64 bytesAvailable() const;
+	bool open(OpenMode mode);
+
+private:
+	int origLen;
+	QByteArray data;
+};
+
+#endif
--- psi.orig/src/chatdlg.cpp
+++ psi/src/chatdlg.cpp
@@ -73,6 +73,8 @@
 #include "psicontactlist.h"
 #include "accountlabel.h"
 #include "psirichtext.h"
+#include "messageview.h"
+#include "chatview.h"

 #ifdef Q_WS_WIN
 #include <windows.h>
@@ -117,12 +119,16 @@ void ChatDlg::init()
 	initActions();
 	setShortcuts();

-	// TODO: this have to be moved to chatEditCreated()
+	chatEdit()->installEventFilter(this);
 	chatView()->setDialog(this);
-	chatEdit()->setDialog(this);
+	chatView()->setSessionData(false, jid().full(), jid().full()); //FIXME fix nick updating
+#ifdef WEBKIT
+	chatView()->setAccount(account());
+#endif
+	chatView()->init();

-	chatEdit()->installEventFilter(this);
-	connect(chatView(), SIGNAL(selectionChanged()), SLOT(logSelectionChanged()));
+	// seems its useless hack
+	//connect(chatView(), SIGNAL(selectionChanged()), SLOT(logSelectionChanged())); //

 	// SyntaxHighlighters modify the QTextEdit in a QTimer::singleShot(0, ...) call
 	// so we need to install our hooks after it fired for the first time
@@ -200,12 +206,12 @@ void ChatDlg::setShortcuts()

 void ChatDlg::scrollUp()
 {
-	chatView()->verticalScrollBar()->setValue(chatView()->verticalScrollBar()->value() - chatView()->verticalScrollBar()->pageStep() / 2);
+	chatView()->scrollUp();
 }

 void ChatDlg::scrollDown()
 {
-	chatView()->verticalScrollBar()->setValue(chatView()->verticalScrollBar()->value() + chatView()->verticalScrollBar()->pageStep() / 2);
+	chatView()->scrollDown();
 }

 void ChatDlg::closeEvent(QCloseEvent *e)
@@ -303,12 +309,13 @@ void ChatDlg::logSelectionChanged()
 {
 #ifdef Q_WS_MAC
 	// A hack to only give the message log focus when text is selected
-	if (chatView()->textCursor().hasSelection()) {
-		chatView()->setFocus();
-	}
-	else {
-		chatEdit()->setFocus();
-	}
+// seems its already useless. at least copy works w/o this hack
+//	if (chatView()->textCursor().hasSelection()) {
+//		chatView()->setFocus();
+//	}
+//	else {
+//		chatEdit()->setFocus();
+//	}
 #endif
 }

@@ -450,18 +457,7 @@ void ChatDlg::updateContact(const Jid &j
 			updatePGP();

 			if (fromPresence && statusChanged) {
-				QString msg = tr("%1 is %2").arg(Qt::escape(dispNick_)).arg(status2txt(status_));
-				if (!statusString_.isEmpty()) {
-					QString ss = TextUtil::linkify(TextUtil::plain2rich(statusString_));
-					if (PsiOptions::instance()->getOption("options.ui.emoticons.use-emoticons").toBool()) {
-						ss = TextUtil::emoticonify(ss);
-					}
-					if (PsiOptions::instance()->getOption("options.ui.chat.legacy-formatting").toBool()) {
-						ss = TextUtil::legacyFormat(ss);
-					}
-					msg += QString(" [%1]").arg(ss);
-				}
-				appendSysMsg(msg);
+				chatView()->dispatchMessage(MessageView::statusMessage(dispNick_, status_, statusString_));
 			}
 		}

@@ -670,6 +666,8 @@ void ChatDlg::doSend()
 	if (isEncryptionEnabled()) {
 		m.setWasEncrypted(true);
 	}
+	QString id = account()->client()->genUniqueId();
+	m.setId(id); // we need id early for message manipulations in chatview
 	m_ = m;

 	// Request events
@@ -777,7 +775,7 @@ QString ChatDlg::whoNick(bool local) con
 		result = dispNick_;
 	}

-	return Qt::escape(result);
+	return result;
 }

 void ChatDlg::appendMessage(const Message &m, bool local)
@@ -792,17 +790,14 @@ void ChatDlg::appendMessage(const Messag
 	encEnabled = lastWasEncrypted_;

 	if (encChanged) {
-		if (encEnabled) {
-			appendSysMsg(QString("<icon name=\"psi/cryptoYes\"> ") + tr("Encryption Enabled"));
-			if (!local) {
-				setPGPEnabled(true);
-			}
-		}
-		else {
-			appendSysMsg(QString("<icon name=\"psi/cryptoNo\"> ") + tr("Encryption Disabled"));
-			if (!local) {
-				setPGPEnabled(false);
-
+		chatView()->dispatchMessage(MessageView::fromHtml(
+				encEnabled? QString("<icon name=\"psi/cryptoYes\"> ") + tr("Encryption Enabled"):
+							QString("<icon name=\"psi/cryptoNo\"> ") + tr("Encryption Disabled"),
+				MessageView::System
+		));
+		if (!local) {
+			setPGPEnabled(encEnabled);
+			if (!encEnabled) {
 				// enable warning
 				warnSend_ = true;
 				QTimer::singleShot(3000, this, SLOT(setWarnSendFalse()));
@@ -810,21 +805,31 @@ void ChatDlg::appendMessage(const Messag
 		}
 	}

-	QString txt = messageText(m);
-	QString subject = messageSubject(m);
-
-	ChatDlg::SpooledType spooledType = m.spooled() ?
-	                                   ChatDlg::Spooled_OfflineStorage :
-	                                   ChatDlg::Spooled_None;
-	if (isEmoteMessage(m))
-		appendEmoteMessage(spooledType, m.timeStamp(), local, txt, subject);
-	else
-		appendNormalMessage(spooledType, m.timeStamp(), local, txt, subject);
-
-	appendMessageFields(m);
+	if (!m.subject().isEmpty()) {
+		chatView()->dispatchMessage(MessageView::subjectMessage(m.subject()));
+	}

-	if (local) {
-		deferredScroll();
+	MessageView mv(MessageView::Message);
+	if (m.containsHTML() && PsiOptions::instance()->getOption("options.html.chat.render").toBool() && !m.html().text().isEmpty()) {
+		mv.setHtml(m.html().toString("span"));
+	} else {
+		mv.setPlainText(m.body());
+	}
+	mv.setMessageId(m.id());
+	mv.setLocal(local);
+	mv.setNick(whoNick(local));
+	mv.setUserId(local?account()->jid().bare():jid().bare());
+	mv.setDateTime(m.timeStamp());
+	mv.setSpooled(m.spooled());
+	chatView()->dispatchMessage(mv);
+
+	if (!m.urlList().isEmpty()) {
+		UrlList urls = m.urlList();
+		QMap<QString,QString> urlsMap;
+		foreach (const Url &u, urls) {
+			urlsMap.insert(u.url(), u.desc());
+		}
+		chatView()->dispatchMessage(MessageView::urlsMessage(urlsMap));
 	}

 	// if we're not active, notify the user by changing the title
@@ -855,16 +860,6 @@ void ChatDlg::appendMessage(const Messag
 	}
 }

-void ChatDlg::deferredScroll()
-{
-	QTimer::singleShot(250, this, SLOT(slotScroll()));
-}
-
-void ChatDlg::slotScroll()
-{
-	chatView()->scrollToBottom();
-}
-
 void ChatDlg::updateIsComposing(bool b)
 {
 	setChatState(b ? XMPP::StateComposing : XMPP::StatePaused);
@@ -1029,67 +1024,8 @@ void ChatDlg::nicksChanged()
 	// this function is intended to be reimplemented in subclasses
 }

-static const QString me_cmd = "/me ";
-
-bool ChatDlg::isEmoteMessage(const XMPP::Message& m)
-{
-	if (m.body().startsWith(me_cmd) || m.html().text().trimmed().startsWith(me_cmd))
-		return true;
-
-	return false;
-}
-
-QString ChatDlg::messageText(const XMPP::Message& m)
-{
-	bool emote = isEmoteMessage(m);
-	QString txt;
-
-	if (m.containsHTML() && PsiOptions::instance()->getOption("options.html.chat.render").toBool() && !m.html().text().isEmpty()) {
-		txt = m.html().toString("span");
-
-		if (emote) {
-			int cmd = txt.indexOf(me_cmd);
-			txt = txt.remove(cmd, me_cmd.length());
-		}
-		// qWarning("html body:\n%s\n",qPrintable(txt));
-	}
-	else {
-		txt = m.body();
-
-		if (emote)
-			txt = txt.mid(me_cmd.length());
-
-		txt = TextUtil::plain2rich(txt);
-		txt = TextUtil::linkify(txt);
-		// qWarning("regular body:\n%s\n",qPrintable(txt));
-	}
-
-	if (PsiOptions::instance()->getOption("options.ui.emoticons.use-emoticons").toBool())
-		txt = TextUtil::emoticonify(txt);
-	if (PsiOptions::instance()->getOption("options.ui.chat.legacy-formatting").toBool())
-		txt = TextUtil::legacyFormat(txt);
-
-	return txt;
-}
-
-QString ChatDlg::messageSubject(const XMPP::Message& m)
-{
-	QString txt = m.subject();
-
-	if (!txt.isEmpty()) {
-		txt = TextUtil::plain2rich(txt);
-		txt = TextUtil::linkify(txt);
-		if (PsiOptions::instance()->getOption("options.ui.emoticons.use-emoticons").toBool())
-			txt = TextUtil::emoticonify(txt);
-		if (PsiOptions::instance()->getOption("options.ui.chat.legacy-formatting").toBool())
-			txt = TextUtil::legacyFormat(txt);
-	}
-	return txt;
-}
-
 void ChatDlg::chatEditCreated()
 {
-	chatView()->setDialog(this);
 	chatEdit()->setDialog(this);

 	if (highlightersInstalled_) {
--- psi.orig/src/chatdlg.h
+++ psi/src/chatdlg.h
@@ -124,7 +124,6 @@ private slots:
 	virtual void updatePGP();
 	virtual void setPGPEnabled(bool enabled);
 	void encryptedMessageSent(int, bool, int, const QString &);
-	void slotScroll();
 	void setChatState(XMPP::ChatState s);
 	void updateIsComposing(bool);
 	void setContactChatState(ChatState s);
@@ -145,28 +144,15 @@ protected:
 	void doneSend();
 	virtual void setLooks();
 	void setSelfDestruct(int);
-	void deferredScroll();
-	bool isEmoteMessage(const XMPP::Message& m);
-	QString messageText(const XMPP::Message& m);
-	QString messageSubject(const XMPP::Message& m);
 	virtual void chatEditCreated();

-	enum SpooledType {
-		Spooled_None,
-		Spooled_OfflineStorage
-	};
-
 	virtual void initUi() = 0;
 	virtual void capsChanged();
 	virtual void contactUpdated(UserListItem* u, int status, const QString& statusString);
-	virtual QString colorString(bool local, SpooledType spooled) const = 0;

 	void appendMessage(const Message &, bool local = false);
 	virtual bool isEncryptionEnabled() const;
 	virtual void appendSysMsg(const QString& txt) = 0;
-	virtual void appendEmoteMessage(SpooledType spooled, const QDateTime& time, bool local, const QString& txt, const QString& subject) = 0;
-	virtual void appendNormalMessage(SpooledType spooled, const QDateTime& time, bool local, const QString& txt, const QString& subject) = 0;
-	virtual void appendMessageFields(const Message& m) = 0;
 	virtual void nicksChanged();

 	QString whoNick(bool local) const;
--- psi.orig/src/chatdlg.ui
+++ psi/src/chatdlg.ui
@@ -203,9 +203,6 @@
          <property name="focusPolicy" >
           <enum>Qt::NoFocus</enum>
          </property>
-         <property name="readOnly" >
-          <bool>true</bool>
-         </property>
         </widget>
        </item>
       </layout>
@@ -313,8 +310,8 @@
  <customwidgets>
   <customwidget>
    <class>ChatView</class>
-   <extends>QTextEdit</extends>
-   <header>msgmle.h</header>
+   <extends>QFrame</extends>
+   <header>chatview.h</header>
   </customwidget>
   <customwidget>
    <class>ChatSplitter</class>
--- psi.orig/src/chatview.h
+++ psi/src/chatview.h
@@ -0,0 +1,5 @@
+#ifdef WEBKIT
+#include "chatview_webkit.h"
+#else
+#include "chatview_te.h"
+#endif
--- psi.orig/src/chatviewshare.cpp
+++ psi/src/chatviewshare.cpp
@@ -0,0 +1,66 @@
+/*
+ * chatviewshare.cpp - shared part of any chatview
+ * Copyright (C) 2010 Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include "chatviewshare.h"
+#include "psioptions.h"
+
+ChatViewShare::ChatViewShare(QObject *parent)
+		: QObject(parent)
+		, nickNumber_(0)
+{
+
+}
+
+bool ChatViewShare::updateLastMsgTime(QDateTime t)
+{
+	bool doInsert = t.date() != lastMsgTime_.date();
+	lastMsgTime_ = t;
+	return doInsert;
+}
+
+QString ChatViewShare::getMucNickColor(QString nick, bool isSelf, QStringList validList)
+{
+	int sender;
+	if(isSelf || nick.isEmpty()) {
+		sender = -1;
+	} else {
+		if (!nicks.contains(nick)) {
+			//not found in map
+			nicks.insert(nick,nickNumber_);
+			nickNumber_++;
+		}
+		sender=nicks[nick];
+	}
+
+	QStringList nickColors = validList.isEmpty()
+		? PsiOptions::instance()->getOption("options.ui.look.colors.muc.nick-colors").toStringList()
+		: validList;
+
+	if(!PsiOptions::instance()->getOption("options.ui.muc.use-nick-coloring").toBool() || nickColors.empty()) {
+		return "#000000";
+	}
+	else if(sender == -1 || nickColors.size() == 1) {
+		return nickColors[nickColors.size()-1];
+	}
+	else {
+		int n = sender % (nickColors.size()-1);
+		return nickColors[n];
+	}
+}
--- psi.orig/src/chatviewshare.h
+++ psi/src/chatviewshare.h
@@ -0,0 +1,47 @@
+/*
+ * chatviewshare.h - shared part of any chatview
+ * Copyright (C) 2010 Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef CHATVIEWBASE_H
+#define CHATVIEWBASE_H
+
+#include <QDateTime>
+#include <QMap>
+#include <QObject>
+#include <QStringList>
+
+class ChatViewShare : public QObject
+{
+	Q_OBJECT
+public:
+	ChatViewShare(QObject *parent);
+	bool updateLastMsgTime(QDateTime t);
+
+protected:
+	QDateTime lastMsgTime_;
+
+private:
+	int nickNumber_;
+	QMap<QString,int> nicks;
+
+public slots:
+	QString getMucNickColor(QString, bool, QStringList validList = QStringList());
+};
+
+#endif
--- psi.orig/src/chatview_te.cpp
+++ psi/src/chatview_te.cpp
@@ -0,0 +1,390 @@
+/*
+ * chatview_te.cpp - subclass of PsiTextView to handle various hotkeys
+ * Copyright (C) 2001-2010  Justin Karneges, Michail Pishchagin, Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include "chatview_te.h"
+
+#include "msgmle.h"
+#include "messageview.h"
+#include "psioptions.h"
+#include "coloropt.h"
+#include "textutil.h"
+#include "psirichtext.h"
+#include "chatviewshare.h"
+#include "common.h"
+
+#include <QWidget>
+#include <QTextOption>
+#include <QScrollBar>
+#include <QTimer>
+#include <QKeyEvent>
+
+static const char *infomrationalColorOpt = "options.ui.look.colors.messages.informational";
+
+//----------------------------------------------------------------------------
+// ChatView
+//----------------------------------------------------------------------------
+ChatView::ChatView(QWidget *parent)
+	: PsiTextView(parent)
+	, isMuc_(false)
+	, oldTrackBarPosition(0)
+	, dialog_(0)
+	, share_(this)
+{
+	setWordWrapMode(QTextOption::WrapAtWordBoundaryOrAnywhere);
+
+	setReadOnly(true);
+	setUndoRedoEnabled(false);
+	setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
+
+#ifndef Q_WS_X11	// linux has this feature built-in
+	connect(this, SIGNAL(selectionChanged()), SLOT(autoCopy()));
+	connect(this, SIGNAL(cursorPositionChanged()), SLOT(autoCopy()));
+#endif
+}
+
+ChatView::~ChatView()
+{
+
+}
+
+// something after we know isMuc and dialog is set
+void ChatView::init()
+{
+
+}
+
+QSize ChatView::sizeHint() const
+{
+	return minimumSizeHint();
+}
+
+void ChatView::setDialog(QWidget* dialog)
+{
+	dialog_ = dialog;
+}
+
+void ChatView::setSessionData(bool isMuc, const QString &jid, const QString name)
+{
+	isMuc_ = isMuc;
+	jid_ = jid;
+	name_ = name;
+}
+
+bool ChatView::focusNextPrevChild(bool next)
+{
+	return QWidget::focusNextPrevChild(next);
+}
+
+void ChatView::keyPressEvent(QKeyEvent *e)
+{
+/*	if(e->key() == Qt::Key_Escape)
+		e->ignore();
+#ifdef Q_WS_MAC
+	else if(e->key() == Qt::Key_W && e->modifiers() & Qt::ControlModifier)
+		e->ignore();
+	else
+#endif
+	else if(e->key() == Qt::Key_Return && ((e->modifiers() & Qt::ControlModifier) || (e->modifiers() & Qt::AltModifier)) )
+		e->ignore();
+	else if(e->key() == Qt::Key_H && (e->modifiers() & Qt::ControlModifier))
+		e->ignore();
+	else if(e->key() == Qt::Key_I && (e->modifiers() & Qt::ControlModifier))
+		e->ignore(); */
+	/*else*/ if(e->key() == Qt::Key_M && (e->modifiers() & Qt::ControlModifier) && !isReadOnly()) // newline
+		append("\n");
+/*	else if(e->key() == Qt::Key_U && (e->modifiers() & Qt::ControlModifier) && !isReadOnly())
+		setText(""); */
+	else if ((e->key() == Qt::Key_Return || e->key() == Qt::Key_Enter) && ((e->modifiers() & Qt::ControlModifier) || (e->modifiers() & Qt::AltModifier))) {
+		e->ignore();
+	}
+	else {
+		PsiTextView::keyPressEvent(e);
+	}
+}
+
+/**
+ * Copies any selected text to the clipboard
+ * if autoCopy is enabled and ChatView is in read-only mode.
+ */
+void ChatView::autoCopy()
+{
+	if (isReadOnly() && PsiOptions::instance()->getOption("options.ui.automatically-copy-selected-text").toBool()) {
+		copy();
+	}
+}
+
+/**
+ * Handle KeyPress events that happen in ChatEdit widget. This is used
+ * to 'fix' the copy shortcut.
+ * \param object object that should receive the event
+ * \param event received event
+ * \param chatEdit pointer to the dialog's ChatEdit widget that receives user input
+ */
+bool ChatView::handleCopyEvent(QObject *object, QEvent *event, ChatEdit *chatEdit)
+{
+	if (object == chatEdit && event->type() == QEvent::ShortcutOverride &&
+		((QKeyEvent*)event)->matches(QKeySequence::Copy)) {
+
+		if (!chatEdit->textCursor().hasSelection() &&
+			this->textCursor().hasSelection()) {
+			this->copy();
+			return true;
+		}
+	}
+
+	return false;
+}
+
+QString ChatView::formatTimeStamp(const QDateTime &time)
+{
+	// TODO: provide an option for user to customize
+	// time stamp format
+	return QString().sprintf("%02d:%02d:%02d", time.time().hour(), time.time().minute(), time.time().second());;
+}
+
+QString ChatView::colorString(bool local, bool spooled) const
+{
+	if (spooled) {
+		return ColorOpt::instance()->color(infomrationalColorOpt).name();
+	}
+
+	if (local) {
+		return ColorOpt::instance()->color("options.ui.look.colors.messages.sent").name();
+	}
+
+	return ColorOpt::instance()->color("options.ui.look.colors.messages.received").name();
+}
+
+void ChatView::updateLastMsgTime(const QDateTime &t)
+{
+	if (share_.updateLastMsgTime(t)) {
+		QString color = ColorOpt::instance()->color(infomrationalColorOpt).name();
+		appendText(QString("<font color=\"%1\">*** %2</font>").arg(color).arg(t.date().toString(Qt::ISODate)));
+	}
+}
+
+void ChatView::appendText(const QString &text)
+{
+	bool doScrollToBottom = atBottom();
+
+	// prevent scrolling back to selected text when
+	// restoring selection
+	int scrollbarValue = verticalScrollBar()->value();
+
+	PsiTextView::appendText(text);
+
+	if (doScrollToBottom)
+		scrollToBottom();
+	else
+		verticalScrollBar()->setValue(scrollbarValue);
+}
+
+void ChatView::dispatchMessage(const MessageView &mv)
+{
+	if ((mv.type() == MessageView::Message || mv.type() == MessageView::Subject) && share_.updateLastMsgTime(mv.dateTime())) {
+		QString color = ColorOpt::instance()->color(infomrationalColorOpt).name();
+		appendText(QString("<font color=\"%1\">*** %2</font>").arg(color).arg(mv.dateTime().date().toString(Qt::ISODate)));
+	}
+	switch (mv.type()) {
+		case MessageView::Message:
+			if (isMuc_) {
+				renderMucMessage(mv);
+			} else {
+				renderMessage(mv);
+			}
+			break;
+		case MessageView::Subject:
+			if (isMuc_) {
+				renderMucSubject(mv);
+			} else {
+				renderSubject(mv);
+			}
+			break;
+		case MessageView::Urls:
+			renderUrls(mv);
+			break;
+		default: // System/Status
+			renderSysMessage(mv);
+	}
+}
+
+void ChatView::renderMucMessage(const MessageView &mv)
+{
+	const QString timestr = formatTimeStamp(mv.dateTime());
+	QString alerttagso, alerttagsc, nickcolor;
+	QString textcolor = palette().color(QPalette::Active, QPalette::Text).name();
+	if(mv.isAlert()) {
+		textcolor = "#FF0000";
+		alerttagso = "<b>";
+		alerttagsc = "</b>";
+	}
+
+	if(mv.isSpooled()) {
+		nickcolor = ColorOpt::instance()->color(infomrationalColorOpt).name();
+	} else {
+		nickcolor = share_.getMucNickColor(mv.nick(), mv.isLocal());
+	}
+
+	if(mv.isEmote()) {
+		appendText(QString("<font color=\"%1\">").arg(nickcolor) + QString("[%1]").arg(timestr) + QString(" *%1 ").arg(Qt::escape(mv.nick())) + alerttagso + mv.formattedText() + alerttagsc + "</font>");
+	}
+	else {
+		if(PsiOptions::instance()->getOption("options.ui.chat.use-chat-says-style").toBool()) {
+			appendText(QString("<font color=\"%1\">").arg(nickcolor) + QString("[%1] ").arg(timestr) + QString("%1 says:").arg(Qt::escape(mv.nick())) + "</font><br>" + QString("<font color=\"%1\">").arg(textcolor) + alerttagso + mv.formattedText() + alerttagsc + "</font>");
+		}
+		else {
+			appendText(QString("<font color=\"%1\">").arg(nickcolor) + QString("[%1] &lt;").arg(timestr) + Qt::escape(mv.nick()) + QString("&gt;</font> ") + QString("<font color=\"%1\">").arg(textcolor) + alerttagso + mv.formattedText() + alerttagsc +"</font>");
+		}
+	}
+
+	if(mv.isLocal()) {
+		scrollToBottom();
+	}
+}
+
+void ChatView::renderMessage(const MessageView &mv)
+{
+	QString timestr = formatTimeStamp(mv.dateTime());
+	QString color = colorString(mv.isLocal(), mv.isSpooled());
+	if (mv.isEmote()) {
+		appendText(QString("<span style=\"color: %1\">").arg(color) + QString("[%1]").arg(timestr) + QString(" *%1 ").arg(Qt::escape(mv.nick())) + mv.formattedText() + "</span>");
+	} else {
+		if (PsiOptions::instance()->getOption("options.ui.chat.use-chat-says-style").toBool()) {
+			appendText(QString("<p style=\"color: %1\">").arg(color) + QString("[%1] ").arg(timestr) + tr("%1 says:").arg(Qt::escape(mv.nick())) + "</p>" + mv.formattedText());
+		}
+		else {
+			appendText(QString("<span style=\"color: %1\">").arg(color) + QString("[%1] &lt;").arg(timestr) + Qt::escape(mv.nick()) + QString("&gt;</span> ") + mv.formattedText());
+		}
+	}
+
+	if (mv.isLocal()) {
+		deferredScroll();
+	}
+}
+
+void ChatView::renderSysMessage(const MessageView &mv)
+{
+	QString timestr = formatTimeStamp(mv.dateTime());
+	QString ut = mv.formattedUserText();
+	QString color = ColorOpt::instance()->color(infomrationalColorOpt).name();
+	QString userTextColor = ColorOpt::instance()->color("options.ui.look.colors.messages.usertext").name();
+	appendText(QString("<font color=\"%1\">[%2] *** ").arg(color, timestr) + mv.formattedText() +
+						(ut.isEmpty()?"":":") + "</font>" +
+						(ut.isEmpty()?"":QString(" <span style=\"color:%1;\">%2</span>").arg(userTextColor, ut)));
+}
+
+void ChatView::renderSubject(const MessageView &mv)
+{
+	appendText(QString("<b>") + tr("Subject:") + "</b> " + QString("%1").arg(mv.formattedUserText()));
+}
+
+void ChatView::renderMucSubject(const MessageView &mv)
+{
+	QString timestr = formatTimeStamp(mv.dateTime());
+	QString ut = mv.formattedUserText();
+	QString color = ColorOpt::instance()->color(infomrationalColorOpt).name();
+	QString userTextColor = ColorOpt::instance()->color("options.ui.look.colors.messages.usertext").name();
+	appendText(QString("<font color=\"%1\">[%2] *** ").arg(color, timestr) + mv.formattedText() +
+						(ut.isEmpty()?"":":<br>") + "</font>" +
+						(ut.isEmpty()?"":QString(" <span style=\"color:%1;font-weight:bold\">%2</span>").arg(userTextColor, ut)));
+}
+
+void ChatView::renderUrls(const MessageView &mv)
+{
+	QMap<QString, QString> urls = mv.urls();
+	foreach (const QString &key, urls.keys()) {
+		appendText(QString("<b>") + tr("URL:") + "</b> " + QString("%1").arg(TextUtil::linkify(Qt::escape(key))));
+		if (!urls.value(key).isEmpty()) {
+			appendText(QString("<b>") + tr("Desc:") + "</b> " + QString("%1").arg(urls.value(key)));
+		}
+	}
+}
+
+void ChatView::slotScroll() {
+	scrollToBottom();
+}
+
+void ChatView::deferredScroll()
+{
+	QTimer::singleShot(250, this, SLOT(slotScroll()));
+}
+
+void ChatView::scrollUp()
+{
+	verticalScrollBar()->setValue(verticalScrollBar()->value() - verticalScrollBar()->pageStep() / 2);
+}
+
+void ChatView::scrollDown()
+{
+	verticalScrollBar()->setValue(verticalScrollBar()->value() + verticalScrollBar()->pageStep() / 2);
+}
+
+void ChatView::doTrackBar()
+{
+	// save position, because our manipulations could change it
+	int scrollbarValue = verticalScrollBar()->value();
+
+	QTextCursor cursor = textCursor();
+	cursor.beginEditBlock();
+	PsiRichText::Selection selection = PsiRichText::saveSelection(this, cursor);
+
+	//removeTrackBar(cursor);
+	if (oldTrackBarPosition) {
+		cursor.setPosition(oldTrackBarPosition, QTextCursor::KeepAnchor);
+		QTextBlockFormat blockFormat = cursor.blockFormat();
+		blockFormat.clearProperty(QTextFormat::BlockTrailingHorizontalRulerWidth);
+		cursor.clearSelection();
+		cursor.setBlockFormat(blockFormat);
+	}
+
+	//addTrackBar(cursor);
+	cursor.movePosition(QTextCursor::End, QTextCursor::KeepAnchor);
+	oldTrackBarPosition = cursor.position();
+	QTextBlockFormat blockFormat = cursor.blockFormat();
+	blockFormat.setProperty(QTextFormat::BlockTrailingHorizontalRulerWidth, QVariant(true));
+	cursor.clearSelection();
+	cursor.setBlockFormat(blockFormat);
+
+	PsiRichText::restoreSelection(this, cursor, selection);
+	cursor.endEditBlock();
+	setTextCursor(cursor);
+
+	verticalScrollBar()->setValue(scrollbarValue);
+}
+
+bool ChatView::internalFind(QString str, bool startFromBeginning)
+{
+	if (startFromBeginning) {
+		QTextCursor cursor = textCursor();
+		cursor.movePosition(QTextCursor::Start, QTextCursor::KeepAnchor);
+		cursor.clearSelection();
+		setTextCursor(cursor);
+	}
+
+	bool found = find(str);
+	if(!found) {
+		if (!startFromBeginning)
+			return internalFind(str, true);
+
+		return false;
+	}
+
+	return true;
+}
--- psi.orig/src/chatview_te.h
+++ psi/src/chatview_te.h
@@ -0,0 +1,90 @@
+/*
+ * chatview_te.h - subclass of PsiTextView to handle various hotkeys
+ * Copyright (C) 2001-2010  Justin Karneges, Michail Pishchagin, Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef CHATVIEW_TE_H
+#define CHATVIEW_TE_H
+
+#include <QWidget>
+#include <QDateTime>
+#include <QPointer>
+
+#include "psitextview.h"
+#include "chatviewshare.h"
+
+class ChatEdit;
+class ChatViewBase;
+class MessageView;
+
+class ChatView : public PsiTextView
+{
+	Q_OBJECT
+public:
+	ChatView(QWidget* parent);
+	~ChatView();
+
+	// reimplemented
+	QSize sizeHint() const;
+
+	void init();
+	void setDialog(QWidget* dialog);
+	void setSessionData(bool isMuc, const QString &jid, const QString name);
+
+	void appendText(const QString &text);
+	void dispatchMessage(const MessageView &);
+	bool handleCopyEvent(QObject *object, QEvent *event, ChatEdit *chatEdit);
+
+	void deferredScroll();
+	void scrollUp();
+	void scrollDown();
+	void doTrackBar();
+	bool internalFind(QString str, bool startFromBeginning = false);
+
+protected:
+	// override the tab/esc behavior
+	bool focusNextPrevChild(bool next);
+	void keyPressEvent(QKeyEvent *);
+
+	QString formatTimeStamp(const QDateTime &time);
+	QString colorString(bool local, bool spooled) const;
+	void updateLastMsgTime(const QDateTime &t);
+
+	void renderMucMessage(const MessageView &);
+	void renderMessage(const MessageView &);
+	void renderSysMessage(const MessageView &);
+	void renderSubject(const MessageView &);
+	void renderMucSubject(const MessageView &);
+	void renderUrls(const MessageView &);
+
+protected slots:
+	void autoCopy();
+
+private slots:
+	void slotScroll();
+
+private:
+	bool isMuc_;
+	QString jid_;
+	QString name_;
+	int  oldTrackBarPosition;
+	QPointer<QWidget> dialog_;
+	ChatViewShare share_;
+};
+
+#endif
--- psi.orig/src/chatviewtheme.cpp
+++ psi/src/chatviewtheme.cpp
@@ -0,0 +1,240 @@
+/*
+ * chatviewtheme.cpp - theme for webkit based chatview
+ * Copyright (C) 2010 Rion (Sergey Ilinyh)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include "chatviewtheme.h"
+#include "psioptions.h"
+#include "coloropt.h"
+#include "jsutil.h"
+#include "psiwkavatarhandler.h"
+#include "webview.h"
+#include <QWebPage>
+#include <QWebFrame>
+#include <QFileInfo>
+#include <QApplication>
+
+
+class ChatViewTheme;
+class ChatViewTheme::Private
+{
+public:
+	QString html;
+	QString jsNamespace;
+	QString adapterPath;
+	QStringList scripts;
+	QPointer<QObject> jso;
+	QPointer<WebView> wv;
+};
+
+class ChatViewThemeJS : public QObject {
+	Q_OBJECT
+private:
+	ChatViewTheme *theme;
+	QMap<QString,QVariant> cache_;
+public:
+	ChatViewThemeJS(ChatViewTheme *theme_)
+		: theme(theme_)
+	{
+	}
+
+public slots:
+	void setMetaData(const QVariantMap &map)
+	{
+		if (map["name"].isValid()) {
+			theme->setName(map["name"].toString());
+		}
+	}
+
+	QString psiOption(const QString &option) const
+	{
+		return JSUtil::variant2js(PsiOptions::instance()->getOption(option));
+	}
+
+	QString colorOption(const QString &option) const
+	{
+		return JSUtil::variant2js(ColorOpt::instance()->color(option));
+	}
+
+	QString getFileContents(const QString &name) const
+	{
+		return QString(Theme::loadData(name, theme->fileName()));
+	}
+
+	QString getFileContentsFromAdapterDir(const QString &name) const
+	{
+		QFile file(theme->d->adapterPath + "/" + name);
+		if (file.open(QIODevice::ReadOnly)) {
+			return file.readAll();
+		}
+		return QString();
+	}
+
+	void setHtml(const QString &h)
+	{
+		theme->d->html = h;
+	}
+
+	QString formatDate(const QDateTime &dt, const QString &format) const
+	{
+		return dt.toLocalTime().toString(format);
+	}
+
+	QString getPaletteTextcolor() const
+	{
+		return QApplication::palette().color(QPalette::Text).name();
+	}
+
+	void console(const QString &text) const
+	{
+		qDebug("%s", qPrintable(text));
+	}
+
+	// we don't need not text cache since binary data(images?)
+	// most likely will be cached by webkit itself
+	void toCache(const QString &name, const QVariant &data)
+	{
+		cache_.insert(name, data);
+	}
+
+	QVariant cache(const QString &name) const
+	{
+		return cache_.value(name);
+	}
+
+	void setDefaultAvatar(const QString &filename, const QString &host = QString())
+	{
+		QByteArray ba = Theme::loadData(filename, theme->fileName());
+		if (!ba.isEmpty()) {
+			((PsiWKAvatarHandler *)NetworkAccessManager::instance()
+				->schemeHandler("avatar").data())->setDefaultAvatar(ba, host);
+		}
+	}
+
+	void setAvatarSize(int width, int height)
+	{
+		((PsiWKAvatarHandler *)NetworkAccessManager::instance()
+				->schemeHandler("avatar").data())->setAvatarSize(QSize(width,
+																	   height));
+	}
+
+	void setJSNamespace(const QString &ns)
+	{
+		theme->d->jsNamespace = ns;
+	}
+
+	const QString jsNamespace() const
+	{
+		return theme->d->jsNamespace;
+	}
+
+	QString status2text(int status) const
+	{
+		return ::status2txt(status);
+	}
+
+};
+
+
+//------------------------------------------------------------------------------
+// ChatViewTheme
+//------------------------------------------------------------------------------
+ChatViewTheme::ChatViewTheme(const QString &id) :
+	Theme(id)
+{
+	d = new Private;
+	d->jsNamespace = "chat";
+}
+
+ChatViewTheme::~ChatViewTheme()
+{
+	if (!d->jso.isNull())
+		delete d->jso;
+	if (!d->wv.isNull())
+		delete d->wv;
+	delete d;
+}
+
+bool ChatViewTheme::load(const QString &file, const QStringList &helperScripts,
+						 const QString &adapterPath)
+{
+	if (d->jso.isNull())
+		d->jso = new ChatViewThemeJS(this);
+	if (d->wv.isNull()) {
+		d->wv = new WebView(0);
+		d->wv->setHtml("", QUrl("theme://theme"));
+	}
+	d->adapterPath = adapterPath;
+	setFileName(file);
+	d->scripts = helperScripts;
+
+	d->wv->page()->mainFrame()->addToJavaScriptWindowObject("chatServer", d->jso,
+												QScriptEngine::QtOwnership);
+	foreach (const QString &script, d->scripts) {
+		QVariant result = d->wv->page()->mainFrame()->evaluateJavaScript(script);
+		if (result != "ok") {
+			qDebug("failed to eval helper script: %s...", qPrintable(script.mid(0, 50)));
+			return false;
+		}
+	}
+	QString resStr = d->wv->page()->mainFrame()->evaluateJavaScript(
+				"try { window[chatServer.jsNamespace()].adapter.loadTheme() } "
+				"catch(e) { window[chatServer.jsNamespace()].util.props(e); }").toString();
+
+	if (resStr == "ok") {
+		return true;
+	}
+	qWarning("javascript part of the theme loader "
+			 "didn't return expected result: %s", qPrintable(resStr));
+	return false;
+}
+
+QByteArray ChatViewTheme::screenshot()
+{
+	return Theme::loadData("screenshot.png", fileName());
+}
+
+QObject * ChatViewTheme::jsHelper()
+{
+	return d->jso;
+}
+
+QStringList ChatViewTheme::scripts()
+{
+	return d->scripts;
+}
+
+QString ChatViewTheme::html(QObject *session)
+{
+	if (d->html.isEmpty()) {
+		if (session) {
+			d->wv->page()->mainFrame()->addToJavaScriptWindowObject("chatSession", session);
+		}
+		return d->wv->page()->mainFrame()->evaluateJavaScript(
+					"try { "+d->jsNamespace+".adapter.getHtml(); } catch(e) { e.toString() + ' line:' +e.line; }").toString();
+	}
+	return d->html;
+}
+
+QString ChatViewTheme::jsNamespace()
+{
+	return d->jsNamespace;
+}
+
+
+#include "chatviewtheme.moc"
--- psi.orig/src/chatviewtheme.h
+++ psi/src/chatviewtheme.h
@@ -0,0 +1,53 @@
+/*
+ * chatviewtheme.h - theme for webkit based chatview
+ * Copyright (C) 2010 Rion (Sergey Ilinyh)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef CHATVIEWTHEME_H
+#define CHATVIEWTHEME_H
+
+#include <QPointer>
+
+#include "theme.h"
+#include "webview.h"
+
+class ChatViewThemeJS;
+
+class ChatViewTheme : public Theme
+{
+	friend class ChatViewThemeJS;
+public:
+	ChatViewTheme(const QString &id);
+	~ChatViewTheme();
+
+	QByteArray screenshot();
+
+	bool load( const QString &file, const QStringList &helperScripts,
+			   const QString &adapterPath );
+
+	QObject * jsHelper();
+	QStringList scripts();
+	QString html(QObject *session = 0);
+	QString jsNamespace();
+
+private:
+	class Private;
+	Private *d;
+};
+
+#endif
--- psi.orig/src/chatviewthemeprovider.cpp
+++ psi/src/chatviewthemeprovider.cpp
@@ -0,0 +1,186 @@
+/*
+ * chatviewthemeprovider.h - adapter for set of chatview themes
+ * Copyright (C) 2010 Rion (Sergey Ilinyh)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+
+#include "chatviewthemeprovider.h"
+
+#include <QFile>
+#include <QFileInfo>
+#include <QDir>
+
+#include "chatviewtheme.h"
+#include "psioptions.h"
+#include "theme.h"
+#include "applicationinfo.h"
+#include "psiwkavatarhandler.h"
+
+
+static QMap<QString, QString> chatViewScripts;
+
+class ChatViewThemeProvider;
+
+class ChatViewThemeUrlHandler : public NAMSchemeHandler
+{
+private:
+	ChatViewThemeProvider *provider;
+public:
+	ChatViewThemeUrlHandler(ChatViewThemeProvider *provider_)
+		: provider(provider_)
+	{
+	}
+	QByteArray data(const QUrl &url) const
+	{
+		qDebug("loading theme file: %s", qPrintable(url.toString()));
+		Theme *theme = provider->current();
+		if (theme) {
+			QByteArray td = Theme::loadData(url.path(), theme->fileName());
+			if (td.isNull()) {
+				qDebug("content of %s is not found", qPrintable(url.toString()));
+			}
+			return td;
+		}
+		return QByteArray();
+	}
+
+};
+
+ChatViewThemeProvider::ChatViewThemeProvider(QObject *parent_)
+	: PsiThemeProvider(parent_)
+	, curTheme(0)
+{
+	NetworkAccessManager::instance()->setSchemeHandler(
+			"avatar", new PsiWKAvatarHandler((PsiCon*)parent()) );
+	NetworkAccessManager::instance()->setSchemeHandler(
+			"theme", new ChatViewThemeUrlHandler(this));
+	connect(PsiOptions::instance(),
+			SIGNAL(optionChanged(const QString&)),
+			SLOT(optionChanged(const QString&)));
+}
+
+const QString ChatViewThemeProvider::type() const
+{
+	return "chatview";
+}
+
+const QStringList ChatViewThemeProvider::themeIds() const
+{
+	QStringList dirs;
+	dirs << ":";
+	dirs << ".";
+	dirs << ApplicationInfo::homeDir();
+	dirs << ApplicationInfo::resourcesDir();
+
+	QSet<QString> ret;
+	foreach (QString dir, dirs) {
+		foreach (QFileInfo tDirInfo, QDir(dir+"/themes/chatview/")
+			.entryInfoList(QDir::AllDirs | QDir::NoDotAndDotDot)) {
+			QString typeName = tDirInfo.fileName();
+			foreach (QFileInfo themeInfo,
+					QDir(tDirInfo.absoluteFilePath())
+						.entryInfoList(QDir::AllDirs | QDir::NoDotAndDotDot) +
+					QDir(tDirInfo.absoluteFilePath())
+						.entryInfoList(QStringList("*.theme"), QDir::Files)) {
+				ret<<(QString("%1/%2").arg(typeName).arg(themeInfo.fileName()));
+				//qDebug("found theme: %s", qPrintable(QString("%1/%2").arg(typeName).arg(themeInfo.fileName())));
+			}
+		}
+	}
+
+	return ret.values();
+}
+
+Theme * ChatViewThemeProvider::load(const QString &themeId)
+{
+	QString up;
+	if (chatViewScripts.value("util").isEmpty()) {
+		if (!(up = themePath("chatview/util.js")).isEmpty()) {
+			QFile file(up);
+			if (file.open(QIODevice::ReadOnly)) {
+				chatViewScripts["util"] = file.readAll();
+			}
+		}
+	}
+	if (!chatViewScripts.value("util").isEmpty()) {
+		int pos;
+		if ((pos = themeId.indexOf('/')) > 0) {
+			QString tp = themePath("chatview/" + themeId);
+			QString typeName = themeId.mid(0, pos);
+			if (!tp.isEmpty()) { // theme exists
+				QString ap, ad;
+				if (chatViewScripts.value(typeName).isEmpty() &&
+					!(ap = themePath("chatview/" + typeName + "/adapter.js")).isEmpty()) {
+					QFile afile(ap);
+					if (afile.open(QIODevice::ReadOnly)) {
+						chatViewScripts[typeName] = afile.readAll();
+						ad = QFileInfo(afile).dir().path();
+					}
+				}
+				if (!chatViewScripts.value(typeName).isEmpty()) {
+					ChatViewTheme *theme = new ChatViewTheme(themeId);
+					if (theme->load(tp, QStringList()<<chatViewScripts["util"]
+									<<chatViewScripts[typeName], ad)) {
+						return theme;
+					}
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+bool ChatViewThemeProvider::loadCurrent()
+{
+	QString themeName = PsiOptions::instance()->getOption(optionString()).toString();
+	ChatViewTheme *theme = 0;
+	if (!(theme = (ChatViewTheme *)load(themeName))) {
+		if (themeName != "psi/classic") {
+			qDebug("fallback to classic chatview theme");
+			if ( (theme = (ChatViewTheme *)load("psi/classic")) ) {
+				PsiOptions::instance()->setOption(optionString(), "psi/classic");
+			}
+		}
+	}
+	if (theme) {
+		if (curTheme) {
+			delete curTheme;
+		}
+		curTheme = theme;
+		emit themeChanged();
+		return true;
+	}
+	return false;
+}
+
+Theme *ChatViewThemeProvider::current() const
+{
+	return curTheme;
+}
+
+int ChatViewThemeProvider::screenshotWidth() const
+{
+	return 512;
+}
+
+void ChatViewThemeProvider::optionChanged(const QString& option)
+{
+	if (option == optionString()) {
+		loadCurrent();
+	}
+}
--- psi.orig/src/chatviewthemeprovider.h
+++ psi/src/chatviewthemeprovider.h
@@ -0,0 +1,74 @@
+/*
+ * chatviewthemeprovider.h - adapter for set of chatview themes
+ * Copyright (C) 2010 Rion (Sergey Ilinyh)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+
+#ifndef CHATVIEWTHEMEPROVIDER_H
+#define CHATVIEWTHEMEPROVIDER_H
+
+#include "psithemeprovider.h"
+
+class ChatViewTheme;
+
+class ChatViewThemeProvider : public PsiThemeProvider
+{
+	Q_OBJECT
+
+public:
+	ChatViewThemeProvider(QObject *);
+
+	const QString type() const;
+	const QStringList themeIds() const;
+	Theme* load(const QString &themeId);
+	bool loadCurrent();
+	Theme *current() const;
+	virtual int screenshotWidth() const;
+
+	QString optionsName() const { return tr("Chat Message Style"); }
+	QString optionsDescription() const { return tr("Configure your chat theme here"); }
+
+protected:
+	virtual const char* optionString() const { return "options.ui.chat.theme"; }
+
+signals:
+	void themeChanged();
+
+private slots:
+	void optionChanged(const QString& option);
+
+private:
+	ChatViewTheme *curTheme;
+};
+
+class GroupChatViewThemeProvider : public ChatViewThemeProvider
+{
+	Q_OBJECT
+
+public:
+	GroupChatViewThemeProvider(QObject *parent) :
+		ChatViewThemeProvider(parent) {}
+
+	QString optionsName() const { return tr("Groupchat Message Style"); }
+	QString optionsDescription() const { return tr("Configure your groupchat theme here"); }
+
+protected:
+	const char* optionString() const { return "options.ui.muc.theme"; }
+};
+
+#endif // CHATVIEWTHEMEPROVIDER_H
--- psi.orig/src/chatview_webkit.cpp
+++ psi/src/chatview_webkit.cpp
@@ -0,0 +1,309 @@
+/*
+ * chatview_webkit.cpp - Webkit based chatview
+ * Copyright (C) 2010  Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include "chatview_webkit.h"
+
+#include "msgmle.h"
+#include "psioptions.h"
+#include "textutil.h"
+
+#include <QWidget>
+#include <QWebFrame>
+#include <QFile>
+#include <QFileInfo>
+#include <QLayout>
+#include <QPalette>
+
+#include "webview.h"
+//#include "psiapplication.h"
+#include "psiaccount.h"
+#include "applicationinfo.h"
+#include "networkaccessmanager.h"
+#include "jsutil.h"
+#include "messageview.h"
+#include "psithememanager.h"
+#include "chatviewtheme.h"
+
+
+
+//----------------------------------------------------------------------------
+// ChatViewJSObject
+// object which will be embed to javascript part of view
+//----------------------------------------------------------------------------
+ChatViewJSObject::ChatViewJSObject(QObject *view)
+	: QObject(view)
+{
+
+}
+
+QString ChatViewJSObject::mucNickColor(QString nick, bool isSelf, QStringList validList) const
+{
+	return ((ChatView*)parent())->share_.getMucNickColor(nick, isSelf, validList);
+}
+
+bool ChatViewJSObject::isMuc() const
+{
+	return ((ChatView*)parent())->isMuc_;
+}
+
+QString ChatViewJSObject::chatName() const
+{
+	return ((ChatView*)parent())->name_;
+}
+
+QString ChatViewJSObject::jid() const
+{
+	return ((ChatView*)parent())->jid_;
+}
+
+QString ChatViewJSObject::account() const
+{
+	return ((ChatView*)parent())->account_->id();
+}
+
+void ChatViewJSObject::signalInited()
+{
+	emit inited();
+}
+
+QString ChatViewJSObject::getFont() const
+{
+	QFont f = ((ChatView*)parent())->font();
+	QString weight = "normal";
+	switch (f.weight()) {
+		case QFont::Light: weight = "lighter"; break;
+		case QFont::DemiBold: weight = "bold"; break;
+		case QFont::Bold: weight = "bolder"; break;
+		case QFont::Black: weight = "900"; break;
+	}
+	return QString("{fontFamily:'%1',fontSize:'%2pt',fontStyle:'%3',fontVariant:'%4',fontWeight:'%5'}")
+					 .arg(f.family())
+					 .arg(f.pointSize())
+					 .arg(f.style()==QFont::StyleNormal?"normal":(f.style()==QFont::StyleItalic?"italic":"oblique"))
+					 .arg(f.capitalization() == QFont::SmallCaps?"small-caps":"normal")
+					 .arg(weight);
+}
+
+
+//----------------------------------------------------------------------------
+// ChatView
+//----------------------------------------------------------------------------
+ChatView::ChatView(QWidget *parent)
+	: QFrame(parent)
+	, sessionReady_(false)
+	, dialog_(0)
+	, share_(this)
+	, isMuc_(false)
+{
+	jsObject = new ChatViewJSObject(this);
+	webView = new WebView(this);
+	webView->setFocusPolicy(Qt::NoFocus);
+	webView->settings()->setAttribute(QWebSettings::DeveloperExtrasEnabled, true);
+
+	QVBoxLayout *layout = new QVBoxLayout;
+	layout->setContentsMargins(0,0,0,0);
+	layout->addWidget(webView);
+	setLayout(layout);
+	setFrameStyle(QFrame::StyledPanel | QFrame::Sunken);
+
+#ifndef Q_WS_X11	// linux has this feature built-in
+	connect( PsiOptions::instance(), SIGNAL(optionChanged(QString)), SLOT(psiOptionChanged(QString)) ); //needed only for save autocopy state atm
+	psiOptionChanged("options.ui.automatically-copy-selected-text"); // init autocopy connection
+#endif
+	connect(jsObject, SIGNAL(inited()), SLOT(sessionInited()));
+	connect(webView->page()->mainFrame(),
+			SIGNAL(javaScriptWindowObjectCleared()), SLOT(embedJsObject()));
+	connect(PsiThemeManager::instance()->provider("chatview"),
+			SIGNAL(themeChanged()),
+			SLOT(init()));
+}
+
+ChatView::~ChatView()
+{
+}
+
+ChatViewTheme* ChatView::currentTheme()
+{
+	return (ChatViewTheme *)PsiThemeManager::instance()->provider("chatview")->
+			current();
+}
+
+// something after we know isMuc and dialog is set
+void ChatView::init()
+{
+	QString html = currentTheme()->html(jsObject);
+	qDebug() << "Set html:" << html;
+	webView->page()->mainFrame()->setHtml(
+		html, QUrl("theme://theme")
+	);
+}
+
+void ChatView::embedJsObject()
+{
+	ChatViewTheme *theme = currentTheme();
+	QWebFrame *wf = webView->page()->mainFrame();
+	wf->addToJavaScriptWindowObject("chatServer", theme->jsHelper());
+	wf->addToJavaScriptWindowObject("chatSession", jsObject);
+	foreach (const QString &script, theme->scripts()) {
+		wf->evaluateJavaScript(script);
+	}
+}
+
+QSize ChatView::sizeHint() const
+{
+	return minimumSizeHint();
+}
+
+void ChatView::setDialog(QWidget* dialog)
+{
+	dialog_ = dialog;
+}
+
+void ChatView::setSessionData(bool isMuc, const QString &jid, const QString name)
+{
+	isMuc_ = isMuc;
+	jid_ = jid;
+	name_ = name;
+}
+
+bool ChatView::focusNextPrevChild(bool next)
+{
+	return QWidget::focusNextPrevChild(next);
+}
+
+void ChatView::changeEvent(QEvent * event)
+{
+	if ( event->type() == QEvent::ApplicationPaletteChange
+		|| event->type() == QEvent::PaletteChange
+		|| event->type() == QEvent::FontChange ) {
+		QVariantMap m;
+		m["type"] = "settings";
+		sendJsObject(m);
+	}
+	QFrame::changeEvent(event);
+}
+
+void ChatView::psiOptionChanged(const QString &option)
+{
+	if (option == "options.ui.automatically-copy-selected-text") {
+		if (PsiOptions::instance()->
+			getOption("options.ui.automatically-copy-selected-text").toBool()) {
+			connect(webView->page(), SIGNAL(selectionChanged()), webView, SLOT(copySelected()));
+		} else {
+			disconnect(webView->page(), SIGNAL(selectionChanged()), webView, SLOT(copySelected()));
+		}
+	}
+}
+
+void ChatView::sendJsObject(const QVariantMap &map)
+{
+	sendJsCommand(QString(currentTheme()->jsNamespace() + ".adapter.receiveObject(%1);")
+				  .arg(JSUtil::map2json(map)));
+}
+
+void ChatView::sendJsCommand(const QString &cmd)
+{
+	jsBuffer_.append(cmd);
+	checkJsBuffer();
+}
+
+void ChatView::checkJsBuffer()
+{
+	if (sessionReady_) {
+		while (!jsBuffer_.isEmpty()) {
+			webView->evaluateJS(jsBuffer_.takeFirst());
+		}
+	}
+}
+
+void ChatView::sessionInited()
+{
+	sessionReady_ = true;
+	checkJsBuffer();
+}
+
+bool ChatView::handleCopyEvent(QObject *object, QEvent *event, ChatEdit *chatEdit) {
+	if (object == chatEdit && event->type() == QEvent::ShortcutOverride &&
+		((QKeyEvent*)event)->matches(QKeySequence::Copy)) {
+
+		if (!chatEdit->textCursor().hasSelection() &&
+			 !(webView->page()->selectedText().isEmpty()))
+		{
+			webView->copySelected();
+			return true;
+		}
+	}
+
+	return false;
+}
+
+// input point of all messages
+void ChatView::dispatchMessage(const MessageView &mv)
+{
+	if ((mv.type() == MessageView::Message || mv.type() == MessageView::Subject) && share_.updateLastMsgTime(mv.dateTime())) {
+		QVariantMap m;
+		m["date"] = mv.dateTime();
+		m["type"] = "message";
+		m["mtype"] = "lastDate";
+		sendJsObject(m);
+	}
+	QVariantMap vm = mv.toVariantMap(isMuc_, true);
+	vm["mtype"] = vm["type"];
+	vm["type"] = "message";
+	sendJsObject(vm);
+}
+
+void ChatView::scrollUp()
+{
+	QWebFrame *f = webView->page()->mainFrame();
+	f->setScrollBarValue(Qt::Vertical, f->scrollBarValue(Qt::Vertical) - 50);
+}
+
+void ChatView::scrollDown()
+{
+	QWebFrame *f = webView->page()->mainFrame();
+	f->setScrollBarValue(Qt::Vertical, f->scrollBarValue(Qt::Vertical) + 50);
+}
+
+void ChatView::clear()
+{
+	QVariantMap m;
+	m["type"] = "clear";
+	sendJsObject(m);
+}
+
+void ChatView::doTrackBar()
+{
+	QVariantMap m;
+	m["type"] = "trackbar";
+	sendJsObject(m);
+}
+
+bool ChatView::internalFind(QString str, bool startFromBeginning)
+{
+	bool found = webView->page()->findText(str, startFromBeginning ?
+				 QWebPage::FindWrapsAroundDocument : (QWebPage::FindFlag)0);
+
+	if (!found && !startFromBeginning) {
+		return internalFind(str, true);
+	}
+
+	return found;
+}
--- psi.orig/src/chatview_webkit.h
+++ psi/src/chatview_webkit.h
@@ -0,0 +1,116 @@
+/*
+ * chatview_webkit.h - Webkit based chatview
+ * Copyright (C) 2010  Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef CHATVIEW_H
+#define CHATVIEW_H
+
+#include <QWidget>
+#include <QDateTime>
+#include <QFrame>
+#include <QPointer>
+#include "webview.h"
+#include "chatviewshare.h"
+
+class ChatEdit;
+class ChatView;
+class MessageView;
+class PsiAccount;
+class ChatViewTheme;
+
+class ChatViewJSObject : public QObject
+{
+	Q_OBJECT
+public:
+	ChatViewJSObject(QObject *view);
+
+public slots:
+	QString mucNickColor(QString nick, bool isSelf, QStringList validList = QStringList()) const;
+	bool isMuc() const;
+	QString chatName() const;
+	QString jid() const;
+	QString account() const;
+	void signalInited();
+	QString getFont() const;
+
+signals:
+	void inited();
+};
+
+class ChatView : public QFrame
+{
+	Q_OBJECT
+	friend class ChatViewJSObject;
+public:
+	ChatView(QWidget* parent);
+	~ChatView();
+
+	// reimplemented
+	QSize sizeHint() const;
+
+	void setDialog(QWidget* dialog);
+	void setSessionData(bool isMuc, const QString &jid, const QString name);
+	void setAccount(PsiAccount *acc) { account_ = acc; }
+
+	void sendJsObject(const QVariantMap &);
+	void sendJsCommand(const QString &cmd);
+	bool handleCopyEvent(QObject *object, QEvent *event, ChatEdit *chatEdit);
+
+	void dispatchMessage(const MessageView &m);
+
+	void scrollUp();
+	void scrollDown();
+	void clear();
+	void doTrackBar();
+	bool internalFind(QString str, bool startFromBeginning = false);
+
+protected:
+	// override the tab/esc behavior
+	bool focusNextPrevChild(bool next);
+	void changeEvent(QEvent * event);
+	//void keyPressEvent(QKeyEvent *);
+
+protected slots:
+	void psiOptionChanged(const QString &);
+	//void autoCopy();
+
+public slots:
+	void init();
+
+private slots:
+	void embedJsObject();
+	void checkJsBuffer();
+	void sessionInited();
+
+private:
+	ChatViewTheme* currentTheme();
+
+	WebView *webView;
+	ChatViewJSObject *jsObject;
+	QStringList jsBuffer_;
+	bool sessionReady_;
+	QPointer<QWidget> dialog_;
+	ChatViewShare share_;
+	bool isMuc_;
+	QString jid_;
+	QString name_;
+	PsiAccount *account_;
+};
+
+#endif
--- psi.orig/src/eventdlg.cpp
+++ psi/src/eventdlg.cpp
@@ -52,7 +52,7 @@
 #include "psiiconset.h"
 #include "jidutil.h"
 #include "psioptions.h"
-#include "msgmle.h"
+#include "psitextview.h"
 #include "accountscombobox.h"
 #include "common.h"
 #include "xmpp_htmlelement.h"
@@ -524,7 +524,7 @@ public:
 	IconButton *pb_next;
 	IconButton *pb_close, *pb_quote, *pb_deny, *pb_send, *pb_reply, *pb_chat, *pb_auth, *pb_http_confirm, *pb_http_deny;
 	IconButton *pb_form_submit, *pb_form_cancel;
-	ChatView *mle;
+	PsiTextView *mle;
 	AttachView *attachView;
 	QTimer *whois;
 	QString lastWhois;
@@ -849,8 +849,8 @@ void EventDlg::init()
 	}

 	// text area
-	d->mle = new ChatView(this);
-	d->mle->setDialog(this);
+	d->mle = new PsiTextView(this);
+	//d->mle->setDialog(this);
 	d->mle->setReadOnly(false);
 	d->mle->setUndoRedoEnabled(true);
 	d->mle->setMinimumHeight(50);
--- psi.orig/src/filetransdlg.cpp
+++ psi/src/filetransdlg.cpp
@@ -17,7 +17,7 @@
 #include "busywidget.h"
 #include "filetransfer.h"
 #include "psiiconset.h"
-#include "msgmle.h"
+#include "psitextview.h"
 #include "jidutil.h"
 #include "psitooltip.h"
 #include "psicontactlist.h"
@@ -521,7 +521,7 @@ public:
 	QLabel* lb_identity;
 	AccountLabel* lb_ident;
 	QLabel* lb_time;
-	ChatView *te;
+	PsiTextView *te;
 	Jid jid;
 	FileTransferHandler *ft;
 	QString fileName;
@@ -571,7 +571,7 @@ FileRequestDlg::FileRequestDlg(const Jid
 	connect(d->psi, SIGNAL(accountCountChanged()), this, SLOT(updateIdentityVisibility()));
 	updateIdentityVisibility();

-	d->te = new ChatView(this);
+	d->te = new PsiTextView(this);
 	d->te->setReadOnly(false);
 	d->te->setAcceptRichText(false);
 	replaceWidget(te_desc, d->te);
@@ -662,7 +662,7 @@ FileRequestDlg::FileRequestDlg(const QDa

 	replaceWidget(lb_accountlabel, hb);

-	d->te = new ChatView(this);
+	d->te = new PsiTextView(this);
 	d->te->setAcceptRichText(false);
 	replaceWidget(te_desc, d->te);
 	setTabOrder(le_fname, d->te);
--- psi.orig/src/groupchatdlg.cpp
+++ psi/src/groupchatdlg.cpp
@@ -64,6 +64,7 @@
 #include "mucmanager.h"
 #include "busywidget.h"
 #include "msgmle.h"
+#include "messageview.h"
 #include "iconwidget.h"
 #include "iconselect.h"
 #include "xmpp_tasks.h"
@@ -189,7 +190,6 @@ public:
 		nonAnonymous = false;

 		trackBar = false;
-		oldTrackBarPosition = 0;
 		mCmdManager.registerProvider(this);
 	}

@@ -198,6 +198,7 @@ public:
 	MUCManager *mucManager;
 	QString self, prev_self;
 	QString password;
+	QString topic;
 	bool nonAnonymous;		 // got status code 100 ?
 	IconAction *act_find, *act_clear, *act_icon, *act_configure;
 #ifdef WHITEBOARDING
@@ -226,8 +227,6 @@ public:

 public:
 	bool trackBar;
-protected:
-	int  oldTrackBarPosition;

 public:
 	ChatEdit* mle() const { return dlg->ui_.mle->chatEdit(); }
@@ -245,11 +244,6 @@ public slots:
 		PsiRichText::addEmoticon(mle(), text);
 	}

-	void deferredScroll() {
-		//QTimer::singleShot(250, this, SLOT(slotScroll()));
-		te_log()->scrollToBottom();
-	}
-
 	void sp_result(StatusPingTask::Result res, QString id)
 	{
 		//qDebug() << res;
@@ -433,76 +427,11 @@ join <channel>{,<channel>} [pass{,<pass>
 	virtual void mCmdSiteDestroyed() {
 	}

-
-
-protected slots:
-	void slotScroll() {
-		te_log()->scrollToBottom();
-	}
-
-public:
-	bool internalFind(QString str, bool startFromBeginning = false)
-	{
-		if (startFromBeginning) {
-			QTextCursor cursor = te_log()->textCursor();
-			cursor.movePosition(QTextCursor::Start, QTextCursor::KeepAnchor);
-			cursor.clearSelection();
-			te_log()->setTextCursor(cursor);
-		}
-
-		bool found = te_log()->find(str);
-		if(!found) {
-			if (!startFromBeginning)
-				return internalFind(str, true);
-
-			return false;
-		}
-
-		return true;
-	}
-
-private:
-	void removeTrackBar(QTextCursor &cursor)
-	{
-		if (oldTrackBarPosition) {
-			cursor.setPosition(oldTrackBarPosition, QTextCursor::KeepAnchor);
-			QTextBlockFormat blockFormat = cursor.blockFormat();
-			blockFormat.clearProperty(QTextFormat::BlockTrailingHorizontalRulerWidth);
-			cursor.clearSelection();
-			cursor.setBlockFormat(blockFormat);
-		}
-	}
-
-	void addTrackBar(QTextCursor &cursor)
-	{
-		cursor.movePosition(QTextCursor::End, QTextCursor::KeepAnchor);
-		oldTrackBarPosition = cursor.position();
-		QTextBlockFormat blockFormat = cursor.blockFormat();
-		blockFormat.setProperty(QTextFormat::BlockTrailingHorizontalRulerWidth, QVariant(true));
-		cursor.clearSelection();
-		cursor.setBlockFormat(blockFormat);
-	}
-
 public:
 	void doTrackBar()
 	{
 		trackBar = false;
-
-		// save position, because our manipulations could change it
-		int scrollbarValue = te_log()->verticalScrollBar()->value();
-
-		QTextCursor cursor = te_log()->textCursor();
-		cursor.beginEditBlock();
-		PsiRichText::Selection selection = PsiRichText::saveSelection(te_log(), cursor);
-
-		removeTrackBar(cursor);
-		addTrackBar(cursor);
-
-		PsiRichText::restoreSelection(te_log(), cursor, selection);
-		cursor.endEditBlock();
-		te_log()->setTextCursor(cursor);
-
-		te_log()->verticalScrollBar()->setValue(scrollbarValue);
+		te_log()->doTrackBar();
 	}

 public:
@@ -633,7 +562,6 @@ GCMainDlg::GCMainDlg(PsiAccount *pa, con
 	: TabbableWidget(j.bare(), pa, tabManager)
 {
 	setAttribute(Qt::WA_DeleteOnClose);
-	nicknumber=0;
 	d = new Private(this);
 	d->self = d->prev_self = j.resource();
 	account()->dialogRegister(this, jid());
@@ -660,6 +588,10 @@ GCMainDlg::GCMainDlg(PsiAccount *pa, con
 	ui_.setupUi(this);
 	ui_.lb_ident->setAccount(account());
 	ui_.lb_ident->setShowJid(false);
+	ui_.log->setSessionData(true, jid().full(), jid().full()); //FIXME change conference name
+#ifdef WEBKIT
+	ui_.log->setAccount(account());
+#endif

 	connect(ui_.pb_topic, SIGNAL(clicked()), SLOT(doTopic()));
 	PsiToolTip::install(ui_.le_topic);
@@ -674,7 +606,8 @@ GCMainDlg::GCMainDlg(PsiAccount *pa, con
 	ui_.tb_emoticons->setIcon(IconsetFactory::icon("psi/smile").icon());

 #ifdef Q_WS_MAC
-	connect(ui_.log, SIGNAL(selectionChanged()), SLOT(logSelectionChanged()));
+	// seems its useless hack
+	//connect(ui_.log, SIGNAL(selectionChanged()), SLOT(logSelectionChanged()));
 #endif

 	ui_.lv_users->setMainDlg(this);
@@ -733,6 +666,7 @@ GCMainDlg::GCMainDlg(PsiAccount *pa, con
 	ui_.mini_prompt->hide();
 	connect(ui_.mle, SIGNAL(textEditCreated(QTextEdit*)), SLOT(chatEditCreated()));
 	chatEditCreated();
+	ui_.log->init(); //here is we ready to do that

 	d->pm_settings = new QMenu(this);
 	connect(d->pm_settings, SIGNAL(aboutToShow()), SLOT(buildMenu()));
@@ -810,12 +744,12 @@ void GCMainDlg::setShortcuts()

 void GCMainDlg::scrollUp()
 {
-	ui_.log->verticalScrollBar()->setValue(ui_.log->verticalScrollBar()->value() - ui_.log->verticalScrollBar()->pageStep()/2);
+	ui_.log->scrollUp();
 }

 void GCMainDlg::scrollDown()
 {
-	ui_.log->verticalScrollBar()->setValue(ui_.log->verticalScrollBar()->value() + ui_.log->verticalScrollBar()->pageStep()/2);
+	ui_.log->scrollDown();
 }

 void GCMainDlg::closeEvent(QCloseEvent *e)
@@ -866,10 +800,11 @@ void GCMainDlg::logSelectionChanged()
 {
 #ifdef Q_WS_MAC
 	// A hack to only give the message log focus when text is selected
-	if (ui_.log->textCursor().hasSelection())
-		ui_.log->setFocus();
-	else
-		ui_.mle->chatEdit()->setFocus();
+// seems its already useless. at least copy works w/o this hack
+//	if (ui_.log->textCursor().hasSelection())
+//		ui_.log->setFocus();
+//	else
+//		ui_.mle->chatEdit()->setFocus();
 #endif
 }

@@ -1011,7 +946,7 @@ void GCMainDlg::doTopic()

 void GCMainDlg::doClear()
 {
-	ui_.log->setText("");
+	ui_.log->clear();
 }

 void GCMainDlg::doClearButton()
@@ -1026,7 +961,7 @@ void GCMainDlg::doClearButton()
 			)
 		) {
 		case QMessageBox::No:
-			break;
+		break;
 		case QMessageBox::YesAll:
 			PsiOptions::instance()->setOption("options.ui.chat.warn-before-clear", false);
 			// fall-through
@@ -1066,7 +1001,7 @@ void GCMainDlg::configureRoom()
 void GCMainDlg::doFind(const QString &str)
 {
 	d->lastSearch = str;
-	if (d->internalFind(str))
+	if (d->te_log()->internalFind(str))
 		d->findDlg->found();
 	else
 		d->findDlg->error(str);
@@ -1194,7 +1129,7 @@ void GCMainDlg::mucKickMsgHelper(const Q
 	if (!s.mucItem().reason().isEmpty()) {
 		message += QString(" (%1)").arg(s.mucItem().reason());
 	}
-	appendSysMsg(message, false, QDateTime::currentDateTime());
+	appendSysMsg(message);
 }

 void GCMainDlg::presence(const QString &nick, const Status &s)
@@ -1208,7 +1143,7 @@ void GCMainDlg::presence(const QString &
 		else {
 			message = tr("An error occurred (errorcode: %1)").arg(s.errorCode());
 		}
-		appendSysMsg(message, false, QDateTime::currentDateTime());
+		appendSysMsg(message);
 		return;
 	}

@@ -1228,7 +1163,7 @@ void GCMainDlg::presence(const QString &
 	if(s.isAvailable()) {
 		// Available
 		if (s.getMUCStatuses().contains(201)) {
-			appendSysMsg(tr("New room created"), false, QDateTime::currentDateTime());
+			appendSysMsg(tr("New room created"));
 			if (options_->getOption("options.muc.accept-defaults").toBool()) {
 				d->mucManager->setDefaultConfiguration();
 			} else if (options_->getOption("options.muc.auto-configure").toBool()) {
@@ -1260,7 +1195,7 @@ void GCMainDlg::presence(const QString &
 				} else {
 					message = message.arg(nick);
 				}
-				appendSysMsg(message, false, QDateTime::currentDateTime());
+				appendSysMsg(message);
 			}
 		}
 		else {
@@ -1280,23 +1215,18 @@ void GCMainDlg::presence(const QString &
 				}

 				if (!message.isEmpty()) {
-					appendSysMsg(message, false, QDateTime::currentDateTime());
+					appendSysMsg(message);
 				}
 			}
 			if ( !d->connecting && options_->getOption("options.muc.show-status-changes").toBool() ) {
 				if (s.status() != contact->s.status() || s.show() != contact->s.show())	{
-					QString message;
 					QString st;
 					if (s.show().isEmpty()) {
 						st=tr("online");
 					} else {
 						st=s.show();
 					}
-					message = tr("%1 is now %2").arg(nick).arg(st);
-					if (!s.status().isEmpty()) {
-						message+=QString(" (%1)").arg(s.status());
-					}
-					appendSysMsg(message, false, QDateTime::currentDateTime());
+					ui_.log->dispatchMessage(MessageView::statusMessage(nick, (int)s.type(), s.status()));
 				}
 			}
 		}
@@ -1325,7 +1255,7 @@ void GCMainDlg::presence(const QString &
 			else {
 				QMessageBox::information(this,tr("Room Destroyed"), message);
 			}
-			appendSysMsg(log, false, QDateTime::currentDateTime());
+			appendSysMsg(log);
 			goForcedLeave();
 		}

@@ -1385,7 +1315,7 @@ void GCMainDlg::presence(const QString &
 					message += QString(" (%1)").arg(s.status());
 				}
 			}
-			appendSysMsg(message, false, QDateTime::currentDateTime());
+			appendSysMsg(message);
 		}
 		ui_.lv_users->removeEntry(nick);
 	}
@@ -1416,18 +1346,33 @@ void GCMainDlg::message(const Message &_
 		d->nonAnonymous = false;
 	}

-
 	if(!m.subject().isNull()) {
-		ui_.le_topic->setText(m.subject());
+		QString subject = m.subject();
+		d->topic = subject;
+		QString subjectTooltip = TextUtil::plain2rich(subject);
+		subjectTooltip = TextUtil::linkify(subjectTooltip);
+		if(PsiOptions::instance()->getOption("options.ui.emoticons.use-emoticons").toBool()) {
+			subjectTooltip = TextUtil::emoticonify(subjectTooltip);
+		}
+		ui_.le_topic->setText(subject.replace("\n\n", " || ").replace("\n", " | ").replace("\t", " ").replace(QRegExp("\\s{2,}"), " "));
 		ui_.le_topic->setCursorPosition(0);
-		ui_.le_topic->setToolTip(QString("<qt><p>%1</p></qt>").arg(m.subject()));
-		if(m.body().isEmpty()) {
-			if (!from.isEmpty())
-				m.setBody(QString("/me ") + tr("has set the topic to: %1").arg(m.subject()));
-			else
-				// The topic was set by the server
-				m.setBody(tr("The topic has been set to: %1").arg(m.subject()));
+		ui_.le_topic->setToolTip(QString("<qt><p>%1</p></qt>").arg(subjectTooltip));
+
+		QString sysMsg;
+		if (from.isEmpty()) {
+			// The topic was set by the server
+			// ugly trick
+			int btStart = m.body().indexOf(d->topic);
+			sysMsg = btStart > 0?m.body().left(btStart).remove(": "):tr("The topic has been set to");
+		} else {
+			sysMsg = QString(from) + (d->topic.isEmpty()?
+						 tr(" has unset the topic"):tr(" has set the topic to"));
 		}
+		MessageView tv = MessageView::subjectMessage(d->topic, sysMsg);
+		tv.setDateTime(m.timeStamp());
+		appendSysMsg(tv);
+		//ui_.log->dispatchMessage(tv);
+		return;
 	}

 	if(m.body().isEmpty())
@@ -1460,7 +1405,7 @@ void GCMainDlg::message(const Message &_
 	}

 	if(from.isEmpty())
-		appendSysMsg(m.body(), alert, m.timeStamp(), true);
+		appendSysMsg(m.body(), alert, m.timeStamp());
 	else
 		appendMessage(m, alert);
 }
@@ -1487,144 +1432,57 @@ const QString& GCMainDlg::nick() const
 	return d->self;
 }

-void GCMainDlg::updateLastMsgTime(QDateTime t)
+void GCMainDlg::appendSysMsg(const QString &str, bool alert, const QDateTime &ts)
 {
-	bool doInsert = t.date() != lastMsgTime_.date();
-	lastMsgTime_ = t;
-	if (doInsert) {
-		QString color = ColorOpt::instance()->color("options.ui.look.colors.messages.informational").name();
-		ui_.log->appendText(QString("<font color=\"%1\">*** %2</font>").arg(color).arg(t.date().toString(Qt::ISODate)));
+	MessageView mv = MessageView::fromPlainText(str, MessageView::System);
+	if (!PsiOptions::instance()->getOption("options.ui.muc.use-highlighting").toBool()) {
+		alert = false;
+	}
+	mv.setAlert(alert);
+	if(!ts.isNull()) {
+		mv.setDateTime(ts);
 	}
+	appendSysMsg(mv);
 }

-void GCMainDlg::appendSysMsg(const QString &str, bool alert, const QDateTime &ts, bool prepareAsChatMessage)
-{
-	// FIXME:
-	//  prepareAsChatMessage was added to linkify server-generated topic information.
-	//  First idea was to linkify, etc, every SysMsg, but that leads to problems,
-	//  such as parsing full JIDs of participants joining a non-anonymous room as
-	//  emails and looking ugly.
-	//  Possibly a better way would be to change this function to something like
-	//  appendSysMsg(nick, jid, message, alert, ts)
-	//  or maybe even separate functions for different types of system messages.
-
+void GCMainDlg::appendSysMsg(const MessageView &mv)
+{
 	if (d->trackBar)
 		d->doTrackBar();

-	if (!PsiOptions::instance()->getOption("options.ui.muc.use-highlighting").toBool())
-		alert=false;
-
-	QDateTime time = QDateTime::currentDateTime();
-	if(!ts.isNull())
-		time = ts;
-
-	updateLastMsgTime(time);
-	QString timestr = ui_.log->formatTimeStamp(time);
-	QString color = ColorOpt::instance()->color("options.ui.look.colors.messages.informational").name();
-	ui_.log->appendText(QString("<font color=\"%1\">[%2]").arg(color, timestr) +
-		QString(" *** %1</font>").arg(prepareAsChatMessage ? TextUtil::prepareMessageText(str) : Qt::escape(str)));
+	ui_.log->dispatchMessage(mv);

-	if(alert)
+	if(mv.isAlert())
 		doAlert();
 }

-QString GCMainDlg::getNickColor(QString nick)
-{
-	int sender;
-	if(nick == d->self||nick.isEmpty())
-		sender = -1;
-	else {
-		if (!nicks.contains(nick)) {
-			//not found in map
-			nicks.insert(nick,nicknumber);
-			nicknumber++;
-		}
-		sender=nicks[nick];
-	}
-
-	QStringList nickColors = PsiOptions::instance()->getOption("options.ui.look.colors.muc.nick-colors").toStringList();
-
-	if(!PsiOptions::instance()->getOption("options.ui.muc.use-nick-coloring").toBool() || nickColors.empty()) {
-		return "#000000";
-	}
-	else if(sender == -1 || nickColors.size() == 1) {
-		return nickColors[nickColors.size()-1];
-	}
-	else {
-		int n = sender % (nickColors.size()-1);
-		return nickColors[n];
-	}
-}
-
 void GCMainDlg::appendMessage(const Message &m, bool alert)
 {
-	updateLastMsgTime(m.timeStamp());
-	//QString who, color;
+	MessageView mv(MessageView::Message);
+	if (m.containsHTML() && PsiOptions::instance()
+							->getOption("options.html.muc.render").toBool() &&
+							!m.html().text().isEmpty()) {
+		mv.setHtml(m.html().toString("span"));
+	} else {
+		mv.setPlainText(m.body());
+	}
 	if (!PsiOptions::instance()->getOption("options.ui.muc.use-highlighting").toBool())
 		alert=false;
-	QString who, textcolor, nickcolor,alerttagso,alerttagsc;
+	mv.setAlert(alert);
+	mv.setUserId(m.from().full());
+	mv.setNick(m.from().resource());
+	mv.setLocal(mv.nick() == d->self);
+	mv.setSpooled(m.spooled());
+	mv.setDateTime(m.timeStamp());

-	who = m.from().resource();
-	if (d->trackBar&&m.from().resource() != d->self&&!m.spooled())
+	if (d->trackBar && !mv.isLocal() && !mv.isSpooled()) {
 		d->doTrackBar();
-	/*if(local) {
-		color = "#FF0000";
 	}
-	else {
-		color = "#0000FF";
-	}*/
-	nickcolor = getNickColor(who);
-	textcolor = ui_.log->palette().windowText().color().name();
-	if(alert) {
-		textcolor = "#FF0000";
-		alerttagso = "<b>";
-		alerttagsc = "</b>";
-	}
-	if(m.spooled()) {
-		nickcolor = ColorOpt::instance()->color("options.ui.look.colors.messages.informational").name();
-	}
-
-	QString timestr = ui_.log->formatTimeStamp(m.timeStamp());
-
-	bool emote = false;
-	if(m.body().left(4) == "/me ")
-		emote = true;
-
-	QString txt;
-	if(emote)
-		txt = TextUtil::plain2rich(m.body().mid(4));
-	else
-		txt = TextUtil::plain2rich(m.body());
-
-	txt = TextUtil::linkify(txt);

-	if(PsiOptions::instance()->getOption("options.ui.emoticons.use-emoticons").toBool())
-		txt = TextUtil::emoticonify(txt);
-	if( PsiOptions::instance()->getOption("options.ui.chat.legacy-formatting").toBool() )
-		txt = TextUtil::legacyFormat(txt);
-
-	if(emote) {
-		//ui_.log->append(QString("<font color=\"%1\">").arg(color) + QString("[%1]").arg(timestr) + QString(" *%1 ").arg(Qt::escape(who)) + txt + "</font>");
-		ui_.log->appendText(QString("<font color=\"%1\">").arg(nickcolor) + QString("[%1]").arg(timestr) + QString(" *%1 ").arg(Qt::escape(who)) + alerttagso + txt + alerttagsc + "</font>");
-	}
-	else {
-		if(PsiOptions::instance()->getOption("options.ui.chat.use-chat-says-style").toBool()) {
-			//ui_.log->append(QString("<font color=\"%1\">").arg(color) + QString("[%1] ").arg(timestr) + QString("%1 says:").arg(Qt::escape(who)) + "</font><br>" + txt);
-			ui_.log->appendText(QString("<font color=\"%1\">").arg(nickcolor) + QString("[%1] ").arg(timestr) + QString("%1 says:").arg(Qt::escape(who)) + "</font><br>" + QString("<font color=\"%1\">").arg(textcolor) + alerttagso + txt + alerttagsc + "</font>");
-		}
-		else {
-			//ui_.log->append(QString("<font color=\"%1\">").arg(color) + QString("[%1] &lt;").arg(timestr) + Qt::escape(who) + QString("&gt;</font> ") + txt);
-			ui_.log->appendText(QString("<font color=\"%1\">").arg(nickcolor) + QString("[%1] &lt;").arg(timestr) + Qt::escape(who) + QString("&gt;</font> ") + QString("<font color=\"%1\">").arg(textcolor) + alerttagso + txt + alerttagsc +"</font>");
-		}
-	}
-
-	//if(local)
-	if(m.from().resource() == d->self) {
-		d->deferredScroll();
-	}
+	ui_.log->dispatchMessage(mv);

 	// if we're not active, notify the user by changing the title
-	if(!isActiveTab() && (who != d->self)) {
+	if(!isActiveTab() && !mv.isLocal()) {
 		++d->pending;
 		invalidateTab();
 	}
--- psi.orig/src/groupchatdlg.h
+++ psi/src/groupchatdlg.h
@@ -39,6 +39,7 @@ class PsiAccount;
 class PsiOptions;
 class QRect;
 class GCMainDlg;
+class MessageView;
 class QColorGroup;
 namespace XMPP {
 	class Message;
@@ -136,9 +137,9 @@ private:
 	Ui::GroupChatDlg ui_;

 	void doAlert();
-	void appendSysMsg(const QString &, bool, const QDateTime &ts=QDateTime(), bool prepareAsChatMessage=false);
+	void appendSysMsg(const QString &, bool alert=false, const QDateTime &ts=QDateTime());
+	void appendSysMsg(const MessageView &);
 	void appendMessage(const Message &, bool);
-	void updateLastMsgTime(QDateTime t);
 	void setLooks();

 	void mucKickMsgHelper(const QString &nick, const Status &s, const QString &nickJid, const QString &title,
@@ -147,9 +148,6 @@ private:

 	void contextMenuEvent(QContextMenuEvent *);

-	QString getNickColor(QString);
-	QMap<QString,int> nicks;
-	int nicknumber;
 	PsiOptions* options_;
 	QDateTime lastMsgTime_;
 };
--- psi.orig/src/groupchatdlg.ui
+++ psi/src/groupchatdlg.ui
@@ -180,9 +180,6 @@
           <property name="focusPolicy" >
            <enum>Qt::NoFocus</enum>
           </property>
-          <property name="readOnly" >
-           <bool>true</bool>
-          </property>
          </widget>
          <widget class="GCUserView" name="lv_users" >
           <property name="minimumSize" >
@@ -292,8 +289,8 @@
   </customwidget>
   <customwidget>
    <class>ChatView</class>
-   <extends>QTextEdit</extends>
-   <header>msgmle.h</header>
+   <extends>QFrame</extends>
+   <header>chatview.h</header>
   </customwidget>
   <customwidget>
    <class>ChatEditProxy</class>
--- psi.orig/src/jsutil.cpp
+++ psi/src/jsutil.cpp
@@ -0,0 +1,81 @@
+/*
+ * jsutil.cpp
+ * Copyright (C) 2009  Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include "jsutil.h"
+#include <QStringList>
+#include <QDateTime>
+
+QString JSUtil::map2json(const QVariantMap &map)
+{
+	QStringList ret;
+	QMapIterator<QString, QVariant> i(map);
+	while (i.hasNext()) {
+		i.next();
+		ret.append(QString("\"%1\":").arg(escapeStringCopy(i.key())) +
+				   variant2js(i.value()));
+	}
+	return QString("{%1}").arg(ret.join(","));
+}
+
+QString JSUtil::variant2js(const QVariant &value)
+{
+	QString strVal;
+	switch (value.type()) {
+		case QVariant::String:
+		case QVariant::Color:
+			strVal = value.toString();
+			escapeString(strVal);
+			strVal = QString("\"%1\"").arg(strVal);
+			break;
+		case QVariant::StringList:
+			{
+				QStringList sl = value.toStringList();
+				for (int i=0; i<sl.count(); i++) {
+					escapeString(sl[i]);
+					sl[i] = QString("\"%1\"").arg(sl[i]);
+				}
+				strVal = QString("[%1]").arg(sl.join(","));
+			}
+			break;
+		case QVariant::DateTime:
+			strVal = QString("new Date(%1)").arg(value.toDateTime().toString("yyyy,M-1,d,h,m,s"));
+			break;
+		case QVariant::Date:
+			strVal = QString("new Date(%1)").arg(value.toDate().toString("yyyy,M-1,d"));
+			break;
+		case QVariant::Map:
+			strVal = map2json(value.toMap());
+			break;
+		default:
+			strVal = value.toString();
+	}
+	return strVal;
+}
+
+void JSUtil::escapeString(QString& str)
+{
+
+	str.replace("\r\n", "\n");  //windows
+	str.replace("\r", "\n");    //mac
+	str.replace("\\", "\\\\");
+	str.replace("\"", "\\\"");
+	str.replace("\n", "\\\n");
+	str.replace(QChar(8232), "\\\n"); //ctrl+enter
+}
--- psi.orig/src/jsutil.h
+++ psi/src/jsutil.h
@@ -0,0 +1,46 @@
+/*
+ * jsutil.h
+ * Copyright (C) 2009  Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef JSUTIL
+#define JSUTIL
+
+class QString;
+class QVariant;
+
+#include <QVariantMap>
+
+class JSUtil
+{
+public:
+	static QString map2json(const QVariantMap &);
+	static QString variant2js(const QVariant &);
+	/** Escapes " and \n  (for JS evaluation) */
+	static void escapeString(QString &str);
+
+	/** Escapes " and \n  (for JS evaluation) [overload] */
+	static inline QString escapeStringCopy(QString str)
+	{
+		escapeString(str);
+		return str;
+	}
+};
+
+
+#endif
--- psi.orig/src/messageview.cpp
+++ psi/src/messageview.cpp
@@ -0,0 +1,183 @@
+/*
+ * messageview.cpp - message data for chatview
+ * Copyright (C) 2010 Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include "messageview.h"
+#include "textutil.h"
+#include "psioptions.h"
+#include "common.h"
+
+#include <QTextDocument>
+
+static const QString me_cmd = "/me ";
+
+MessageView::MessageView(Type t)
+	: _type(t)
+	, _emote(false)
+	, _alert(false)
+	, _local(false)
+	, _spooled(false)
+	, _status(0)
+	, _dateTime(QDateTime::currentDateTime())
+{
+
+}
+
+MessageView MessageView::fromPlainText(const QString &text, Type type)
+{
+	MessageView mv(type);
+	mv.setPlainText(text);
+	return mv;
+}
+
+MessageView MessageView::fromHtml(const QString &text, Type type)
+{
+	MessageView mv(type);
+	mv.setHtml(text);
+	return mv;
+}
+
+MessageView MessageView::urlsMessage(const QMap<QString, QString> &urls)
+{
+	MessageView mv(Urls);
+	mv._type = Urls;
+	mv._urls = urls;
+	return mv;
+}
+
+MessageView MessageView::subjectMessage(const QString &subject, const QString &prefix)
+{
+	MessageView mv(Subject);
+	mv._text = Qt::escape(prefix);
+	mv._userText = subject;
+	return mv;
+}
+
+MessageView MessageView::statusMessage(const QString &nick, int status,
+									   const QString &statusText)
+{
+	MessageView mv = MessageView::fromPlainText(QObject::tr("%1 is now %2")
+												.arg(nick, status2txt(status)),
+												Status);
+	mv.setNick(nick);
+	mv.setStatus(status);
+	mv.setUserText(statusText);
+	return mv;
+}
+
+// getters and setters
+
+void MessageView::setPlainText(const QString &text)
+{
+	if (!text.isEmpty()) {
+		if (_type == Message) {
+			_emote = text.startsWith(me_cmd);
+		}
+		_text = TextUtil::plain2rich(text);
+		if (_type == Message) {
+			_text = TextUtil::linkify(_text);
+		}
+	}
+}
+
+void MessageView::setHtml(const QString &text)
+{
+	if (_type == Message) {
+		_emote = text.trimmed().startsWith(me_cmd);
+	}
+	_text = text;
+}
+
+QString MessageView::formattedText() const
+{
+	QString txt = _text;
+
+	if (_emote && _type == Message) {
+		int cmd = txt.indexOf(me_cmd);
+		txt = txt.remove(cmd, me_cmd.length());
+	}
+	if (PsiOptions::instance()->getOption("options.ui.emoticons.use-emoticons").toBool())
+		txt = TextUtil::emoticonify(txt);
+	if (PsiOptions::instance()->getOption("options.ui.chat.legacy-formatting").toBool())
+		txt = TextUtil::legacyFormat(txt);
+
+	return txt;
+}
+
+QString MessageView::formattedUserText() const
+{
+	if (!_userText.isEmpty()) {
+		QString text = TextUtil::plain2rich(_userText);
+		text = TextUtil::linkify(text);
+		if (PsiOptions::instance()->getOption("options.ui.emoticons.use-emoticons").toBool())
+			text = TextUtil::emoticonify(text);
+		if (PsiOptions::instance()->getOption("options.ui.chat.legacy-formatting").toBool())
+			text = TextUtil::legacyFormat(text);
+		return text;
+	}
+	return "";
+}
+
+QVariantMap MessageView::toVariantMap(bool isMuc, bool formatted) const
+{
+	static QHash<Type, QString> types;
+	if (types.isEmpty()) {
+		types.insert(Message,	"message");
+		types.insert(System,	"system");
+		types.insert(Status,	"status");
+		types.insert(Subject,	"subject");
+		types.insert(Urls,		"urls");
+	}
+	QVariantMap m;
+	m["time"] = _dateTime;
+	m["type"] = types.value(_type);
+	switch (_type) {
+		case Message:
+			m["message"] = formatted?formattedText():_text;
+			m["emote"] = _emote;
+			m["local"] = _local;
+			m["sender"] = _nick;
+			m["userid"] = _userId;
+			m["spooled"] = _spooled;
+			m["id"] = _messageId;
+			if (isMuc) { // maybe w/o conditions ?
+				m["alert"] = _alert;
+			}
+			break;
+		case Status:
+			m["sender"] = _nick;
+			m["status"] = _status;
+			m["message"] = _text;
+			m["usertext"] = formatted?formattedUserText():_userText;
+			break;
+		case System:
+		case Subject:
+			m["message"] = formatted?formattedText():_text;
+			m["usertext"] = formatted?formattedUserText():_userText;
+			break;
+		case Urls:
+			QVariantMap vmUrls;
+			foreach (const QString &u, _urls.keys()) {
+				vmUrls[u] = _urls.value(u);
+			}
+			m["urls"] = vmUrls;
+			break;
+	}
+	return m;
+}
--- psi.orig/src/messageview.h
+++ psi/src/messageview.h
@@ -0,0 +1,106 @@
+/*
+ * messageview.h - message data for chatview
+ * Copyright (C) 2010 Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef MESSAGEVIEW_H
+#define MESSAGEVIEW_H
+
+#include <QDateTime>
+#include <QVariantMap>
+
+class MessageView
+{
+public:
+	enum Type {
+		Message,
+		System,
+		Status,
+		Subject,
+		Urls
+	};
+
+	enum SystemMessageType {
+		MUCJoin,
+		MUCPart,
+		FileTransferRequest,
+		FileTransferFinished
+	};
+
+	MessageView(Type);
+
+	static MessageView fromPlainText(const QString &, Type);
+	static MessageView fromHtml(const QString &, Type);
+	static MessageView urlsMessage(const QMap<QString, QString> &);
+	static MessageView subjectMessage(const QString &subject,
+									  const QString &prefix = QString());
+
+	// accepts plain/text nick, plain/text status and rich/text statusText
+	static MessageView statusMessage(const QString &nick, int status,
+									 const QString &statusText = QString());
+
+	inline Type type() const { return _type; }
+	inline const QString &text() const { return _text; }
+	inline void setText(const QString &text) { _text = text; }
+	inline const QString &userText() const { return _userText; }
+	inline void setUserText(const QString &text) { _userText = text; }
+
+	void setPlainText(const QString &);
+	void setHtml(const QString &);
+	QString formattedText() const;
+	QString formattedUserText() const;
+
+	inline void setAlert(bool state) { _alert = state; }
+	inline bool isAlert() const { return _alert; }
+	inline void setLocal(bool state) { _local = state; }
+	inline bool isLocal() const { return _local; }
+	inline void setEmote(bool state) { _emote = state; }
+	inline bool isEmote() const { return _emote; }
+	inline void setSpooled(bool state) { _spooled = state; }
+	inline bool isSpooled() const { return _spooled; }
+	inline void setStatus(int s) { _status = s; }
+	inline int status() const { return _status; }
+	inline void setNick(const QString &nick) { _nick = nick; }
+	inline const QString &nick() const { return _nick; }
+	inline void setMessageId(const QString &id) { _messageId = id; }
+	inline const QString &messageId() const { return _messageId; }
+	inline void setUserId(const QString &id) { _userId = id; }
+	inline const QString &userId() const { return _userId; }
+	inline void setDateTime(const QDateTime &dt) { _dateTime = dt; }
+	inline const QDateTime &dateTime() const { return _dateTime; }
+	inline QMap<QString, QString> urls() const { return _urls; }
+
+	QVariantMap toVariantMap(bool isMuc, bool formatted = false) const;
+
+private:
+	Type _type;
+	bool _emote;
+	bool _alert;
+	bool _local;
+	bool _spooled;
+	int _status;
+	QString _messageId;
+	QString _userId;
+	QString _nick; // rich / as is
+	QString _text; // always rich (plain text converted to rich)
+	QString _userText; // rich
+	QDateTime _dateTime;
+	QMap<QString, QString> _urls;
+};
+
+#endif
--- psi.orig/src/msgmle.cpp
+++ psi/src/msgmle.cpp
@@ -29,11 +29,9 @@
 #include <QLayout>
 #include <QMenu>
 #include <QResizeEvent>
-#include <QScrollBar>
 #include <QTextCharFormat>
 #include <QTextDocument>
 #include <QTimer>
-#include <QDateTime>

 #include "shortcutmanager.h"
 #include "spellchecker/spellhighlighter.h"
@@ -41,135 +39,6 @@
 #include "psioptions.h"

 //----------------------------------------------------------------------------
-// ChatView
-//----------------------------------------------------------------------------
-ChatView::ChatView(QWidget *parent)
-	: PsiTextView(parent)
-	, dialog_(0)
-{
-	setWordWrapMode(QTextOption::WrapAtWordBoundaryOrAnywhere);
-
-	setReadOnly(true);
-	setUndoRedoEnabled(false);
-	setHorizontalScrollBarPolicy(Qt::ScrollBarAlwaysOff);
-
-#ifndef Q_WS_X11	// linux has this feature built-in
-	connect(this, SIGNAL(selectionChanged()), SLOT(autoCopy()));
-	connect(this, SIGNAL(cursorPositionChanged()), SLOT(autoCopy()));
-#endif
-}
-
-ChatView::~ChatView()
-{
-}
-
-void ChatView::setDialog(QWidget* dialog)
-{
-	dialog_ = dialog;
-}
-
-QSize ChatView::sizeHint() const
-{
-	return minimumSizeHint();
-}
-
-bool ChatView::focusNextPrevChild(bool next)
-{
-	return QWidget::focusNextPrevChild(next);
-}
-
-void ChatView::keyPressEvent(QKeyEvent *e)
-{
-/*	if(e->key() == Qt::Key_Escape)
-		e->ignore();
-#ifdef Q_WS_MAC
-	else if(e->key() == Qt::Key_W && e->modifiers() & Qt::ControlModifier)
-		e->ignore();
-	else
-#endif
-	else if(e->key() == Qt::Key_Return && ((e->modifiers() & Qt::ControlModifier) || (e->modifiers() & Qt::AltModifier)) )
-		e->ignore();
-	else if(e->key() == Qt::Key_H && (e->modifiers() & Qt::ControlModifier))
-		e->ignore();
-	else if(e->key() == Qt::Key_I && (e->modifiers() & Qt::ControlModifier))
-		e->ignore(); */
-	/*else*/ if(e->key() == Qt::Key_M && (e->modifiers() & Qt::ControlModifier) && !isReadOnly()) // newline
-		append("\n");
-/*	else if(e->key() == Qt::Key_U && (e->modifiers() & Qt::ControlModifier) && !isReadOnly())
-		setText(""); */
-	else if ((e->key() == Qt::Key_Return || e->key() == Qt::Key_Enter) && ((e->modifiers() & Qt::ControlModifier) || (e->modifiers() & Qt::AltModifier))) {
-		e->ignore();
-	}
-	else {
-		PsiTextView::keyPressEvent(e);
-	}
-}
-
-/**
- * Copies any selected text to the clipboard
- * if autoCopy is enabled and ChatView is in read-only mode.
- */
-void ChatView::autoCopy()
-{
-	if (isReadOnly() && PsiOptions::instance()->getOption("options.ui.automatically-copy-selected-text").toBool()) {
-		copy();
-	}
-}
-
-/**
- * Handle KeyPress events that happen in ChatEdit widget. This is used
- * to 'fix' the copy shortcut.
- * \param object object that should receive the event
- * \param event received event
- * \param chatEdit pointer to the dialog's ChatEdit widget that receives user input
- */
-bool ChatView::handleCopyEvent(QObject *object, QEvent *event, ChatEdit *chatEdit)
-{
-	if (object == chatEdit && event->type() == QEvent::KeyPress) {
-		QKeyEvent *e = (QKeyEvent *)event;
-		if ((e->key() == Qt::Key_C && (e->modifiers() & Qt::ControlModifier)) ||
-		    (e->key() == Qt::Key_Insert && (e->modifiers() & Qt::ControlModifier)))
-		{
-			if (!chatEdit->textCursor().hasSelection() &&
-			     this->textCursor().hasSelection())
-			{
-				this->copy();
-				return true;
-			}
-		}
-	}
-
-	return false;
-}
-
-void ChatView::appendText(const QString &text)
-{
-	bool doScrollToBottom = atBottom();
-
-	// prevent scrolling back to selected text when
-	// restoring selection
-	int scrollbarValue = verticalScrollBar()->value();
-
-	PsiTextView::appendText(text);
-
-	if (doScrollToBottom)
-		scrollToBottom();
-	else
-		verticalScrollBar()->setValue(scrollbarValue);
-}
-
-/**
- * \brief Common function for ChatDlg and GCMainDlg. FIXME: Extract common
- * chat window from both dialogs and move this function to that class.
- */
-QString ChatView::formatTimeStamp(const QDateTime &time)
-{
-	// TODO: provide an option for user to customize
-	// time stamp format
-	return QString().sprintf("%02d:%02d:%02d", time.time().hour(), time.time().minute(), time.time().second());;
-}
-
-//----------------------------------------------------------------------------
 // ChatEdit
 //----------------------------------------------------------------------------
 ChatEdit::ChatEdit(QWidget *parent)
--- psi.orig/src/msgmle.h
+++ psi/src/msgmle.h
@@ -23,8 +23,6 @@

 #include <QTextEdit>

-#include "psitextview.h"
-
 class ChatEdit;
 class QEvent;
 class QKeyEvent;
@@ -32,34 +30,6 @@ class QResizeEvent;
 class QTimer;
 class SpellHighlighter;

-class ChatView : public PsiTextView
-{
-	Q_OBJECT
-public:
-	ChatView(QWidget* parent);
-	~ChatView();
-
-	void setDialog(QWidget* dialog);
-
-	// reimplemented
-	QSize sizeHint() const;
-
-	void appendText(const QString &text);
-	bool handleCopyEvent(QObject *object, QEvent *event, ChatEdit *chatEdit);
-
-	QString formatTimeStamp(const QDateTime &time);
-
-protected:
-	// override the tab/esc behavior
-	bool focusNextPrevChild(bool next);
-	void keyPressEvent(QKeyEvent *);
-
-protected slots:
-	void autoCopy();
-
-private:
-	QWidget* dialog_;
-};

 class ChatEdit : public QTextEdit
 {
--- psi.orig/src/networkaccessmanager.cpp
+++ psi/src/networkaccessmanager.cpp
@@ -0,0 +1,116 @@
+/*
+ * networkaccessmanager.cpp - Network Manager for WebView able to process
+ * custom url schemas
+ * Copyright (C) 2010 senu, Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include "networkaccessmanager.h"
+
+#include "bytearrayreply.h"
+#include <QCoreApplication>
+
+NetworkAccessManager::NetworkAccessManager(QObject *parent)
+: QNetworkAccessManager(parent) {
+	setParent(QCoreApplication::instance());
+}
+
+
+NetworkAccessManager::~NetworkAccessManager() {
+	schemeHandlers_.clear();
+}
+
+
+QNetworkReply * NetworkAccessManager::createRequest(Operation op, const QNetworkRequest & req, QIODevice * outgoingData = 0) {
+    //download local file
+	//qDebug("url: %s", qPrintable(req.url().toString()));
+	if (req.url().scheme() == "file" || req.url().scheme() == "data") {
+		return QNetworkAccessManager::createRequest(op, req, outgoingData);
+    }
+
+	if (schemeHandlers_.contains(req.url().scheme())) {
+		ByteArrayReply *repl = new ByteArrayReply(
+					req,
+					schemeHandlers_.value(req.url().scheme())->data(req.url()),
+					QString(),
+					this);
+		connect(repl, SIGNAL(finished()), SLOT(callFinished()));
+		return repl;
+	}
+
+    //on whiteList?
+    whiteListMutex.lock();
+
+    bool whiteListed = whiteList.contains(req.url().toString());
+
+    whiteListMutex.unlock();
+
+    if (whiteListed) {
+        return QNetworkAccessManager::createRequest(op, req, outgoingData);
+    }
+
+	QNetworkReply * reply = new ByteArrayReply(req); //finishes with error
+    connect(reply, SIGNAL(finished()), SLOT(callFinished()));
+
+    return reply;
+}
+
+
+void NetworkAccessManager::callFinished() {
+    QNetworkReply *reply = qobject_cast<QNetworkReply *>(sender());
+
+    if (reply) {
+        emit finished(reply);
+    }
+}
+
+
+void NetworkAccessManager::addUrlToWhiteList(const QString& url) {
+
+    whiteListMutex.lock();
+    whiteList.append(url);
+    whiteListMutex.unlock();
+}
+
+QSharedPointer<NAMSchemeHandler> NetworkAccessManager::schemeHandler(const QString &scheme)
+{
+	if (schemeHandlers_.contains(scheme)) {
+		return schemeHandlers_.value(scheme);
+	}
+	return QSharedPointer<NAMSchemeHandler>();
+}
+
+void NetworkAccessManager::setSchemeHandler(const QString &scheme, NAMSchemeHandler *handler)
+{
+	if (schemeHandlers_.contains(scheme)) {
+		schemeHandlers_.remove(scheme);
+	}
+	schemeHandlers_.insert(scheme, QSharedPointer<NAMSchemeHandler>(handler));
+}
+
+/**
+ * Returns the singleton instance of this class
+ * \return Instance of NetworkAccessManager
+ */
+NetworkAccessManager* NetworkAccessManager::instance()
+{
+	if ( !instance_ )
+		instance_ = new NetworkAccessManager();
+	return instance_;
+}
+
+NetworkAccessManager* NetworkAccessManager::instance_ = NULL;
--- psi.orig/src/networkaccessmanager.h
+++ psi/src/networkaccessmanager.h
@@ -0,0 +1,93 @@
+/*
+ * networkaccessmanager.h - Network Manager for WebView able to process
+ * custom url schemas
+ * Copyright (C) 2010 senu, Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef _NETWORKACCESSMANAGER_H
+#define _NETWORKACCESSMANAGER_H
+
+#include <QNetworkAccessManager>
+#include <QStringList>
+#include <QSharedPointer>
+#include <QHash> //for qt-4.4
+#include <QMutex>
+
+#include <QNetworkReply>
+#include <QNetworkRequest>
+#include <QIODevice>
+
+class NetworkAccessManager;
+
+class NAMSchemeHandler {
+public:
+	virtual QByteArray data(const QUrl &) const = 0;
+};
+
+/** Blocks internet connections and allows to use icon:// URLs in webkit-based ChatViews*/
+class NetworkAccessManager : public QNetworkAccessManager {
+
+	Q_OBJECT
+public:
+	/**
+	 * Constructor.
+	 *
+	 * \param iconServer will be used to serve icon:// urls
+	 */
+	NetworkAccessManager(QObject *parent = 0);
+	~NetworkAccessManager();
+
+	/** Add URL to whiteList. */
+	void addUrlToWhiteList(const QString& url);
+	static NetworkAccessManager* instance();
+	QSharedPointer<NAMSchemeHandler> schemeHandler(const QString &);
+	void setSchemeHandler(const QString &, NAMSchemeHandler *);
+
+private slots:
+
+	/**
+	 * Called by QNetworkReply::finish().
+	 *
+	 * Emitts finish(reply)
+	 */
+	void callFinished();
+
+protected:
+	QNetworkReply* createRequest(Operation op, const QNetworkRequest & req, QIODevice * outgoingData);
+
+	/*
+	 * List of whitelisted URLs.
+	 *
+	 * Access to whitelisted URLs is not denied.
+	 */
+	QStringList whiteList;
+
+	/**
+	 * Mutal exclusion for whitList.
+	 *
+	 * WhiteList can be accessed by Webkit (createRequest())
+	 * and Psi (addUrlToWhiteList()) simultaneously)
+	 */
+	QMutex whiteListMutex;
+
+private:
+	static NetworkAccessManager* instance_;
+	QHash<QString, QSharedPointer<NAMSchemeHandler> > schemeHandlers_;
+};
+
+#endif
--- psi.orig/src/options/opt_appearance.cpp
+++ psi/src/options/opt_appearance.cpp
@@ -1,5 +1,6 @@
 #include "opt_appearance.h"
 #include "opt_iconset.h"
+#include "opt_theme.h"
 #include "common.h"
 #include "iconwidget.h"

@@ -21,6 +22,7 @@
 #include "ui_opt_appearance_misc.h"
 #include "psioptions.h"
 #include "coloropt.h"
+#include "psithememanager.h"


 class OptAppearanceUI : public QWidget, public Ui::OptAppearance
@@ -78,12 +80,25 @@ QSize FontLabel::sizeHint() const
 OptionsTabAppearance::OptionsTabAppearance(QObject *parent) : MetaOptionsTab(parent, "appearance", "", tr("Appearance"), tr("Psi's appearance"), "psi/appearance")
 {
 	addTab( new OptionsTabAppearanceGeneral(this) );
+	addTab( new OptionsTabIconset(this) );
+	if (PsiThemeManager::instance()->registeredProviders().count()) {
+		addTab( new OptionsTabAppearanceThemes(this) );
+	}
+	addTab( new OptionsTabAppearanceMisc(this) );
+}
+
+
+//----------------------------------------------------------------------------
+// OptionsTabIconset
+//----------------------------------------------------------------------------
+OptionsTabIconset::OptionsTabIconset(QObject *parent) : MetaOptionsTab(parent, "iconsets", "", tr("Icons"), tr("Icons"))
+{
 	addTab( new OptionsTabIconsetEmoticons(this) );
 	addTab( new OptionsTabIconsetRoster(this) );
 	addTab( new OptionsTabIconsetSystem(this) );
-	addTab( new OptionsTabAppearanceMisc(this) );
 }

+
 //----------------------------------------------------------------------------
 // OptionsTabAppearanceMisc
 //----------------------------------------------------------------------------
@@ -232,7 +247,9 @@ QWidget *OptionsTabAppearanceGeneral::wi
 		{d->ck_cAnimBack,        d->pb_cAnimBack,    "contactlist.status-change-animation2", ""},
 		{d->ck_cMessageSent,     d->pb_cMessageSent,     "messages.sent", ""},
 		{d->ck_cMessageReceived, d->pb_cMessageReceived, "messages.received", ""},
-		{d->ck_cSysMsg,          d->pb_cSysMsg,          "messages.informational", ""}
+		{d->ck_cSysMsg,          d->pb_cSysMsg,          "messages.informational", ""},
+		{d->ck_cUserText,        d->pb_cUserText,        "messages.usertext", ""}
+
 	};

 	bg_color = new QButtonGroup(this);
--- psi.orig/src/options/opt_appearance.h
+++ psi/src/options/opt_appearance.h
@@ -36,6 +36,13 @@ public:
 	OptionsTabAppearance(QObject *parent);
 };

+class OptionsTabIconset : public MetaOptionsTab
+{
+	Q_OBJECT
+public:
+	OptionsTabIconset(QObject *parent);
+};
+
 class OptionsTabAppearanceMisc : public OptionsTab
 {
 	Q_OBJECT
--- psi.orig/src/options/opt_appearance.ui
+++ psi/src/options/opt_appearance.ui
@@ -37,7 +37,7 @@
            <x>0</x>
            <y>0</y>
            <width>282</width>
-           <height>432</height>
+           <height>460</height>
           </rect>
          </property>
          <layout class="QGridLayout" name="gridLayout">
@@ -296,14 +296,14 @@
             </property>
            </widget>
           </item>
-          <item row="9" column="0">
+          <item row="10" column="0">
            <widget class="QCheckBox" name="ck_cOnline">
             <property name="text">
              <string>Online contacts:</string>
             </property>
            </widget>
           </item>
-          <item row="9" column="1">
+          <item row="10" column="1">
            <widget class="QToolButton" name="pb_cOnline">
             <property name="sizePolicy">
              <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
@@ -322,14 +322,14 @@
             </property>
            </widget>
           </item>
-          <item row="10" column="0">
+          <item row="11" column="0">
            <widget class="QCheckBox" name="ck_cAway">
             <property name="text">
              <string>Away contacts:</string>
             </property>
            </widget>
           </item>
-          <item row="10" column="1">
+          <item row="11" column="1">
            <widget class="QToolButton" name="pb_cAway">
             <property name="sizePolicy">
              <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
@@ -348,14 +348,14 @@
             </property>
            </widget>
           </item>
-          <item row="11" column="0">
+          <item row="12" column="0">
            <widget class="QCheckBox" name="ck_cDND">
             <property name="text">
              <string>DND contacts:</string>
             </property>
            </widget>
           </item>
-          <item row="11" column="1">
+          <item row="12" column="1">
            <widget class="QToolButton" name="pb_cDND">
             <property name="sizePolicy">
              <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
@@ -374,14 +374,14 @@
             </property>
            </widget>
           </item>
-          <item row="12" column="0">
+          <item row="13" column="0">
            <widget class="QCheckBox" name="ck_cOffline">
             <property name="text">
              <string>Offline contacts:</string>
             </property>
            </widget>
           </item>
-          <item row="12" column="1">
+          <item row="13" column="1">
            <widget class="QToolButton" name="pb_cOffline">
             <property name="sizePolicy">
              <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
@@ -400,7 +400,7 @@
             </property>
            </widget>
           </item>
-          <item row="13" column="0">
+          <item row="14" column="0">
            <widget class="QCheckBox" name="ck_cListBack">
             <property name="whatsThis">
              <string>Specifies the background color for the main window.</string>
@@ -410,7 +410,7 @@
             </property>
            </widget>
           </item>
-          <item row="13" column="1">
+          <item row="14" column="1">
            <widget class="QToolButton" name="pb_cListBack">
             <property name="sizePolicy">
              <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
@@ -429,14 +429,14 @@
             </property>
            </widget>
           </item>
-          <item row="14" column="0">
+          <item row="15" column="0">
            <widget class="QCheckBox" name="ck_cStatus">
             <property name="text">
              <string>Status messages:</string>
             </property>
            </widget>
           </item>
-          <item row="14" column="1">
+          <item row="15" column="1">
            <widget class="QToolButton" name="pb_cStatus">
             <property name="sizePolicy">
              <sizepolicy hsizetype="Fixed" vsizetype="Fixed">
@@ -455,6 +455,29 @@
             </property>
            </widget>
           </item>
+          <item row="9" column="0">
+           <widget class="QCheckBox" name="ck_cUserText">
+            <property name="whatsThis">
+             <string>Specifies the color for additional text of system messages. MUC topic for example.</string>
+            </property>
+            <property name="text">
+             <string>Additional message text:</string>
+            </property>
+           </widget>
+          </item>
+          <item row="9" column="1">
+           <widget class="QToolButton" name="pb_cUserText">
+            <property name="maximumSize">
+             <size>
+              <width>20</width>
+              <height>20</height>
+             </size>
+            </property>
+            <property name="text">
+             <string/>
+            </property>
+           </widget>
+          </item>
          </layout>
         </widget>
        </widget>
@@ -578,6 +601,8 @@
   <tabstop>pb_cMessageReceived</tabstop>
   <tabstop>ck_cSysMsg</tabstop>
   <tabstop>pb_cSysMsg</tabstop>
+  <tabstop>ck_cUserText</tabstop>
+  <tabstop>pb_cUserText</tabstop>
   <tabstop>ck_cOnline</tabstop>
   <tabstop>pb_cOnline</tabstop>
   <tabstop>ck_cAway</tabstop>
--- psi.orig/src/options/options.pri
+++ psi/src/options/options.pri
@@ -17,6 +17,7 @@ HEADERS += \
 	$$PWD/opt_status.h \
 	$$PWD/opt_appearance.h \
 	$$PWD/opt_iconset.h \
+	$$PWD/opt_theme.h \
 	$$PWD/opt_groupchat.h \
 	$$PWD/opt_sound.h \
 	$$PWD/opt_avcall.h \
@@ -33,6 +34,7 @@ SOURCES += \
 	$$PWD/opt_status.cpp \
 	$$PWD/opt_appearance.cpp \
 	$$PWD/opt_iconset.cpp \
+	$$PWD/opt_theme.cpp \
 	$$PWD/opt_groupchat.cpp \
 	$$PWD/opt_sound.cpp \
 	$$PWD/opt_avcall.cpp \
@@ -49,6 +51,7 @@ FORMS += \
 	$$PWD/opt_status.ui \
 	$$PWD/opt_appearance.ui \
 	$$PWD/opt_appearance_misc.ui \
+	$$PWD/opt_theme.ui \
 	$$PWD/opt_sound.ui \
 	$$PWD/opt_avcall.ui \
 	$$PWD/opt_advanced.ui \
--- psi.orig/src/options/opt_theme.cpp
+++ psi/src/options/opt_theme.cpp
@@ -0,0 +1,89 @@
+#include "opt_theme.h"
+
+#include "ui_opt_theme.h"
+#include "psioptions.h"
+#include "psithememodel.h"
+#include "psithemeviewdelegate.h"
+#include "psithememanager.h"
+
+class OptAppearanceThemeUI : public QWidget, public Ui::OptAppearanceTheme
+{
+public:
+	OptAppearanceThemeUI() : QWidget() { setupUi(this); }
+};
+
+
+
+OptionsTabAppearanceThemes::OptionsTabAppearanceThemes(QObject *parent)
+	: MetaOptionsTab(parent, "themes", "", tr("Themes"), tr("Configure themes"))
+{
+	foreach (PsiThemeProvider *provider,
+			 PsiThemeManager::instance()->registeredProviders()) {
+		addTab( new OptionsTabAppearanceTheme(this, provider) );
+	}
+}
+
+
+
+
+
+//----------------------------------------------------------------------------
+// OptionsTabAppearanceTheme
+//----------------------------------------------------------------------------
+
+OptionsTabAppearanceTheme::OptionsTabAppearanceTheme(QObject *parent,
+													PsiThemeProvider *provider_)
+	: OptionsTab(parent, qPrintable(provider_->type()), "",
+				 tr(qPrintable(provider_->optionsName())),
+				 tr(qPrintable(provider_->optionsDescription())))
+	, w(0)
+	, provider(provider_)
+{
+
+}
+
+OptionsTabAppearanceTheme::~OptionsTabAppearanceTheme()
+{
+
+}
+
+QWidget *OptionsTabAppearanceTheme::widget()
+{
+	if ( w )
+		return 0;
+
+	w = new OptAppearanceThemeUI();
+	OptAppearanceThemeUI *d = (OptAppearanceThemeUI *)w;
+	themesModel = new PsiThemeModel(this);
+	themesModel->setType(provider->type());
+	PsiThemeViewDelegate *vd = new PsiThemeViewDelegate(d->themeView);
+	d->themeView->setItemDelegate(vd);
+	d->themeView->setModel(themesModel);
+	int sw = provider->screenshotWidth();
+	if (sw) {
+		d->themeView->setFixedWidth(sw);
+	}
+	connect(d->themeView->selectionModel(), SIGNAL(currentChanged(QModelIndex, QModelIndex)), SIGNAL(dataChanged()));
+
+	return w;
+}
+
+void OptionsTabAppearanceTheme::applyOptions()
+{
+	if ( !w )
+		return;
+
+	OptAppearanceThemeUI *d = (OptAppearanceThemeUI *)w;
+	//qDebug("save theme: %s", qPrintable(d->themeView->currentIndex().data(PsiThemeModel::IdRole).toString()));
+	PsiOptions::instance()->setOption("options.ui.chat.theme", d->themeView->currentIndex().data(PsiThemeModel::IdRole));
+}
+
+void OptionsTabAppearanceTheme::restoreOptions()
+{
+	if ( !w )
+		return;
+
+	OptAppearanceThemeUI *d = (OptAppearanceThemeUI *)w;
+
+	d->themeView->setCurrentIndex(themesModel->index( themesModel->themeRow(PsiOptions::instance()->getOption("options.ui.chat.theme").toString()) ));
+}
--- psi.orig/src/options/opt_theme.h
+++ psi/src/options/opt_theme.h
@@ -0,0 +1,35 @@
+#ifndef OPT_THEME_H
+#define OPT_THEME_H
+
+#include "optionstab.h"
+
+class QWidget;
+class PsiThemeModel;
+class PsiThemeProvider;
+
+class OptionsTabAppearanceThemes : public MetaOptionsTab
+{
+	Q_OBJECT
+public:
+	OptionsTabAppearanceThemes(QObject *parent);
+};
+
+class OptionsTabAppearanceTheme : public OptionsTab
+{
+	Q_OBJECT
+public:
+	OptionsTabAppearanceTheme(QObject *parent, PsiThemeProvider *provider_);
+	~OptionsTabAppearanceTheme();
+
+	bool stretchable() const { return true; }
+	QWidget *widget();
+	void applyOptions();
+	void restoreOptions();
+
+private:
+	QWidget *w;
+	PsiThemeModel *themesModel;
+	PsiThemeProvider *provider;
+};
+
+#endif
--- psi.orig/src/options/opt_theme.ui
+++ psi/src/options/opt_theme.ui
@@ -0,0 +1,82 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<ui version="4.0">
+ <class>OptAppearanceTheme</class>
+ <widget class="QWidget" name="OptAppearanceTheme">
+  <property name="geometry">
+   <rect>
+    <x>0</x>
+    <y>0</y>
+    <width>274</width>
+    <height>257</height>
+   </rect>
+  </property>
+  <property name="windowTitle">
+   <string>OptAppearanceThemeUI</string>
+  </property>
+  <layout class="QVBoxLayout" name="verticalLayout">
+   <item>
+    <layout class="QHBoxLayout" name="adapterLayout">
+     <item>
+      <widget class="QListView" name="themeView"/>
+     </item>
+     <item>
+      <spacer name="horizontalSpacer_2">
+       <property name="orientation">
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" stdset="0">
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+    </layout>
+   </item>
+   <item>
+    <layout class="QHBoxLayout" name="horizontalLayout">
+     <item>
+      <spacer name="horizontalSpacer">
+       <property name="orientation">
+        <enum>Qt::Horizontal</enum>
+       </property>
+       <property name="sizeHint" stdset="0">
+        <size>
+         <width>40</width>
+         <height>20</height>
+        </size>
+       </property>
+      </spacer>
+     </item>
+     <item>
+      <widget class="URLLabel" name="lbl_morethemes">
+       <property name="sizePolicy">
+        <sizepolicy hsizetype="Preferred" vsizetype="Preferred">
+         <horstretch>0</horstretch>
+         <verstretch>0</verstretch>
+        </sizepolicy>
+       </property>
+       <property name="text">
+        <string>&lt;a href=&quot;thememanager://showmore/&quot;&gt;More themes&lt;/a&gt;</string>
+       </property>
+       <property name="alignment">
+        <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>
+       </property>
+      </widget>
+     </item>
+    </layout>
+   </item>
+  </layout>
+ </widget>
+ <layoutdefault spacing="6" margin="11"/>
+ <customwidgets>
+  <customwidget>
+   <class>URLLabel</class>
+   <extends>QLabel</extends>
+   <header>urllabel.h</header>
+  </customwidget>
+ </customwidgets>
+ <resources/>
+ <connections/>
+</ui>
--- psi.orig/src/psichatdlg.cpp
+++ psi/src/psichatdlg.cpp
@@ -27,6 +27,7 @@
 #include "iconwidget.h"
 #include "fancylabel.h"
 #include "msgmle.h"
+#include "messageview.h"
 #include "iconselect.h"
 #include "avatars.h"
 #include "psitooltip.h"
@@ -39,7 +40,6 @@
 #include "psicontactlist.h"
 #include "userlist.h"
 #include "jidutil.h"
-#include "textutil.h"
 #include "xmpp_tasks.h"
 #include "lastactivitytask.h"

@@ -136,8 +136,8 @@ public slots:
 			dlg_->appendSysMsg("No version information available.");
 			return;
 		}
-		dlg_->appendSysMsg(QString("Version response: N: %2 V: %3 OS: %4")
-			.arg(version->name(), version->version(), version->os()));
+		dlg_->appendSysMsg(Qt::escape(QString("Version response: N: %2 V: %3 OS: %4")
+			.arg(version->name(), version->version(), version->os())));
 	};

 	void lastactivity_finished()
@@ -154,7 +154,7 @@ public slots:
 				.arg(idle->time().toString()));
 		} else {
 			dlg_->appendSysMsg(QString("Last activity at %1 (%2)")
-				.arg(idle->time().toString(), idle->status()));
+				.arg(idle->time().toString(), Qt::escape(idle->status())));
 		}
 	}

@@ -526,67 +526,6 @@ void PsiChatDlg::updateCounter()
 	ui_.lb_count->setNum(chatEdit()->toPlainText().length());
 }

-void PsiChatDlg::appendEmoteMessage(SpooledType spooled, const QDateTime& time, bool local, const QString& txt, const QString& subject)
-{
-	updateLastMsgTime(time);
-	QString color = colorString(local, spooled);
-	QString timestr = chatView()->formatTimeStamp(time);
-
-	if (subject.isEmpty()) {
-		chatView()->appendText(QString("<span style=\"color: %1\">").arg(color) + QString("[%1]").arg(timestr) + QString(" *%1 ").arg(whoNick(local)) + txt + "</span>");
-	} else {
-		chatView()->appendText(QString("<span style=\"color: %1\">").arg(color) + QString("[%1]").arg(timestr) + "</span><br><b>" + tr("Subject:") + "</b> " + subject);
-		chatView()->appendText(QString("<span style=\"color: %1\">").arg(color) + QString(" *%1 ").arg(whoNick(local)) + txt + "</span>");
-	}
-
-}
-
-void PsiChatDlg::appendNormalMessage(SpooledType spooled, const QDateTime& time, bool local, const QString& txt, const QString& subject)
-{
-	updateLastMsgTime(time);
-	QString color = colorString(local, spooled);
-	QString timestr = chatView()->formatTimeStamp(time);
-	QString subjectLine;
-	if (!subject.isEmpty()) {
-		subjectLine = "<b>" + tr("Subject:") + "</b> " + subject;
-	}
-
-	if (PsiOptions::instance()->getOption("options.ui.chat.use-chat-says-style").toBool()) {
-		chatView()->appendText(QString("<span style=\"color: %1\">").arg(color) + QString("[%1] ").arg(timestr) + tr("%1 says:").arg(whoNick(local)) + "</span>");
-		if (!subjectLine.isEmpty()) {
-			chatView()->appendText(subjectLine);
-		}
-		chatView()->appendText(txt);
-	}
-	else {
-		QString intro = QString("<span style=\"color: %1\">").arg(color) + QString("[%1] &lt;").arg(timestr) + whoNick(local) + QString("&gt;</span>");
-		if (subjectLine.isEmpty()) {
-			chatView()->appendText(intro + " " + txt);
-		} else {
-			chatView()->appendText(intro);
-			chatView()->appendText(subjectLine);
-			chatView()->appendText(txt);
-		}
-
-	}
-}
-
-void PsiChatDlg::appendMessageFields(const Message& m)
-{
-//	if (!m.subject().isEmpty()) {
-//		chatView()->appendText(QString("<b>") + tr("Subject:") + "</b> " + QString("%1").arg(Qt::escape(m.subject())));
-//	}
-	if (!m.urlList().isEmpty()) {
-		UrlList urls = m.urlList();
-		chatView()->appendText(QString("<i>") + tr("-- Attached URL(s) --") + "</i>");
-		for (QList<Url>::ConstIterator it = urls.begin(); it != urls.end(); ++it) {
-			const Url &u = *it;
-			chatView()->appendText(QString("<b>") + tr("URL:") + "</b> " + QString("%1").arg(TextUtil::linkify(Qt::escape(u.url()))));
-			chatView()->appendText(QString("<b>") + tr("Desc:") + "</b> " + QString("%1").arg(u.desc()));
-		}
-	}
-}
-
 bool PsiChatDlg::isEncryptionEnabled() const
 {
 	return act_pgp_->isChecked();
@@ -594,25 +533,7 @@ bool PsiChatDlg::isEncryptionEnabled() c

 void PsiChatDlg::appendSysMsg(const QString &str)
 {
-	QDateTime t = QDateTime::currentDateTime();
-	updateLastMsgTime(t);
-	QString timestr = chatView()->formatTimeStamp(t);
-	QString color = ColorOpt::instance()->color("options.ui.look.colors.messages.informational").name();
-
-	chatView()->appendText(QString("<font color=\"%1\">[%2]").arg(color, timestr) + QString(" *** %1</font>").arg(str));
-}
-
-QString PsiChatDlg::colorString(bool local, ChatDlg::SpooledType spooled) const
-{
-	if (spooled == ChatDlg::Spooled_OfflineStorage) {
-		return ColorOpt::instance()->color("options.ui.look.colors.messages.informational").name();
-	}
-
-	if (local) {
-		return ColorOpt::instance()->color("options.ui.look.colors.messages.sent").name();
-	}
-
-	return ColorOpt::instance()->color("options.ui.look.colors.messages.received").name();
+	chatView()->dispatchMessage(MessageView::fromHtml(str, MessageView::System));
 }

 ChatView* PsiChatDlg::chatView() const
@@ -643,23 +564,13 @@ void PsiChatDlg::doSend() {
 	if (mCmdSite_.isActive()) {
 		QString str = chatEdit()->toPlainText();
 		if (!mCmdManager_.processCommand(str)) {
-			appendSysMsg(tr("Error: Can not parse command: ") + str);
+			appendSysMsg(tr("Error: Can not parse command: ") + Qt::escape(str));
 		}
 	} else {
 		ChatDlg::doSend();
 	}
 }

-void PsiChatDlg::updateLastMsgTime(QDateTime t)
-{
-	bool doInsert = t.date() != lastMsgTime_.date();
-	lastMsgTime_ = t;
-	if (doInsert) {
-		QString color = "#00A000";
-		chatView()->appendText(QString("<font color=\"%1\">*** %2</font>").arg(color).arg(t.date().toString(Qt::ISODate)));
-	}
-}
-
 void PsiChatDlg::doMiniCmd()
 {
 	mCmdManager_.open(new MCmdSimpleState(MCMDCHAT, tr("Command>")), QStringList() );
--- psi.orig/src/psichatdlg.h
+++ psi/src/psichatdlg.h
@@ -55,12 +55,7 @@ private:
 	void activated();
 	void setLooks();
 	void setShortcuts();
-	QString colorString(bool local, SpooledType spooled) const;
 	void appendSysMsg(const QString &);
-	void appendEmoteMessage(SpooledType spooled, const QDateTime& time, bool local, const QString& txt, const QString& subject);
-	void appendNormalMessage(SpooledType spooled, const QDateTime& time, bool local, const QString& txt, const QString& subject);
-	void appendMessageFields(const Message& m);
-	void updateLastMsgTime(QDateTime t);
 	ChatView* chatView() const;
 	ChatEdit* chatEdit() const;

@@ -86,7 +81,6 @@ private:
 	MCmdTabCompletion tabCompletion;

 	bool smallChat_;
-	QDateTime lastMsgTime_;
 	class ChatDlgMCmdProvider;
 };

--- psi.orig/src/psicon.cpp
+++ psi/src/psicon.cpp
@@ -40,6 +40,7 @@
 #include "activeprofiles.h"
 #include "accountadddlg.h"
 #include "psiiconset.h"
+#include "psithememanager.h"
 #ifndef NEWCONTACTLIST
 # include "contactview.h"
 #endif
@@ -80,6 +81,10 @@
 #include "accountscombobox.h"
 #include "tabdlg.h"
 #include "chatdlg.h"
+#ifdef WEBKIT
+#include "avatars.h"
+#include "chatviewthemeprovider.h"
+#endif
 #include "capsregistry.h"
 #include "urlobject.h"
 #include "anim.h"
@@ -191,6 +196,7 @@ private:
 	}
 };

+
 //----------------------------------------------------------------------------
 // PsiCon::Private
 //----------------------------------------------------------------------------
@@ -473,6 +479,18 @@ bool PsiCon::init()
 		//}
 	}

+#ifdef WEBKIT
+	PsiThemeManager::instance()->registerProvider(
+			new ChatViewThemeProvider(this), true);
+	PsiThemeManager::instance()->registerProvider(
+			new GroupChatViewThemeProvider(this), true);
+#endif
+
+	if( !PsiThemeManager::instance()->loadAll() ) {
+		QMessageBox::critical(0, tr("Error"), tr("Unable to load theme!  Please make sure Psi is properly installed."));
+		result = false;
+	}
+
 	if ( !d->actionList )
 		d->actionList = new PsiActionList( this );

@@ -619,7 +637,6 @@ bool PsiCon::init()
 	}

 	checkAccountsEmpty();
-
 	// try autologin if needed
 	foreach(PsiAccount* account, d->contactList->accounts()) {
 		account->autoLogin();
--- psi.orig/src/psiiconset.cpp
+++ psi/src/psiiconset.cpp
@@ -235,7 +235,7 @@ public:
 		foreach(QString name, PsiOptions::instance()->getOption("options.iconsets.emoticons").toStringList()) {
 			Iconset *is = new Iconset;
 			if ( is->load ( iconsetPath("emoticons/" + name) ) ) {
-				PsiIconset::removeAnimation(is);
+				//PsiIconset::removeAnimation(is);
 				is->addToFactory();
 				emo.append( is );
 			}
--- psi.orig/src/psithememanager.cpp
+++ psi/src/psithememanager.cpp
@@ -0,0 +1,86 @@
+/*
+ * psithememanager.h - manages all themes in psi
+ * Copyright (C) 2010  Rion (Sergey Ilinyh)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include "psithememanager.h"
+
+#include <QCoreApplication>
+
+#include "theme.h"
+#include "applicationinfo.h"
+
+class PsiThemeManager::Private {
+public:
+	QMap<QString, PsiThemeProvider *> providers;
+	QSet<QString> required;
+};
+
+
+
+//---------------------------------------------------------
+// PsiThemeManager
+//---------------------------------------------------------
+PsiThemeManager::PsiThemeManager()
+	: QObject(QCoreApplication::instance())
+{
+	d = new Private;//(this);
+}
+
+PsiThemeManager::~PsiThemeManager()
+{
+	delete d;
+}
+
+PsiThemeManager* PsiThemeManager::instance()
+{
+	if (!instance_)
+		instance_ = new PsiThemeManager();
+	return instance_;
+}
+
+void PsiThemeManager::registerProvider(PsiThemeProvider *provider,
+									   bool required)
+{
+	d->providers[provider->type()] = provider;
+	if (required) {
+		d->required.insert(provider->type());
+	}
+}
+
+PsiThemeProvider *PsiThemeManager::provider(const QString &type)
+{
+	return d->providers.value(type);
+}
+
+QList<PsiThemeProvider *> PsiThemeManager::registeredProviders() const
+{
+	return d->providers.values();
+}
+
+bool PsiThemeManager::loadAll()
+{
+	foreach (const QString &type, d->providers.keys()) {
+		if (!d->providers[type]->loadCurrent() && d->required.contains(type)) {
+			return false;
+		}
+	}
+	return true;
+}
+
+PsiThemeManager* PsiThemeManager::instance_ = NULL;
--- psi.orig/src/psithememanager.h
+++ psi/src/psithememanager.h
@@ -0,0 +1,51 @@
+/*
+ * psithememanager.h - manages all themes in psi
+ * Copyright (C) 2010 Rion (Sergey Ilinyh)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef PSITHEMEMANAGER_H
+#define PSITHEMEMANAGER_H
+
+#include <QObject>
+
+#include "psithemeprovider.h"
+
+//class ChatViewTheme;
+
+class PsiThemeManager : public QObject {
+	Q_OBJECT
+public:
+	static PsiThemeManager* instance();
+
+	void registerProvider(PsiThemeProvider *provider, bool required = false);
+	PsiThemeProvider *provider(const QString &type);
+	QList<PsiThemeProvider *> registeredProviders() const;
+	bool loadAll();
+
+private:
+	PsiThemeManager();
+	~PsiThemeManager();
+
+	static PsiThemeManager* instance_;
+
+	class Private;
+	Private *d;
+};
+
+
+#endif
--- psi.orig/src/psithememodel.cpp
+++ psi/src/psithememodel.cpp
@@ -0,0 +1,152 @@
+/*
+ * psithememodel.h - just a model for theme views
+ * Copyright (C) 2010 Rion (Sergey Ilinyh)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include "psithememodel.h"
+
+#include <QtConcurrentMap>
+
+#include "psithememanager.h"
+
+
+class PsiThemeModel;
+struct PsiThemeModel::Loader
+{
+	Loader(PsiThemeProvider *provider_)
+	: provider(provider_) { }
+
+	typedef ThemeItemInfo result_type;
+
+	ThemeItemInfo operator()(const QString &id)
+	{
+		Theme *t = provider->load(id);
+		ThemeItemInfo ti;
+		if (t) { // if loaded
+			ti.id = id;
+			ti.title = t->title();
+			ti.screenshot = t->screenshot();
+			ti.isValid = true;
+		} else {
+			ti.isValid = false;
+		}
+		return ti;
+	}
+
+	PsiThemeProvider *provider;
+};
+
+//------------------------------------------------------------------------------
+// PsiThemeModel
+//------------------------------------------------------------------------------
+
+PsiThemeModel::PsiThemeModel(QObject *parent)
+	: QAbstractListModel(parent)
+{
+	connect(&themeWatcher, SIGNAL(progressValueChanged(int)),
+			SLOT(loadProgress(int)));
+	connect(&themeWatcher, SIGNAL(finished()), SLOT(loadComplete()));
+}
+
+void PsiThemeModel::loadProgress(int pv)
+{
+	qDebug("%d", pv);
+}
+
+void PsiThemeModel::loadComplete()
+{
+	QFutureIterator<ThemeItemInfo> i(themesFuture);
+#if QT_VERSION >= 0x040600
+	beginResetModel();
+#endif
+	while (i.hasNext()) {
+		ThemeItemInfo ti = i.next();
+		if (ti.isValid) {
+			qDebug("%s theme loaded", qPrintable(ti.id));
+			themesInfo.append(ti);
+		} else {
+			qDebug("failed to load theme %s", qPrintable(ti.id));
+		}
+	}
+#if QT_VERSION >= 0x040600
+	endResetModel();
+#else
+	reset();
+#endif
+}
+
+void PsiThemeModel::setType(const QString &type)
+{
+	PsiThemeProvider *provider = PsiThemeManager::instance()->provider(type);
+	if (provider) {
+		Loader loader = Loader(provider);
+		if (provider->threadedLoading()) {
+			themesFuture = QtConcurrent::mapped(provider->themeIds(), loader);
+			themeWatcher.setFuture(themesFuture);
+		} else {
+#if QT_VERSION >= 0x040600
+			beginResetModel();
+#endif
+			foreach (const QString id, provider->themeIds()) {
+				ThemeItemInfo ti = loader(id);
+				if (ti.isValid) {
+					themesInfo.append(ti);
+				}
+			}
+#if QT_VERSION >= 0x040600
+			endResetModel();
+#else
+			reset();
+#endif
+		}
+	}
+}
+
+int PsiThemeModel::rowCount ( const QModelIndex & parent ) const
+{
+	Q_UNUSED(parent)
+	return themesInfo.count();
+}
+
+QVariant PsiThemeModel::data ( const QModelIndex & index, int role ) const
+{
+	switch (role) {
+		case IdRole:
+			return themesInfo[index.row()].id;
+		case TitleRole:
+			return themesInfo[index.row()].title;
+		case ScreenshotRole:
+			QPixmap p;
+			p.loadFromData(themesInfo[index.row()].screenshot);
+			return p;
+	}
+	return QVariant();
+}
+
+
+int PsiThemeModel::themeRow(const QString &id)
+{
+	int i = 0;
+	foreach (const ThemeItemInfo &tii, themesInfo) {
+		if (tii.id == id) {
+			return i;
+		}
+		i++;
+	}
+	return -1;
+}
--- psi.orig/src/psithememodel.h
+++ psi/src/psithememodel.h
@@ -0,0 +1,67 @@
+/*
+ * psithememodel.h - just a model for theme views
+ * Copyright (C) 2010 Rion (Sergey Ilinyh)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef PSITHEMEMODEL_H
+#define PSITHEMEMODEL_H
+
+#include <QAbstractListModel>
+#include <QFutureWatcher>
+
+class Theme;
+
+struct ThemeItemInfo
+{
+	QString id;
+	QString title;
+	QByteArray screenshot;
+	bool isValid;
+};
+
+
+class PsiThemeModel : public QAbstractListModel
+{
+	Q_OBJECT
+
+public:
+	enum ThemeRoles {
+		IdRole = Qt::UserRole + 1,
+		ScreenshotRole = Qt::UserRole + 2,
+		TitleRole = Qt::UserRole + 3
+	};
+
+	PsiThemeModel(QObject *parent);
+	void setType(const QString &type);
+
+	int rowCount ( const QModelIndex & parent = QModelIndex() ) const ;
+	QVariant data ( const QModelIndex & index, int role = Qt::DisplayRole ) const;
+	int themeRow(const QString &id);
+
+private slots:
+	void loadProgress(int);
+	void loadComplete();
+
+private:
+	class Loader;
+	QFutureWatcher<ThemeItemInfo> themeWatcher;
+	QFuture<ThemeItemInfo> themesFuture;
+	QList<ThemeItemInfo> themesInfo;
+};
+
+#endif
--- psi.orig/src/psithemeprovider.cpp
+++ psi/src/psithemeprovider.cpp
@@ -0,0 +1,64 @@
+/*
+ * psithemeprovider.cpp - kinda adapter for set of themes
+ * Copyright (C) 2010 Rion (Sergey Ilinyh)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include "psithemeprovider.h"
+
+#include <QFileInfo>
+#include <QStringList>
+
+#include "applicationinfo.h"
+
+
+PsiThemeProvider::PsiThemeProvider(QObject *parent)
+	: QObject(parent)
+{
+
+}
+
+QString PsiThemeProvider::themePath(const QString &name) const {
+	QStringList dirs;
+	dirs << ":";
+	dirs << ".";
+	dirs << ApplicationInfo::homeDir();
+	dirs << ApplicationInfo::resourcesDir();
+
+	foreach (QString dir, dirs) {
+		QString fileName = dir + "/themes/" + name;
+
+		QFileInfo fi(fileName);
+		if ( fi.exists() )
+			return fileName;
+	}
+
+	qWarning("PsiThemeManager::Private::themePath(\"%s\"): not found", qPrintable(name));
+	return QString();
+}
+
+
+// says where theme is able to load in separate thread
+bool PsiThemeProvider::threadedLoading() const
+{
+	return false;
+}
+
+int PsiThemeProvider::screenshotWidth() const
+{
+	return 0;
+}
--- psi.orig/src/psithemeprovider.h
+++ psi/src/psithemeprovider.h
@@ -0,0 +1,51 @@
+/*
+ * psithemeprovider.h - kinda adapter for set of themes
+ * Copyright (C) 2010 Rion (Sergey Ilinyh)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef PSITHEMEPROVIDER_H
+#define PSITHEMEPROVIDER_H
+
+#include <QFuture>
+#include "theme.h"
+
+class Theme;
+
+class PsiThemeProvider : public QObject
+{
+	Q_OBJECT
+
+public:
+	PsiThemeProvider(QObject *parent);
+
+	virtual const QString type() const = 0;
+	virtual Theme* load(const QString &) = 0;
+	virtual const QStringList themeIds() const = 0;
+	virtual bool loadCurrent() = 0;
+	virtual Theme* current() const = 0;
+
+	virtual bool threadedLoading() const;
+	virtual int screenshotWidth() const;
+
+	virtual QString optionsName() const = 0;
+	virtual QString optionsDescription() const = 0;
+
+	QString themePath(const QString &name) const;
+};
+
+#endif
--- psi.orig/src/psithemeviewdelegate.cpp
+++ psi/src/psithemeviewdelegate.cpp
@@ -0,0 +1,87 @@
+/*
+ * psithemeviewdelegate.cpp - renders theme items
+ * Copyright (C) 2010 Rion (Sergey Ilinyh)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include "psithemeviewdelegate.h"
+#include "psithememodel.h"
+#include <QPainter>
+#include <QFontMetrics>
+#include "iconset.h"
+
+// painting
+void PsiThemeViewDelegate::paint(QPainter *painter,
+				   const QStyleOptionViewItem &option,
+				   const QModelIndex &index) const
+{
+	QPixmap screenshot = index.data(PsiThemeModel::ScreenshotRole).value<QPixmap>();
+	QPixmap texture = IconsetFactory::iconPixmap("psi/themeTitleTexture");
+	int texturew = texture.width();
+	int textureh = texture.height();
+
+	QFont f("Serif");
+	f.setBold(true);
+	if (screenshot.isNull()) {
+		f.setPixelSize(20);
+		painter->setFont(f);
+		painter->setPen(QColor(170, 170, 170));
+		QRect nirect(0, option.rect.top() + textureh, option.rect.width(), 20);
+		painter->drawText(nirect, Qt::AlignCenter, tr("No Image"));
+	} else {
+		QRect sp = screenshot.rect();
+		sp.moveTopLeft(option.rect.topLeft());
+		painter->drawPixmap(sp, screenshot);
+	}
+
+	f.setItalic(true);
+	f.setPixelSize(textureh - 15);
+	painter->setFont(f);
+	QFontMetrics fm(f);
+	QString text = index.data(PsiThemeModel::TitleRole).toString();
+	QSize textSize = fm.size(Qt::TextSingleLine, text);
+	int tw = textSize.width() + 10;
+	int y = option.rect.top();
+	int vw = option.rect.width();
+
+	painter->drawPixmap(0, y, vw - tw - texturew, textureh, texture.copy(0, 0, 1, textureh).scaled(vw - tw - texturew, textureh));
+	painter->drawPixmap(vw - tw - texturew, y, texturew, textureh, texture);
+	painter->drawPixmap(vw - tw, y, tw, textureh, texture.copy(texturew - 1, 0, 1, textureh).scaled(tw, textureh));
+
+
+	painter->setPen(option.state & QStyle::State_Selected? Qt::white : QColor(170, 170, 170));
+	QRect txtr(vw - tw, y, tw, textureh-5); // 5 shadow size?
+	painter->drawText(txtr, Qt::AlignCenter, text);
+}
+
+QSize PsiThemeViewDelegate::sizeHint(const QStyleOptionViewItem &option,
+					   const QModelIndex &index) const
+{
+	int textureh = IconsetFactory::iconPixmap("psi/themeTitleTexture").height();
+	QPixmap screenshot = index.data(PsiThemeModel::ScreenshotRole).value<QPixmap>();
+	int h = screenshot.isNull()? textureh + 20 : qMax(textureh, screenshot.height());
+	return QSize(option.rect.width(), h);
+}
+
+// editing
+QWidget *PsiThemeViewDelegate::createEditor(QWidget */*parent*/,
+							  const QStyleOptionViewItem &/*option*/,
+							  const QModelIndex &/*index*/) const
+{
+	return 0;
+}
+
--- psi.orig/src/psithemeviewdelegate.h
+++ psi/src/psithemeviewdelegate.h
@@ -0,0 +1,49 @@
+/*
+ * psithemeviewdelegate.h - renders theme items
+ * Copyright (C) 2010 Rion (Sergey Ilinyh)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef PSITHEMEVIEWDELEGATE_H
+#define PSITHEMEVIEWDELEGATE_H
+
+#include <QAbstractItemDelegate>
+
+class PsiThemeViewDelegate : public QAbstractItemDelegate
+{
+	Q_OBJECT
+public:
+	PsiThemeViewDelegate ( QObject * parent = 0 )
+		: QAbstractItemDelegate ( parent ) { }
+
+	// painting
+	virtual void paint(QPainter *painter,
+					   const QStyleOptionViewItem &option,
+					   const QModelIndex &index) const;
+
+	virtual QSize sizeHint(const QStyleOptionViewItem &option,
+						   const QModelIndex &index) const;
+
+	// editing
+	virtual QWidget *createEditor(QWidget *parent,
+								  const QStyleOptionViewItem &option,
+								  const QModelIndex &index) const;
+
+	static const int TextPadding = 3;
+};
+
+#endif
--- psi.orig/src/psiwkavatarhandler.cpp
+++ psi/src/psiwkavatarhandler.cpp
@@ -0,0 +1,81 @@
+/*
+ * psiwkavatarhandler.cpp - "avatar" schema handler for for network manager
+ * Copyright (C) 2010 Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include "psiwkavatarhandler.h"
+
+#include <QBuffer>
+
+#include "iconset.h"
+#include "avatars.h"
+#include "psicontactlist.h"
+#include "psiaccount.h"
+
+PsiWKAvatarHandler::PsiWKAvatarHandler(PsiCon *pc)
+	: psi_(pc)
+{
+	defaultAvatar_[""] = IconsetFactory::icon("psi/default_avatar").pixmap();
+	size_ = defaultAvatar_[""].size();
+}
+
+QByteArray PsiWKAvatarHandler::data(const QUrl &url) const {
+	QStringList parts = url.path().split("/");
+	qDebug("loading avatar");
+	PsiAccount *ac;
+	if (parts.size() > 0 && parts[0].isEmpty()) { // first / makes empty string
+		parts.removeFirst();
+	}
+	if (parts.count() == 2 && (ac = psi_->contactList()->getAccount(parts[0]))) {
+		QPixmap p = ac->avatarFactory()->getAvatar(parts[1]);
+		if (p.isNull()) {
+			if (!url.host().isEmpty() && defaultAvatar_.value(url.host()).isNull()) {
+				p = defaultAvatar_.value("");
+			} else {
+				p = defaultAvatar_.value(url.host());
+			}
+			if (p.isNull()) {
+				p = IconsetFactory::icon("psi/default_avatar").pixmap();
+			}
+		}
+		QByteArray ba;
+		QBuffer buffer(&ba);
+		buffer.open(QIODevice::WriteOnly);
+		p.scaled(size_, Qt::KeepAspectRatio, Qt::SmoothTransformation).toImage().save(&buffer, "PNG");
+		return ba;
+	}
+	return QByteArray();
+}
+
+void PsiWKAvatarHandler::setDefaultAvatar(const QString &filename, const QString &host)
+{
+	defaultAvatar_[host] = QPixmap(filename);
+	size_ = defaultAvatar_[host].size();
+}
+
+void PsiWKAvatarHandler::setDefaultAvatar(const QByteArray &ba, const QString &host)
+{
+	defaultAvatar_[host] = QPixmap();
+	defaultAvatar_[host].loadFromData(ba);
+	size_ = defaultAvatar_[host].size();
+}
+
+void PsiWKAvatarHandler::setAvatarSize(const QSize &size)
+{
+	size_ = size;
+}
--- psi.orig/src/psiwkavatarhandler.h
+++ psi/src/psiwkavatarhandler.h
@@ -0,0 +1,42 @@
+/*
+ * psiwkavatarhandler.h - "avatar" schema handler for for network manager
+ * Copyright (C) 2010 Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef PSIWKAVATARHANDLER_H
+#define PSIWKAVATARHANDLER_H
+
+#include "networkaccessmanager.h"
+#include "psicon.h"
+
+class PsiWKAvatarHandler : public NAMSchemeHandler
+{
+public:
+	PsiWKAvatarHandler(PsiCon *pc);
+	QByteArray data(const QUrl &url) const;
+	void setDefaultAvatar(const QString &filename, const QString &host = "");
+	void setDefaultAvatar(const QByteArray &ba, const QString &host = "");
+	void setAvatarSize(const QSize &);
+
+private:
+	QMap<QString,QPixmap> defaultAvatar_;
+	PsiCon *psi_;
+	QSize size_;
+};
+
+#endif
--- psi.orig/src/src.pri
+++ psi/src/src.pri
@@ -113,6 +113,11 @@ HEADERS += \
 	$$PWD/psievent.h \
 	$$PWD/xmlconsole.h \
 	$$PWD/psiiconset.h \
+	$$PWD/psithememanager.h \
+	$$PWD/psithememodel.h \
+	$$PWD/psithemeviewdelegate.h \
+	$$PWD/psithemeprovider.h \
+	$$PWD/theme.cpp \
 	$$PWD/applicationinfo.h \
 	$$PWD/pgptransaction.h \
 	$$PWD/userlist.h \
@@ -130,6 +135,9 @@ HEADERS += \
 	$$PWD/accountmodifydlg.h \
 	$$PWD/changepwdlg.h \
 	$$PWD/msgmle.h \
+	$$PWD/chatviewshare.h \
+	$$PWD/chatview.h \
+	$$PWD/messageview.h \
 	$$PWD/statusdlg.h \
 	$$PWD/statuscombobox.h \
 	$$PWD/eventdlg.h \
@@ -238,6 +246,11 @@ SOURCES += \
 	$$PWD/psievent.cpp \
 	$$PWD/xmlconsole.cpp \
 	$$PWD/psiiconset.cpp \
+	$$PWD/psithememanager.cpp \
+	$$PWD/psithememodel.cpp \
+	$$PWD/psithemeviewdelegate.cpp \
+	$$PWD/psithemeprovider.cpp \
+	$$PWD/theme.cpp \
 	$$PWD/applicationinfo.cpp \
 	$$PWD/pgptransaction.cpp \
 	$$PWD/serverinfomanager.cpp \
@@ -256,6 +269,8 @@ SOURCES += \
 	$$PWD/accountmodifydlg.cpp \
 	$$PWD/changepwdlg.cpp \
 	$$PWD/msgmle.cpp \
+	$$PWD/chatviewshare.cpp \
+	$$PWD/messageview.cpp \
 	$$PWD/statusdlg.cpp \
 	$$PWD/statuscombobox.cpp \
 	$$PWD/eventdlg.cpp \
@@ -592,6 +607,31 @@ unix:!dbus {
 	SOURCES += $$PWD/activeprofiles_stub.cpp
 }

+webkit {
+	HEADERS += 	$$PWD/chatview_webkit.h \
+			$$PWD/networkaccessmanager.h \
+			$$PWD/bytearrayreply.h \
+			$$PWD/webview.h \
+			$$PWD/psiwkavatarhandler.h \
+			$$PWD/jsutil.h \
+			$$PWD/chatviewtheme.h \
+			$$PWD/chatviewthemeprovider.h
+	SOURCES += 	$$PWD/chatview_webkit.cpp \
+			$$PWD/networkaccessmanager.cpp \
+			$$PWD/bytearrayreply.cpp \
+			$$PWD/webview.cpp \
+			$$PWD/psiwkavatarhandler.cpp \
+			$$PWD/jsutil.cpp \
+			$$PWD/chatviewtheme.cpp \
+			$$PWD/chatviewthemeprovider.cpp
+	DEFINES += WEBKIT
+	QT += webkit
+}
+else {
+	HEADERS += 	$$PWD/chatview_te.h
+	SOURCES += 	$$PWD/chatview_te.cpp
+}
+
 mac {
 	QMAKE_LFLAGS += -framework Carbon -framework IOKit -framework AppKit
 }
--- psi.orig/src/src.pro
+++ psi/src/src.pro
@@ -30,6 +30,9 @@ unix {
 	# Shared files
 	sharedfiles.path  = $$PSI_DATADIR
 	sharedfiles.files = ../README ../COPYING ../iconsets ../sound ../certs
+	webkit {
+		sharedfiles.files += ../themes
+	}
 	INSTALLS += sharedfiles

 	# Widgets
--- psi.orig/src/statusdlg.cpp
+++ psi/src/statusdlg.cpp
@@ -37,7 +37,7 @@
 #include "psiaccount.h"
 #include "userlist.h"
 #include "common.h"
-#include "msgmle.h"
+#include "psitextview.h"
 #include "statuspreset.h"
 #include "statuscombobox.h"
 #include "shortcutmanager.h"
@@ -88,7 +88,7 @@ public:
 	PsiCon *psi;
 	PsiAccount *pa;
 	Status s;
-	ChatView *te;
+	PsiTextView *te;
 	StatusComboBox *cb_type;
 	QComboBox *cb_preset;
 	QLineEdit *le_priority;
@@ -161,8 +161,8 @@ void StatusSetDlg::init()
 	connect(d->cb_preset, SIGNAL(currentIndexChanged(int)), SLOT(chooseStatusPreset(int)));
 	hb1->addWidget(d->cb_preset,3);

-	d->te = new ChatView(this);
-	d->te->setDialog(this);
+	d->te = new PsiTextView(this);
+	//d->te->setDialog(this);
 	d->te->setReadOnly(false);
 	d->te->setAcceptRichText(false);
 	d->te->setMinimumHeight(50);
--- psi.orig/src/textutil.cpp
+++ psi/src/textutil.cpp
@@ -150,7 +150,7 @@ QString TextUtil::rich2plain(const QStri
 				out += '\n';

 			// handle output of Qt::convertFromPlainText() correctly
-			if((tagName == "p" || tagName == "/p") && out.length() > 0)
+			if((tagName == "p" || tagName == "/p" || tagName == "div") && out.length() > 0)
 				out += '\n';
 		}
 		// entity?
@@ -535,6 +535,15 @@ QString TextUtil::emoticonify(const QStr
 	return out;
 }

+QString TextUtil::img2title(const QString &in)
+{
+	QString ret = in;
+	QRegExp rxq("<img[^>]+title\\s*=\\s*'([^']+)'[^>]*>"),  rxdq("<img[^>]+title\\s*=\\s*\"([^\"]+)\"[^>]*>");
+	ret.replace(rxq, "\\1");
+	ret.replace(rxdq, "\\1");
+	return ret;
+}
+
 QString TextUtil::legacyFormat(const QString& in)
 {

@@ -552,38 +561,3 @@ QString TextUtil::legacyFormat(const QSt

 	return out;
 }
-
-/**
- * Creates linkified and optionally emoticonified and legacy-formatted rich text.
- * \a text, text to modify (either plain or rich, depending on \a isHtml
- * \a isEmote, if true, remove "/me " part
- * \a isHtml, if false, \a text is first converted to rich text.
- */
-QString TextUtil::prepareMessageText(const QString& text, bool isEmote, bool isHtml)
-{
-	static const QString me_cmd = "/me ";
-
-	QString txt = text;
-
-	if (isHtml) {
-		if (isEmote) {
-			int cmd = txt.indexOf(me_cmd);
-			txt = txt.remove(cmd, me_cmd.length());
-		}
-	}
-	else {
-		if (isEmote) {
-			txt = txt.mid(me_cmd.length());
-		}
-
-		txt = TextUtil::plain2rich(txt);
-		txt = TextUtil::linkify(txt);
-	}
-
-	if (PsiOptions::instance()->getOption("options.ui.emoticons.use-emoticons").toBool())
-		txt = TextUtil::emoticonify(txt);
-	if (PsiOptions::instance()->getOption("options.ui.chat.legacy-formatting").toBool())
-		txt = TextUtil::legacyFormat(txt);
-
-	return txt;
-}
--- psi.orig/src/textutil.h
+++ psi/src/textutil.h
@@ -15,6 +15,7 @@ namespace TextUtil
 	QString linkify(const QString &);
 	QString legacyFormat(const QString &);
 	QString emoticonify(const QString &in);
+	QString img2title(const QString &in);

 	QString prepareMessageText(const QString& text, bool isEmote=false, bool isHtml=false);
 };
--- psi.orig/src/theme.cpp
+++ psi/src/theme.cpp
@@ -0,0 +1,189 @@
+/*
+ * theme.cpp - base class for any theme
+ * Copyright (C) 2010 Justin Karneges, Michail Pishchagin, Rion (Sergey Ilinyh)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include "theme.h"
+
+#include <QFileInfo>
+
+#ifndef NO_Theme_ZIP
+#define Theme_ZIP
+#endif
+
+#ifdef Theme_ZIP
+#	include "zip/zip.h"
+#endif
+
+class ThemeMetaData : public QSharedData
+{
+public:
+	QString id, name, version, description, creation, homeUrl, filename;
+	QStringList authors;
+	QHash<QString, QString> info;
+
+public:
+	ThemeMetaData(const QString &id);
+	//QByteArray loadData(const QString &fileName, const QString &dir) const;
+};
+
+ThemeMetaData::ThemeMetaData(const QString &id) :
+	id(id),
+	name(QObject::tr("Unnamed"))
+{
+
+}
+
+
+//--------------------------------------
+// Theme
+//--------------------------------------
+Theme::Theme(const QString &id) :
+	md(new ThemeMetaData(id))
+{
+
+}
+
+Theme::Theme(const Theme &other) :
+	md(other.md)
+{
+
+}
+
+Theme::~Theme()
+{
+
+}
+
+QByteArray Theme::loadData(const QString &fileName, const QString &dir)
+{
+	QByteArray ba;
+
+	QFileInfo fi(dir);
+	if ( fi.isDir() ) {
+		QFile file ( dir + '/' + fileName );
+		//qDebug("read data from %s", qPrintable(file.fileName()));
+		if (!file.open(QIODevice::ReadOnly))
+			return ba;
+
+		ba = file.readAll();
+	}
+#ifdef Theme_ZIP
+	else if ( fi.suffix() == "jisp" || fi.suffix() == "zip" || fi.suffix() == "theme" ) {
+		UnZip z(dir);
+		if ( !z.open() )
+			return ba;
+
+		QString n = fi.completeBaseName() + '/' + fileName;
+		if ( !z.readFile(n, &ba) ) {
+			n = "/" + fileName;
+			z.readFile(n, &ba);
+		}
+	}
+#endif
+
+	return ba;
+}
+
+const QString &Theme::id() const
+{
+	return md->id;
+}
+
+const QString &Theme::name() const
+{
+	return md->name;
+}
+
+void Theme::setName(const QString &name)
+{
+	md->name = name;
+}
+
+const QString &Theme::version() const
+{
+	return md->version;
+}
+
+const QString &Theme::description() const
+{
+	return md->description;
+}
+
+/**
+ * Returns the Theme authors list.
+ */
+const QStringList &Theme::authors() const
+{
+	return md->authors;
+}
+
+/**
+ * Returns the Theme creation date.
+ */
+const QString &Theme::creation() const
+{
+	return md->creation;
+}
+
+const QString &Theme::homeUrl() const
+{
+	return md->homeUrl;
+}
+
+/**
+ * Returns directory (or .zip/.jisp archive) name from which Theme was loaded.
+ */
+const QString &Theme::fileName() const
+{
+	return md->filename;
+}
+
+/**
+ * Sets the Theme directory (.zip archive) name.
+ */
+void Theme::setFileName(const QString &f)
+{
+	md->filename = f;
+}
+
+/**
+ * Returns additional Theme information.
+ * \sa setInfo()
+ */
+const QHash<QString, QString> Theme::info() const
+{
+	return md->info;
+}
+
+/**
+ * Sets additional Theme information.
+ * \sa info()
+ */
+void Theme::setInfo(const QHash<QString, QString> &i)
+{
+	md->info = i;
+}
+
+/**
+ * Title suitable to display in options dialog
+ */
+QString Theme::title() const
+{
+	return md->name.isEmpty()? md->id : md->name;
+}
--- psi.orig/src/theme.h
+++ psi/src/theme.h
@@ -0,0 +1,61 @@
+/*
+ * theme.h - base class for any theme
+ * Copyright (C) 2010 Justin Karneges, Michail Pishchagin, Rion (Sergey Ilinyh)
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef PSITHEME_H
+#define PSITHEME_H
+
+#include <QPixmap>
+#include <QSharedData>
+#include <QHash>
+
+class ThemeMetaData;
+
+//-----------------------------------------------
+// Theme
+//-----------------------------------------------
+class Theme {
+public:
+	Theme(const QString &id);
+	Theme(const Theme &other);
+	virtual ~Theme();
+
+	static QByteArray loadData(const QString &fileName, const QString &dir);
+
+	const QString &id() const;
+	const QString &name() const;
+	void setName(const QString &name);
+	const QString &version() const;
+	const QString &description() const;
+	const QStringList &authors() const;
+	const QString &creation() const;
+	const QString &homeUrl() const;
+	const QString &fileName() const;
+	void setFileName(const QString &f);
+	const QHash<QString, QString> info() const;
+	void setInfo(const QHash<QString, QString> &i);
+
+	virtual QString title() const;
+	virtual QByteArray screenshot() = 0;
+protected:
+	QSharedDataPointer<ThemeMetaData> md;
+};
+
+
+#endif
--- psi.orig/src/tools/iconset/iconset.cpp
+++ psi/src/tools/iconset/iconset.cpp
@@ -31,6 +31,7 @@
 #include <QThread>
 #include <QCoreApplication>
 #include <QLocale>
+#include <QBuffer>

 #include <QTextCodec>

@@ -270,6 +271,7 @@ public:
 		text = from.text;
 		sound = from.sound;
 		impix = from.impix;
+		rawData = from.rawData;
 		anim = from.anim ? new Anim ( *from.anim ) : 0;
 		icon = 0;
 		activatedCount = from.activatedCount;
@@ -320,6 +322,7 @@ public:
 	Impix impix;
 	Anim *anim;
 	QIcon *icon;
+	mutable QByteArray rawData;

 	int activatedCount;
 	friend class PsiIcon;
@@ -447,6 +450,24 @@ const QIcon &PsiIcon::icon() const
 	return *d->icon;
 }

+#ifdef WEBKIT
+/**
+ * Returns original image data
+ */
+const QByteArray & PsiIcon::raw() const
+{
+	if (!(d->rawData.size())) {
+		QPixmap pix = impix().pixmap();
+		if (!pix.isNull()) {
+			QBuffer buffer(&d->rawData);
+			buffer.open(QIODevice::WriteOnly);
+			pix.save(&buffer, "PNG");
+		}
+	}
+	return d->rawData;
+}
+#endif
+
 /**
  * Sets the PsiIcon impix to \a impix.
  * \sa impix()
@@ -683,7 +704,11 @@ bool PsiIcon::blockSignals(bool b)
 bool PsiIcon::loadFromData(const QByteArray &ba, bool isAnim)
 {
 	detach();
-
+#ifdef WEBKIT
+	if (isAnim) {
+		d->rawData = ba;
+	}
+#endif
 	bool ret = false;
 	if ( isAnim ) {
 		Anim *anim = new Anim(ba);
@@ -961,6 +986,20 @@ const QStringList IconsetFactory::icons(
 	return IconsetFactoryPrivate::instance()->icons();
 }

+#ifdef WEBKIT
+/**
+ * Returs image raw data aka original image
+ */
+const QByteArray IconsetFactory::raw(const QString &name)
+{
+	const PsiIcon *i = iconPtr(name);
+	if ( i ) {
+		return i->raw();
+	}
+	return QByteArray();
+}
+#endif
+
 //----------------------------------------------------------------------------
 // Iconset
 //----------------------------------------------------------------------------
--- psi.orig/src/tools/iconset/iconset.h
+++ psi/src/tools/iconset/iconset.h
@@ -119,6 +119,9 @@ public:
 	virtual const QPixmap &pixmap() const;
 	virtual const QImage &image() const;
 	virtual const QIcon & icon() const;
+#ifdef WEBKIT
+	virtual const QByteArray & raw() const;
+#endif

 	virtual const Impix &impix() const;
 	virtual const Impix &frameImpix() const;
@@ -236,6 +239,9 @@ public:

 	static const PsiIcon *iconPtr(const QString &name);
 	static const QStringList icons();
+#ifdef WEBKIT
+	static const QByteArray raw(const QString &name);
+#endif
 };

 #endif
--- psi.orig/src/webview.cpp
+++ psi/src/webview.cpp
@@ -0,0 +1,207 @@
+/*
+ * webview.cpp - QWebView handling links and copying text
+ * Copyright (C) 2010 senu, Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include <QWebFrame>
+#include <QFile>
+#include <QMimeData>
+#include <QApplication>
+#include <QStyle>
+
+#include "webview.h"
+#include "urlobject.h"
+#include "textutil.h"
+
+WebView::WebView(QWidget* parent) : QWebView(parent), possibleDragging(false), isLoading_(false)
+{
+
+    settings()->setAttribute(QWebSettings::JavaEnabled, false);
+    settings()->setAttribute(QWebSettings::PluginsEnabled, false);
+	setAcceptDrops(false);
+
+	page()->setNetworkAccessManager(NetworkAccessManager::instance());
+    page()->setLinkDelegationPolicy(QWebPage::DelegateAllLinks);
+
+	NetworkAccessManager::instance()->setSchemeHandler("icon", new IconHandler());
+
+	connect(page(), SIGNAL(linkClicked(const QUrl&)), this, SLOT(linkClickedEvent(const QUrl&)));
+	connect(page()->action(QWebPage::Copy), SIGNAL(triggered()), SLOT(textCopiedEvent()));
+	connect(page()->action(QWebPage::Cut), SIGNAL(triggered()), SLOT(textCopiedEvent()));
+	connect(page(), SIGNAL(loadStarted()), this, SLOT(loadStartedEvent()));
+	connect(page(), SIGNAL(loadFinished(bool)), this, SLOT(loadFinishedEvent(bool)));
+}
+
+void WebView::linkClickedEvent(const QUrl& url)
+{
+	//qDebug()<<"clicked link: "<<url.toString();
+	URLObject::getInstance()->popupAction(url.toEncoded());
+}
+
+void WebView::loadStartedEvent()
+{
+	//qDebug("page load started");
+	isLoading_ = true;
+}
+
+void WebView::loadFinishedEvent(bool success)
+{
+	//qDebug("page load finished");
+	if (!success) {
+		qDebug("webview page load failed");
+	}
+	isLoading_ = false;
+}
+
+void WebView::contextMenuEvent(QContextMenuEvent* event)
+{
+	if (isLoading_) return;
+	QWebHitTestResult r = page()->mainFrame()->hitTestContent(event->pos());
+	QMenu *menu;
+
+	if (!r.linkUrl().isEmpty()) {
+		menu = URLObject::getInstance()->createPopupMenu(r.linkUrl().toEncoded());
+		//menu->addAction(pageAction(QWebPage::CopyLinkToClipboard));
+	} else {
+		menu = new QMenu(this);
+		if (!page()->selectedText().isEmpty()) {
+			menu->addAction(pageAction(QWebPage::Copy));
+		} else {
+			if (!menu->isEmpty()) {
+				menu->addSeparator();
+			}
+#if QT_VERSION >= 0x040500
+			menu->addAction(pageAction(QWebPage::SelectAll));
+#endif
+		}
+		if (settings()->testAttribute(QWebSettings::DeveloperExtrasEnabled)) {
+			menu->addAction(pageAction(QWebPage::InspectElement));
+		}
+	}
+	menu->exec(mapToGlobal(event->pos()));
+	event->accept();
+	delete menu;
+}
+
+void WebView::mousePressEvent ( QMouseEvent * event )
+{
+	if (isLoading_) return;
+	QWebView::mousePressEvent(event);
+	if (event->buttons() & Qt::LeftButton) {
+		QWebHitTestResult r = page()->mainFrame()->hitTestContent(event->pos());
+		QSize cs = page()->mainFrame()->contentsSize();
+		QSize vs = page()->viewportSize();
+		possibleDragging = r.isContentSelected() &&
+			QRect(QPoint(0,0),
+				  cs - QSize(cs.width()>vs.width()?1:0, cs.height()>vs.height()?1:0) *
+					style()->pixelMetric(QStyle::PM_ScrollBarExtent)
+				 ).contains(event->pos());
+		dragStartPosition = event->pos();
+	} else {
+		possibleDragging = false;
+	}
+}
+
+void WebView::mouseReleaseEvent ( QMouseEvent * event )
+{
+	QWebView::mouseReleaseEvent(event);
+	possibleDragging = false;
+#ifdef Q_WS_X11
+	if (!page()->selectedText().isEmpty()) {
+		convertClipboardHtmlImages(QClipboard::Selection);
+	}
+#endif
+}
+
+void WebView::mouseMoveEvent(QMouseEvent *event)
+ {
+	//QWebView::mouseMoveEvent(event);
+	if (!possibleDragging || !(event->buttons() & Qt::LeftButton)) {
+		QWebView::mouseMoveEvent(event);
+		return;
+	}
+	if ((event->pos() - dragStartPosition).manhattanLength()
+		< QApplication::startDragDistance())
+		return;
+
+	QDrag *drag = new QDrag(this);
+	QMimeData *mimeData = new QMimeData;
+
+	QString html = selectedHtml();
+	mimeData->setHtml(html);
+	mimeData->setText(TextUtil::rich2plain(html));
+
+	drag->setMimeData(mimeData);
+	drag->exec(Qt::CopyAction);
+}
+
+void WebView::convertClipboardHtmlImages(QClipboard::Mode mode)
+{
+	QClipboard *cb = QApplication::clipboard();
+	//qDebug("text selection before: %s", qPrintable(cb->text(mode)));
+	QString html = TextUtil::img2title(cb->mimeData(mode)->html());
+	QMimeData *data = new QMimeData;
+	data->setHtml(html);
+	data->setText(TextUtil::rich2plain(html));
+	cb->setMimeData(data, mode);
+	//qDebug("selection: %s", qPrintable(cb->mimeData(mode)->text()));
+}
+
+void WebView::evaluateJS(const QString &scriptSource)
+{
+	//qDebug()<< "EVALUATE: " << (scriptSource.size()>200?scriptSource.mid(0,200)+"...":scriptSource);
+	page()->mainFrame()->evaluateJavaScript(scriptSource);
+}
+
+QString WebView::selectedHtml()
+{
+	// WARNING: selectedHtml must be implemented in qt-4.8 and
+	// this ugly hack will become useless
+	QClipboard *clipboard = QApplication::clipboard();
+	QMimeData *originalData = new QMimeData;
+	foreach (QString format, clipboard->mimeData(QClipboard::Clipboard)->formats()) {
+		originalData->setData(format, clipboard->mimeData(QClipboard::Clipboard)->data(format));
+	}
+	copySelected();
+
+	QString html = clipboard->mimeData()->html();
+	clipboard->setMimeData(originalData);
+
+	return html;
+}
+
+QString WebView::selectedText()
+{
+	return TextUtil::rich2plain(selectedHtml());
+}
+
+void WebView::copySelected()
+{
+	// use native selectedText w/o clipboard hacks.
+	// ideally we should call something like hasSelection() but there is no such method in Qt API for webkit classes.
+	if (!page()->selectedText().isEmpty()) {
+		page()->triggerAction(QWebPage::Copy);
+		textCopiedEvent();
+	}
+	//qDebug("copied text: %s", qPrintable(QApplication::clipboard()->text(QClipboard::Clipboard)));
+}
+
+void WebView::textCopiedEvent()
+{
+	convertClipboardHtmlImages(QClipboard::Clipboard);
+}
--- psi.orig/src/webview.h
+++ psi/src/webview.h
@@ -0,0 +1,107 @@
+/*
+ * webview.h - QWebView handling links and copying text
+ * Copyright (C) 2010 senu, Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef _WEBVIEW_H
+#define	_WEBVIEW_H
+
+#include <QWebView>
+#include <QMessageBox>
+#include <QMenu>
+#include <QContextMenuEvent>
+#include <QClipboard>
+#include <QBuffer>
+
+#include "networkaccessmanager.h"
+#include "iconset.h"
+
+class IconHandler : public NAMSchemeHandler
+{
+	QByteArray data(const QUrl &url) const {
+		int w = url.queryItemValue("w").toInt();
+		int h = url.queryItemValue("h").toInt();
+		PsiIcon icon = IconsetFactory::icon(url.path());
+		if (w && h && !icon.isAnimated()) {
+			QByteArray ba;
+			QBuffer buffer(&ba);
+			buffer.open(QIODevice::WriteOnly);
+			icon.pixmap().scaled(w, h, Qt::KeepAspectRatio, Qt::SmoothTransformation)
+					.toImage().save(&buffer, "PNG");
+			return ba;
+		} else { //scaling impossible, return as is. do scaling with help of css or html attributes
+			return IconsetFactory::raw(url.path());
+		}
+	}
+};
+
+/**
+ * Extended QWebView.
+ *
+ * It's used in EventView and HTMLChatView.
+ * Provides evaluateJavaScript escaping and secure NetworkManager with icon:// URL
+ * support and \<img\> whitelisting.
+ *
+ * Better name for it would be: PsiWebView, but it's used in HTMLChatView which is
+ * Psi-unaware.
+ */
+class WebView : public QWebView {
+
+    Q_OBJECT
+public:
+
+	WebView(QWidget* parent);
+
+	/** Evaluates JavaScript code */
+	void evaluateJS(const QString &scriptSource = "");
+
+	QString selectedHtml();
+	QString selectedText();
+	bool isLoading() { return isLoading_; }
+
+public slots:
+	void copySelected();
+
+protected:
+    /** Creates menu with Copy actions */
+	void contextMenuEvent(QContextMenuEvent* event);
+	void mousePressEvent ( QMouseEvent * event );
+	void mouseReleaseEvent ( QMouseEvent * event );
+	void mouseMoveEvent(QMouseEvent *event);
+
+	//QAction* copyAction, *copyLinkAction;
+
+private:
+	void convertClipboardHtmlImages(QClipboard::Mode);
+
+	bool possibleDragging;
+	bool isLoading_;
+	QStringList jsBuffer_;
+	QPoint dragStartPosition;
+
+
+protected slots:
+	void linkClickedEvent(const QUrl& url);
+	void textCopiedEvent();
+	void loadStartedEvent();
+	void loadFinishedEvent(bool);
+};
+
+
+#endif
+
--- psi.orig/src/widgets/iconselect.cpp
+++ psi/src/widgets/iconselect.cpp
@@ -104,10 +104,6 @@ signals:
 	void iconSelected(const PsiIcon *);
 	void textSelected(QString);

-public slots:
-	void aboutToShow() { iconStart(); }
-	void aboutToHide() { iconStop();  }
-
 private:
 	void iconStart()
 	{
@@ -147,8 +143,8 @@ private:
 		}
 	}

-	void enterEvent(QEvent *) { setFocus();   update(); } // focus follows mouse mode
-	void leaveEvent(QEvent *) { clearFocus(); update(); }
+	void enterEvent(QEvent *) { iconStart(); setFocus();  update(); } // focus follows mouse mode
+	void leaveEvent(QEvent *) { iconStop(); clearFocus(); update(); }

 private slots:
 	void iconUpdated()
@@ -338,8 +334,8 @@ void IconSelect::setIconset(const Iconse
 		connect (b, SIGNAL(iconSelected(const PsiIcon *)), menu, SIGNAL(iconSelected(const PsiIcon *)));
 		connect (b, SIGNAL(textSelected(QString)), menu, SIGNAL(textSelected(QString)));

-		connect (menu, SIGNAL(aboutToShow()), b, SLOT(aboutToShow()));
-		connect (menu, SIGNAL(aboutToHide()), b, SLOT(aboutToHide()));
+		//connect (menu, SIGNAL(aboutToShow()), b, SLOT(aboutToShow()));
+		//connect (menu, SIGNAL(aboutToHide()), b, SLOT(aboutToHide()));

 		if (++column >= size) {
 			++row;
--- psi.orig/themes/chatview/adium/adapter.js
+++ psi/themes/chatview/adium/adapter.js
@@ -0,0 +1,363 @@
+try {
+
+window[chatServer.jsNamespace()].adapter = {
+	loadTheme : function() {
+		var chat = window[chatServer.jsNamespace()];
+		//chat.console("DEBUG: 1");
+		var resources = ["Template.html", "FileTransferRequest.html",
+		"Footer.html", "Header.html", "Status.html", "Topic.html", "Content.html",
+		"Incoming/Content.html", "Incoming/NextContent.html",
+		"Incoming/Context.html", "Incoming/NextContext.html",
+		"Outgoing/Content.html", "Outgoing/NextContent.html",
+		"Outgoing/Context.html", "Outgoing/NextContext.html"];
+		for (var i=0; i<resources.length; i++) {
+			var content = chatServer.getFileContents("Contents/Resources/" + resources[i]) ||
+						chatServer.getFileContents("Contents/Resources/" + resources[i].toLowerCase());
+			if (content.length) {
+				chatServer.toCache(resources[i], content);
+			}
+		}
+		//chat.console("DEBUG: 2");
+		var ipDoc = chat.util.loadXML("Contents/Info.plist");
+		var xres = ipDoc.evaluate("/plist/dict/*", ipDoc, null, null, null);
+		var e;
+		var curKey = "";
+		var ip = {variants: {}};
+		var varKey = null;
+		var value;
+		while (e = xres.iterateNext()) {
+			//chat.console("DEBUG: " + e.textContent);
+			switch(e.tagName) {
+				case "key":
+					curKey = e.textContent.split(':');
+					varKey = null;
+					if (curKey.length == 2) {
+						varKey = curKey[1];
+					}
+					curKey = curKey[0];
+					continue;
+				case "string":
+					value = e.textContent;
+					break;
+				case "integer":
+					value = Number(e.textContent);
+					break;
+				case "false":
+					value = false;
+					break;
+				case "true":
+					value = true;
+					break;
+				default:
+					value = undefined;
+			}
+			//chat.console("DEBUG: 2.5");
+			if (varKey) {
+				if (!ip.variants[varKey]) {
+					ip.variants[varKey] = {};
+				}
+				ip.variants[varKey][curKey] = value;
+			} else {
+				ip[curKey] = value;
+			}
+		}
+		//chat.console("DEBUG: 3");
+		var baseHtml = chatServer.cache("Template.html");
+		if (baseHtml) {
+			chatServer.toCache("html", baseHtml);
+			if (!ip.MessageViewVersion) { // is not set. trying to guess
+				if (baseHtml.indexOf("replaceLastMessage") != -1) {
+					ip.MessageViewVersion = 4;
+				} else if (baseHtml.indexOf("appendMessageNoScroll") != -1) {
+					ip.MessageViewVersion = 3;
+				} else  {
+					ip.MessageViewVersion = 2; // or less
+				}
+			}
+		} else {
+			chatServer.toCache("html", chatServer.getFileContentsFromAdapterDir("Template.html"));
+			ip.MessageViewVersion = 4;
+		}
+		chatServer.toCache("Info.plist", ip);
+		chatServer.setMetaData({name: ip.CFBundleName});
+		var jsRootName = "_adiumChat"+Math.round(1000*Math.random());
+		window[jsRootName] = window[chatServer.jsNamespace()];
+		chatServer.setJSNamespace(jsRootName);
+		chatServer.setDefaultAvatar("Contents/Resources/Incoming/buddy_icon.png", "incoming");
+		chatServer.setDefaultAvatar("Contents/Resources/Outgoing/buddy_icon.png", "outgoing");
+		return "ok";
+	}
+}
+
+// update apapter with methods having some private part
+window[chatServer.jsNamespace()].util.updateObject(window[chatServer.jsNamespace()].adapter, function(){
+	var chat = window[chatServer.jsNamespace()];
+	var server = window.chatServer;
+	var session = null;
+	var dateFormat = "hh:mm";
+	var cdata;
+	var proxyEl = document.createElement("div");
+
+	function TemplateVar(name, param) {
+		this.name = name;
+		this.param = param
+	}
+
+	TemplateVar.prototype = {
+		toString : function() {
+			//chat.console("DEBUG: TemplateVar.prototype.toString " + session);
+			var d = cdata[this.name];
+			if (this.name == "sender") { //may not be html
+				d = chat.util.escapeHtml(d);
+			} else if (d instanceof Date) {
+				d = server.formatDate(d, "yyyy-MM-dd");
+			} else if (this.name == "userIconPath") {
+				return "avatar://" + (cdata.local?"outgoing/":"incoming/") +
+					encodeURIComponent(session.account()) +
+					"/" + encodeURIComponent(cdata.userid);
+			} else if (this.name == "incomingIconPath") {
+				return "avatar://incoming/" + encodeURIComponent(session.account()) +
+					"/" + encodeURIComponent(session.jid());
+			} else if (this.name == "senderColor") {
+				return session.mucNickColor(cdata.sender, cdata.local);
+			}
+			return d || "";
+		}
+	}
+
+	function TemplateTimeVar(name, param) {
+		this.name = name;
+		if (param) {
+			var i, r = {y:'yy',Y:'yyyy',m:'MM',d:'dd',H:'hh',M:'mm',S:'ss'};
+			var m = param.split(/%([a-zA-Z]+)/)
+			for (i=0; i<m.length; i++) {
+				m[i] = r[m[i]] || m[i];
+			}
+			this.format = m.join("");
+		} else {
+			this.format = dateFormat
+		}
+	}
+
+	TemplateTimeVar.prototype.toString = function() {
+		//chat.console("DEBUG: TemplateTimeVar.prototype.toString");
+		return cdata[this.name] instanceof Date?
+			server.formatDate(cdata[this.name], this.format) :
+			(cdata[this.name] ? cdata[this.name] : "");
+	}
+
+	function Template(raw) {
+		var splitted = raw.split(/(%[\w]+(?:\{[\w:%]+\})?%)/), i;
+		this.parts = [];
+
+		for (i = 0; i < splitted.length; i++) {
+			var m = splitted[i].match(/%([\w]+)(?:\{([\w:%]+)\})?%/);
+			if (m) {
+				this.parts.push(m[1] in tvConstructors
+					? new tvConstructors[m[1]](m[1], m[2])
+					: new TemplateVar(m[1], m[2]));
+			} else {
+				this.parts.push(splitted[i]);
+			}
+		}
+	}
+
+	Template.prototype.toString = function(data) {
+		chat.console("prepare Template.prototype.toString1");
+		cdata = data || cdata;
+		var html = this.parts.join("");
+		proxyEl.innerHTML = html;
+		chat.util.replaceIcons(proxyEl);
+		chat.console("prepare Template.prototype.toString2");
+		return proxyEl.innerHTML;
+	}
+
+	// Template variable constructors
+	var tvConstructors = {
+		time : TemplateTimeVar,
+		timeOpened : TemplateTimeVar
+	}
+
+	function psiOption(name) {
+		return eval("[" + server.psiOption(name) + "][0]")
+	}
+
+	return {
+		getHtml : function() {
+			session = window.chatSession; // global session because Template needs it
+
+			//chat.console("prepare html");
+			var html = server.cache("html");
+			var ip = server.cache("Info.plist");
+			var variant = ip.DefaultVariant;
+			if (variant && ip.variants[variant]) {
+				chat.util.updateObject(ip, ip.variants[variant]);
+			}
+			////chat.console("prepare html2");
+			var topHtml = (session.isMuc() && server.cache("Topic.html")) || server.cache("Header.html");
+			//chat.console("prepare html2.5");
+			topHtml = topHtml? (new Template(topHtml)).toString({
+				chatName: chat.util.escapeHtml(session.chatName()),
+				timeOpened: new Date()
+			}) : "";
+			//chat.console("prepare html3");
+			var footerHtml = new Template(server.cache("Footer.html") || "").toString({});
+			footerHtml += "\n<script type='text/javascript'>window.addEventListener('load', "+
+				server.jsNamespace()+".adapter.initSession, false);</script>";
+			//chat.console("prepare html4");
+			if (ip.MessageViewVersion < 3) {
+				var replace = [
+					"/Contents/Resources//", "main.css",
+					topHtml, footerHtml
+				];
+			} else {
+				var replace = [
+					"/Contents/Resources//", "@import url( \"main.css\" );",
+					ip.DefaultVariant? "Variants/" + ip.DefaultVariant + ".css" : "main.css",
+					topHtml, footerHtml
+				];
+			}
+			//chat.console("prepare html5");
+			html = html.replace(/%@/g, function(){return replace.shift() || ""});
+
+			var styles = [];
+			if (ip.DefaultBackgroundColor) {
+				styles.push("background-color:#"+ip.DefaultBackgroundColor);
+			}
+			if (ip.DefaultFontFamily) {
+				styles.push("font-family:"+ip.DefaultFontFamily);
+			}
+			if (ip.DefaultFontSize) {
+				styles.push("font-size:"+ip.DefaultFontSize+"pt");
+			}
+			//chat.console("prepare html: " + html);
+
+			return html.replace("==bodyBackground==", styles.join(";"));
+		},
+		initSession : function() {
+			chat.console("init session");
+			session = window.chatSession;
+			chat.adapter.initSession = null;
+			chat.adapter.loadTheme = null;
+			chat.adapter.getHtml = null;
+			var trackbar = null;
+			var ip = server.cache("Info.plist");
+			var prevGrouppingData = null;
+			var groupping = !(ip.DisableCombineConsecutive == true);
+
+			chat.adapter.receiveObject = function(data) {
+				cdata = data;
+				try {
+					//chat.console(chat.util.props(data, true))
+					var template;
+					if (data.type == "message") {
+						if (data.mtype != "message") {
+							prevGrouppingData = null;
+						}
+						switch (data.mtype) {
+							case "message":
+								data.nextOfGroup = groupping && !!(prevGrouppingData &&
+									(prevGrouppingData.type == cdata.type) &&
+									(prevGrouppingData.mtype == cdata.mtype) &&
+									(prevGrouppingData.userid == cdata.userid) &&
+									(prevGrouppingData.emote == cdata.emote) &&
+									(prevGrouppingData.local == cdata.local));
+
+								if (data.nextOfGroup) {
+									template = data.local?templates.outgoingNextContent:templates.incomingNextContent;
+								} else {
+									template = data.local?templates.outgoingContent:templates.incomingContent;
+								}
+								prevGrouppingData = data;
+								data.senderStatusIcon="icon:status/online"; //FIXME temporary hack
+								break;
+							case "status":
+							case "system":
+								if (data["usertext"]) {
+									data["message"] += " (" + data["usertext"] + ")"
+								}
+								template = templates.status;
+								break;
+							case "lastDate":
+								data["message"] = data["date"];
+								data["time"] = "&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;"; //fixes some themes =)
+								template = templates.status;
+								break;
+							case "subject": //its better to init with proper templates on start than do comparision like below
+								template = templates.status;
+								var e = document.getElementById("topic");
+								if (e) {
+									e.innerHTML = data["usertext"]
+								} else {
+									data["message"] += ("<br/>" + data["usertext"]);
+								}
+								break;
+							case "urls":
+								var i, urls=[];
+								for (url in data.urls) {
+									urls.push('<a href="'+url+'">'+(data.urls[url]?chat.util.escapeHtml(data.urls[url]):url)+"</a>");
+								}
+								data["message"] = urls.join("<br/>");
+								template = templates.status;
+								break;
+						}
+						if (template) {
+							if (data.nextOfGroup) {
+								appendNextMessage(template.toString(data));
+							} else {
+								appendMessage(template.toString(data));
+							}
+							if (data.mtype == "message" && data.local) {
+								scrollToBottom();
+							}
+						} else {
+							throw "Template not found";
+						}
+					} else if (data.type == "clear") {
+						prevGrouppingData = null; //groupping impossible
+						trackbar = null;
+					}
+				} catch(e) {
+					chat.util.showCriticalError("APPEND ERROR: " + e + " \nline: " + e.line)
+				}
+			};
+
+			var t = {};
+			var templates = {}
+			var tcList = ["Status.html", "Content.html",
+				"Incoming/Content.html", "Incoming/NextContent.html",
+				"Incoming/Context.html", "Incoming/NextContext.html",
+				"Outgoing/Content.html", "Outgoing/NextContent.html",
+				"Outgoing/Context.html", "Outgoing/NextContext.html"];
+			var i
+			for (i=0; i<tcList.length; i++) {
+				var content = server.cache(tcList[i]);
+				if (content) {
+					t[tcList[i]] = new Template(content);
+				}
+			}
+			templates.content = t["Content.html"] || "%message%";
+			templates.status = t["Status.html"] || t.message;
+			templates.incomingContent = t["Incoming/Content.html"] || templates.content;
+			templates.outgoingContent = t["Outgoing/Content.html"] || templates.incomingContent;
+			templates.incomingNextContent = t["Incoming/NextContent.html"] || templates.incomingContent;
+			templates.outgoingNextContent = t["Outgoing/NextContent.html"] || templates.outgoingContent;
+			templates.incomingContext = t["Incoming/Context.html"] || templates.incomingContent;
+			templates.outgoingContext = t["Outgoing/Context.html"] || templates.outgoingContent;
+			templates.incomingNextContext = t["Incoming/NextContext.html"] || templates.incomingNextContent;
+			templates.outgoingNextContext = t["Outgoing/NextContext.html"] || templates.outgoingNextContent;
+			delete t
+			//t.lastMsgDate = t.lastMsgDate || t.sys;
+			//t.subject = t.subject || t.sys;
+			//t.urls = t.urls || t.sys;
+			//t.trackbar = t.trackbar || "<hr/>";
+			chat.console("session inited");
+			session.signalInited();
+		}
+	}
+}())
+
+} catch(e) {
+	window[chatServer.jsNamespace()].console("adapter load error!!! "+ e + "(Line:" + e.line + ")");
+}
+"ok"; // just an indicator for script loader
--- psi.orig/themes/chatview/adium/Template.html
+++ psi/themes/chatview/adium/Template.html
@@ -0,0 +1,343 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
+<html>
+<head>
+	<meta http-equiv="content-type" content="text/html; charset=utf-8" />
+	<base href="%@">
+	<script type="text/javascript" defer="defer">
+		// NOTE:
+		// Any percent signs in this file must be escaped!
+		// Use two escape signs (%%) to display it, this is passed through a format call!
+
+		function appendHTML(html) {
+			var node = document.getElementById("Chat");
+			var range = document.createRange();
+			range.selectNode(node);
+			var documentFragment = range.createContextualFragment(html);
+			node.appendChild(documentFragment);
+		}
+
+		// a coalesced HTML object buffers and outputs DOM objects en masse.
+		// saves A LOT of CSS recalculation time when loading many messages.
+		// (ex. a long twitter timeline)
+		function CoalescedHTML() {
+			var self = this;
+			this.fragment = document.createDocumentFragment();
+			this.timeoutID = 0;
+			this.coalesceRounds = 0;
+			this.isCoalescing = false;
+			this.isConsecutive = undefined;
+			this.shouldScroll = undefined;
+
+			var appendElement = function (elem) {
+				document.getElementById("Chat").appendChild(elem);
+			};
+
+			function outputHTML() {
+				var insert = document.getElementById("insert");
+				if(!!insert && self.isConsecutive) {
+					insert.parentNode.replaceChild(self.fragment, insert);
+				} else {
+					if(insert)
+						insert.parentNode.removeChild(insert);
+					// insert the documentFragment into the live DOM
+					appendElement(self.fragment);
+				}
+				alignChat(self.shouldScroll);
+
+				// reset state to empty/non-coalescing
+				self.shouldScroll = undefined;
+				self.isConsecutive = undefined;
+				self.isCoalescing = false;
+				self.coalesceRounds = 0;
+			}
+
+			// creates and returns a new documentFragment, containing all content nodes
+			// which can be inserted as a single node.
+			function createHTMLNode(html) {
+				var range = document.createRange();
+				range.selectNode(document.getElementById("Chat"));
+				return range.createContextualFragment(html);
+			}
+
+			// removes first insert node from the internal fragment.
+			function rmInsertNode() {
+				var insert = self.fragment.querySelector("#insert");
+				if(insert)
+					insert.parentNode.removeChild(insert);
+			}
+
+			function setShouldScroll(flag) {
+				if(flag && undefined === self.shouldScroll)
+					self.shouldScroll = flag;
+			}
+
+			// hook in a custom method to append new data
+			// to the chat.
+			this.setAppendElementMethod = function (func) {
+				if(typeof func === 'function')
+					appendElement = func;
+			}
+
+			// (re)start the coalescing timer.
+			//   we wait 25ms for a new message to come in.
+			//   If we get one, restart the timer and wait another 10ms.
+			//   If not, run outputHTML()
+			//  We do this a maximum of 400 times, for 10s max that can be spent
+			//  coalescing input, since this will block display.
+			this.coalesce = function() {
+				window.clearTimeout(self.timeoutID);
+				self.timeoutID = window.setTimeout(outputHTML, 25);
+				self.isCoalescing = true;
+				self.coalesceRounds += 1;
+				if(400 < self.coalesceRounds)
+					self.cancel();
+			}
+
+			// if we need to append content into an insertion div,
+			// we need to clear the buffer and cancel the timeout.
+			this.cancel = function() {
+				if(self.isCoalescing) {
+					window.clearTimeout(self.timeoutID);
+					outputHTML();
+				}
+			}
+
+
+			// coalased analogs to the global functions
+
+			this.append = function(html, shouldScroll) {
+				// if we started this fragment with a consecuative message,
+				// cancel and output before we continue
+				if(self.isConsecutive) {
+					self.cancel();
+				}
+				self.isConsecutive = false;
+				rmInsertNode();
+				var node = createHTMLNode(html);
+				self.fragment.appendChild(node);
+
+				node = null;
+
+				setShouldScroll(shouldScroll);
+				self.coalesce();
+			}
+
+			this.appendNext = function(html, shouldScroll) {
+				if(undefined === self.isConsecutive)
+					self.isConsecutive = true;
+				var node = createHTMLNode(html);
+				var insert = self.fragment.querySelector("#insert");
+				if(insert) {
+					insert.parentNode.replaceChild(node, insert);
+				} else {
+					self.fragment.appendChild(node);
+				}
+				node = null;
+				setShouldScroll(shouldScroll);
+				self.coalesce();
+			}
+
+			this.replaceLast = function (html, shouldScroll) {
+				rmInsertNode();
+				var node = createHTMLNode(html);
+				var lastMessage = self.fragment.lastChild;
+				lastMessage.parentNode.replaceChild(node, lastMessage);
+				node = null;
+				setShouldScroll(shouldScroll);
+			}
+		}
+		var coalescedHTML;
+
+		//Appending new content to the message view
+		function appendMessage(html) {
+			var shouldScroll;
+
+			// Only call nearBottom() if should scroll is undefined.
+			if(undefined === coalescedHTML.shouldScroll) {
+				shouldScroll = nearBottom();
+			} else {
+				shouldScroll = coalescedHTML.shouldScroll;
+			}
+			appendMessageNoScroll(html, shouldScroll);
+		}
+
+		function appendMessageNoScroll(html, shouldScroll) {
+			shouldScroll = shouldScroll || false;
+			// always try to coalesce new, non-griuped, messages
+			coalescedHTML.append(html, shouldScroll)
+		}
+
+		function appendNextMessage(html){
+			var shouldScroll;
+			if(undefined === coalescedHTML.shouldScroll) {
+				shouldScroll = nearBottom();
+			} else {
+				shouldScroll = coalescedHTML.shouldScroll;
+			}
+			appendNextMessageNoScroll(html, shouldScroll);
+		}
+
+		function appendNextMessageNoScroll(html, shouldScroll){
+			shouldScroll = shouldScroll || false;
+			// only group next messages if we're already coalescing input
+			coalescedHTML.appendNext(html, shouldScroll);
+		}
+
+		function replaceLastMessage(html){
+			var shouldScroll;
+			// only replace messages if we're already coalescing
+			if(coalescedHTML.isCoalescing){
+				if(undefined === coalescedHTML.shouldScroll) {
+					shouldScroll = nearBottom();
+				} else {
+					shouldScroll = coalescedHTML.shouldScroll;
+				}
+				coalescedHTML.replaceLast(html, shouldScroll);
+			} else {
+				shouldScroll = nearBottom();
+				//Retrieve the current insertion point, then remove it
+				//This requires that there have been an insertion point... is there a better way to retrieve the last element? -evands
+				var insert = document.getElementById("insert");
+				if(insert){
+					var parentNode = insert.parentNode;
+					parentNode.removeChild(insert);
+					var lastMessage = document.getElementById("Chat").lastChild;
+					document.getElementById("Chat").removeChild(lastMessage);
+				}
+
+				//Now append the message itself
+				appendHTML(html);
+
+				alignChat(shouldScroll);
+			}
+		}
+
+		//Auto-scroll to bottom.  Use nearBottom to determine if a scrollToBottom is desired.
+		function nearBottom() {
+			return ( document.body.scrollTop >= ( document.body.offsetHeight - ( window.innerHeight * 1.2 ) ) );
+		}
+		function scrollToBottom() {
+			document.body.scrollTop = document.body.offsetHeight;
+		}
+
+		//Dynamically exchange the active stylesheet
+		function setStylesheet( id, url ) {
+			var code = "<style id=\"" + id + "\" type=\"text/css\" media=\"screen,print\">";
+			if( url.length )
+				code += "@import url( \"" + url + "\" );";
+			code += "</style>";
+			var range = document.createRange();
+			var head = document.getElementsByTagName( "head" ).item(0);
+			range.selectNode( head );
+			var documentFragment = range.createContextualFragment( code );
+			head.removeChild( document.getElementById( id ) );
+			head.appendChild( documentFragment );
+		}
+
+		/* Converts emoticon images to textual emoticons; all emoticons in message if alt is held */
+		document.onclick = function imageCheck() {
+			var node = event.target;
+			if (node.tagName.toLowerCase() != 'img')
+				return;
+
+			imageSwap(node, false);
+		}
+
+		/* Converts textual emoticons to images if textToImagesFlag is true, otherwise vice versa */
+		function imageSwap(node, textToImagesFlag) {
+			var shouldScroll = nearBottom();
+
+			var images = [node];
+			if (event.altKey) {
+				while (node.id != "Chat" && node.parentNode.id != "Chat")
+					node = node.parentNode;
+				images = node.querySelectorAll(textToImagesFlag ? "a" : "img");
+			}
+
+			for (var i = 0; i < images.length; i++) {
+				textToImagesFlag ? textToImage(images[i]) : imageToText(images[i]);
+			}
+
+			alignChat(shouldScroll);
+		}
+
+		function textToImage(node) {
+			if (!node.getAttribute("isEmoticon"))
+				return;
+			//Swap the image/text
+			var img = document.createElement('img');
+			img.setAttribute('src', node.getAttribute('src'));
+			img.setAttribute('alt', node.firstChild.nodeValue);
+			img.className = node.className;
+			node.parentNode.replaceChild(img, node);
+		}
+
+		function imageToText(node)
+		{
+			if (client.zoomImage(node) || !node.alt)
+				return;
+			var a = document.createElement('a');
+			a.setAttribute('onclick', 'imageSwap(this, true)');
+			a.setAttribute('src', node.getAttribute('src'));
+			a.setAttribute('isEmoticon', true);
+			a.className = node.className;
+			var text = document.createTextNode(node.alt);
+			a.appendChild(text);
+			node.parentNode.replaceChild(a, node);
+		}
+
+		//Align our chat to the bottom of the window.  If true is passed, view will also be scrolled down
+		function alignChat(shouldScroll) {
+			var windowHeight = window.innerHeight;
+
+			if (windowHeight > 0) {
+				var contentElement = document.getElementById('Chat');
+				var contentHeight = contentElement.offsetHeight;
+				if (windowHeight - contentHeight > 0) {
+					contentElement.style.position = 'relative';
+					contentElement.style.top = (windowHeight - contentHeight) + 'px';
+				} else {
+					contentElement.style.position = 'static';
+				}
+			}
+
+			if (shouldScroll) scrollToBottom();
+		}
+
+		window.onresize = function windowDidResize(){
+			alignChat(true/*nearBottom()*/); //nearBottom buggy with inactive tabs
+		}
+
+		function initStyle() {
+			alignChat(true);
+			if(!coalescedHTML)
+				coalescedHTML = new CoalescedHTML();
+		}
+	</script>
+
+	<style type="text/css">
+		.actionMessageUserName { display:none; }
+		.actionMessageBody:before { content:"*"; }
+		.actionMessageBody:after { content:"*"; }
+		* { word-wrap:break-word; text-rendering: optimizelegibility; }
+		img.scaledToFitImage { height: auto; max-width: 100%%; }
+	</style>
+
+	<!-- This style is shared by all variants. !-->
+	<style id="baseStyle" type="text/css" media="screen,print">
+		%@
+	</style>
+
+	<!-- Although we call this mainStyle for legacy reasons, it's actually the variant style !-->
+	<style id="mainStyle" type="text/css" media="screen,print">
+		@import url( "%@" );
+	</style>
+
+</head>
+<body onload="initStyle();" style="==bodyBackground==">
+%@
+<div id="Chat">
+</div>
+%@
+</body>
+</html>
--- psi.orig/themes/chatview/psi/adapter.js
+++ psi/themes/chatview/psi/adapter.js
@@ -0,0 +1,260 @@
+try {
+
+window[chatServer.jsNamespace()].adapter = {
+	loadTheme : function() {
+        chatServer.setHtml(chatServer.getFileContents("index.html"));
+        eval(chatServer.getFileContents("load.js"));
+		return "ok";
+	},
+	initSession : function() {
+		var chat = window[chatServer.jsNamespace()];
+		var trackbar = null;
+		var inited = false;
+		var proxy = null;
+
+		var shared = {
+			templates : {},
+			server : window.chatServer,
+			session : window.chatSession,
+			isMuc : window.chatSession.isMuc(),
+			accountId : window.chatSession.account(),
+			dateFormat : "hh:mm:ss",
+			scroller : null,
+			varHandlers : {},
+			prevGrouppingData : null,
+			groupping : false,
+			chatElement : null,
+
+			TemplateVar : function(name) {
+				this.name = name;
+			},
+
+			Template : function(raw) {
+				var splitted = raw.split('%'), i;
+				this.parts = [];
+
+				for (i = 0; i < splitted.length; i++) {
+					if (/^[a-zA-Z]+$/.test(splitted[i])) {
+						this.parts.push(new shared.TemplateVar(splitted[i]));
+					} else if (this.parts.length>0 && typeof(this.parts[this.parts.length-1]) == "string") {
+						this.parts[this.parts.length-1]+=('%'+splitted[i]);
+					} else {
+						this.parts.push(splitted[i]);
+					}
+				}
+			},
+
+			psiOption : function(name) {
+				return eval("[" + shared.server.psiOption(name) + "][0]")
+			},
+
+			colorOption : function(name) {
+				return eval("[" + shared.server.colorOption(name) + "][0]")
+			},
+
+			appendHtml : function(html, scroll, nextEl) { //scroll[true|false|auto/other]
+				if (typeof(scroll) == 'boolean') {
+					shared.scroller.atBottom = scroll;
+				}
+				if (nextEl) {
+					chat.util.siblingHtml(nextEl, html);
+				} else {
+					chat.util.appendHtml(shared.chatElement, html);
+				}
+				shared.scroller.invalidate();
+			},
+
+			stopGroupping : function() {
+				if (shared.prevGrouppingData) {
+					shared.prevGrouppingData.nextEl.parentNode.removeChild(shared.prevGrouppingData.nextEl)
+					shared.prevGrouppingData = null;
+				}
+			},
+
+			initTheme : function(config) {
+				if (inited) {
+					chat.util.showCriticalError("Theme should not be inited twice. Something wrong with theme.")
+					return false;
+				}
+				var t = shared.templates;
+				shared.chatElement = config.chatElement;
+				shared.dateFormat = config.dateFormat || shared.dateFormat;
+				shared.scroller = config.scroller || new chat.WindowScroller(false);
+				shared.groupping = config.groupping || shared.groupping;
+				proxy = config.proxy;
+				shared.varHandlers = config.varHandlers || {};
+				for (var tname in config.templates) {
+					if (config.templates[tname]) {
+						t[tname] = new shared.Template(config.templates[tname]);
+					}
+				}
+				t.message = t.message || "%message%";
+				t.sys = t.sys || "%message%";
+				t.sysMessage = t.sysMessage || t.sys;
+				t.sysMessageUT = t.sysMessageUT || t.sysMessage;
+				t.statusMessage = t.statusMessage || t.sysMessage;
+				t.statusMessageUT = t.statusMessageUT || t.statusMessage;
+				t.sentMessage = t.sentMessage || t.message;
+				t.receivedMessage = t.receivedMessage || t.message;
+				t.spooledMessage = t.spooledMessage || t.message;
+				t.receivedMessageGroupping = t.receivedMessageGroupping || t.messageGroupping;
+				t.sentMessageGroupping = t.sentMessageGroupping || t.messageGroupping;
+				t.lastMsgDate = t.lastMsgDate || t.sys;
+				t.subject = t.subject || t.sys;
+				t.urls = t.urls || t.sys;
+				t.trackbar = t.trackbar || "<hr/>";
+				config.defaultAvatar && shared.server.setDefaultAvatar(config.defaultAvatar)
+				config.avatarSize && shared.server.setAvatarSize(config.avatarSize.width, config.avatarSize.height);
+				inited = true;
+			},
+			checkNextOfGroup : function() {
+				shared.cdata.nextOfGroup = !!(shared.prevGrouppingData &&
+									(shared.prevGrouppingData.type == shared.cdata.type) &&
+									(shared.prevGrouppingData.mtype == shared.cdata.mtype) &&
+									(shared.prevGrouppingData.userid == shared.cdata.userid) &&
+									(shared.prevGrouppingData.emote == shared.cdata.emote) &&
+									(shared.prevGrouppingData.local == shared.cdata.local));
+				return shared.cdata.nextOfGroup;
+			}
+		};
+
+        // internationalization
+        function tr(text)
+        {
+            // TODO translate
+            return text;
+        }
+
+        // accepts some templater object and object with 2 optional methods: "pre" and "post(text)"
+        function proxyTemplate(template, handlers)
+        {
+            return {"toString": function(){
+                if(handlers.pre) handlers.pre();
+                var result = template.toString();
+                if(handlers.post) result = handlers.post(result);
+                return result;
+            }}
+        }
+
+		shared.TemplateVar.prototype = {
+			toString : function() {
+				if (shared.varHandlers[this.name]) {
+					return shared.varHandlers[this.name]();
+				}
+				var d = shared.cdata[this.name];
+				if (this.name == "sender") { //may not be html
+					d = chat.util.escapeHtml(d);
+				} else if (d instanceof Date) {
+					if (this.name == "time") {
+						d = shared.server.formatDate(d, shared.dateFormat);
+					} else { // last message date ?
+						d = shared.server.formatDate(d, "yyyy-MM-dd");
+					}
+				 } else if (this.name == "avatarurl") {
+					return "avatar:" + encodeURIComponent(shared.accountId) +
+						"/" + encodeURIComponent(shared.cdata.userid);
+				} else if (this.name == "next") {
+					shared.cdata.nextEl = "nextMessagePH"+(1000+Math.floor(Math.random()*1000));
+					return '<div id="'+shared.cdata.nextEl +'"></div>';
+				}
+				return d || "";
+			}
+		}
+
+		shared.Template.prototype.toString = function() {
+			return this.parts.join("");
+		}
+
+
+		chat.adapter.receiveObject = function(data) {
+			shared.cdata = data;
+			if (!inited) {
+				chat.util.showCriticalError("A try to output data while theme is not inited. output is impossible.\nCheck if your theme does not have errors.");
+				return;
+			}
+			try {
+				//shared.server.console(chat.util.props(data, true))
+				var template;
+				if (proxy && (template = proxy()) === false) { // proxy stopped processing
+					return; //we don't store shared.prevGrouppingData here, let's proxy do it if needed
+				}
+				if (data.type == "message") {
+					if (data.mtype != "message") {
+						shared.stopGroupping();
+					}
+					if (!template) switch (data.mtype) {
+						case "message":
+							if (shared.checkNextOfGroup()) {
+								template = data.local?shared.templates.sentMessageGroupping:shared.templates.receivedMessageGroupping;
+							}
+							if (!template) {
+								data.nextOfGroup = false; //can't group w/o template
+								template = data.local?shared.templates.sentMessage:shared.templates.receivedMessage;
+							}
+							break;
+                        case "status":
+                            template = data.usertext?shared.templates.statusMessageUT:shared.templates.statusMessage;
+							break;
+						case "system":
+							template = data.usertext?shared.templates.sysMessageUT:shared.templates.sysMessage;
+							break;
+						case "lastDate":
+							template = shared.templates.lastMsgDate;
+							break;
+						case "subject": //its better to init with proper templates on start than do comparision like below
+							template = shared.templates.subject;
+							break;
+						case "urls":
+							var i, urls=[];
+							for (url in data.urls) {
+								urls.push('<a href="'+url+'">'+(data.urls[url]?chat.util.escapeHtml(data.urls[url]):url)+"</a>");
+							}
+							data["message"] = urls.join("<br/>");
+							template = shared.templates.urls;
+							break;
+					}
+					if (template) {
+						shared.appendHtml(template.toString(), data.local?true:null, data.nextOfGroup?
+							shared.prevGrouppingData.nextEl:null); //force scroll on local messages
+						shared.stopGroupping();// safe clean up previous data
+						if (shared.cdata.nextEl) { //convert to DOM
+							shared.cdata.nextEl = document.getElementById(shared.cdata.nextEl);
+							shared.prevGrouppingData = shared.cdata;
+						}
+					} else {
+						throw "Template not found";
+					}
+				} else if (data.type == "trackbar") {
+					if (!trackbar) {
+						trackbar = document.createElement("div");
+						trackbar.innerHTML = shared.templates.trackbar.toString();
+					} else {
+						shared.chatElement.removeChild(trackbar);
+					}
+					shared.chatElement.appendChild(trackbar);
+					shared.scroller.invalidate();
+					shared.stopGroupping(); //groupping impossible
+				} else if (data.type == "clear") {
+					shared.stopGroupping(); //groupping impossible
+					shared.chatElement.innerHTML = "";
+					trackbar = null;
+				}
+			} catch(e) {
+				chat.util.showCriticalError("APPEND ERROR: " + e + " \nline: " + e.line)
+			}
+		};
+
+		chat.adapter.initSession = null;
+		chat.adapter.loadTheme = null;
+		window.chatServer = null;
+		window.chatSession = null;
+		return shared;
+
+	}
+}
+
+
+} catch(e) {
+	window[chatServer.jsNamespace()].console("adapter load error!!! "+e)
+}
+"ok"; // just an indicator for script loader
--- psi.orig/themes/chatview/psi/classic/index.html
+++ psi/themes/chatview/psi/classic/index.html
@@ -0,0 +1,115 @@
+<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
+<html>
+<head>
+  <style type="text/css" media="screen,print">
+body {padding:0 0 2px 0; margin:0; width:100%;}
+body > div {
+	margin:0px 3px 0px 3px;
+	line-height:1.4em;
+	word-wrap:break-word !important;
+	white-space: pre-wrap !important;
+	overflow:hidden;
+}
+body > div img { vertical-align:bottom; }
+.sent {}
+.received {}
+.infmsg {}
+.usertext {}
+.alert {font-weight:bold; color:red;}
+  </style>
+</head>
+<body>
+<script type="text/javascript">
+try {
+
+window[chatServer.jsNamespace()].theme = function() {
+	var nicks = {};
+	var nickNumber = 0;
+	var chat = window[chatServer.jsNamespace()];
+
+	var cssBody = chat.util.findStyleSheet(document.styleSheets[0], "body").style;
+	var cssSentMsg = chat.util.findStyleSheet(document.styleSheets[0], ".sent").style;
+	var cssReceivedMsg = chat.util.findStyleSheet(document.styleSheets[0], ".received").style;
+	var cssInfMsg = chat.util.findStyleSheet(document.styleSheets[0], ".infmsg").style;
+	var cssUserText = chat.util.findStyleSheet(document.styleSheets[0], ".usertext").style;
+	var cssChatSays = chat.util.findStyleSheet(document.styleSheets[0], ".msg>span:first").style;
+
+	var applyPsiSettings = function() {
+		chat.util.updateObject(cssBody, eval("["+shared.session.getFont()+"][0]"));
+		cssBody.color = shared.server.getPaletteTextcolor(); // global message color palette().color(QPalette::Text).name();
+		cssSentMsg.color = shared.colorOption("options.ui.look.colors.messages.sent");
+		cssReceivedMsg.color = shared.colorOption("options.ui.look.colors.messages.received");
+		cssInfMsg.color = shared.colorOption("options.ui.look.colors.messages.informational");
+		cssUserText.color = shared.colorOption("options.ui.look.colors.messages.usertext");
+	}
+
+	var shared = chat.adapter.initSession();
+	shared.initTheme({
+		chatElement : document.body,
+		templates : {
+			message: shared.isMuc?
+				"<div class='msg'><span style='color:%nickcolor%'>[%time%] %sender%</span> %message%</div>"
+				: "<div class='msg'><span class='%sentrec%'>[%time%] %sender%</span> %message%</div>",
+			messageNC: shared.isMuc?
+				"<div style='color:%nickcolor%'>[%time%] %sender% %message%</div>"
+				: "<div class='%sentrec%'>[%time%] %sender% %message%</div>",
+			receivedMessage: shared.isMuc?
+				"<div class='msg'><span style='color:%nickcolor%'>[%time%] %sender%</span> %alertedmessage%</div>"
+				: null,
+			spooledMessage: "<div class='infmsg'>[%time%] %sender% %message%</div>",
+			sys: "<div class='infmsg'>%message%</div>",
+			sysMessage: "<div class='infmsg'>[%time%] *** %message%</div>",
+			sysMessageUT: "<div class='infmsg'>[%time%] *** %message%: <span class='usertext'>%usertext%</span></div>",
+			lastMsgDate: "<div class='infmsg'>*** %date%</div>",
+			subject: shared.isMuc?
+				"<div class='infmsg'>[%time%] %message%<div class='usertext'><b>%usertext%</b></div></div>"
+				: "<div class='infmsg'><b>*** %usertext%</b></div>",
+			trackbar: '<hr style="height:1px; border:1px solid black; border-color:#bbf #66f #66f #bbf" />'
+		},
+		dateFormat : "hh:mm:ss",
+		proxy : function() { //optional
+			if (shared.cdata.type == "settings") {
+				applyPsiSettings();
+				return false;
+			}
+			if (shared.cdata.mtype == "message") {
+				var template = shared.cdata.emote && shared.templates.messageNC ||
+					(shared.cdata.spooled && shared.templates.message || null);
+				if (template) {
+					shared.appendHtml(template.toString(), shared.cdata.local?true:null);
+					return false;
+				}
+			}
+		},
+		varHandlers : {
+			sender : function() {
+				var nick = chat.util.escapeHtml(shared.cdata.sender);
+				return shared.cdata.emote?"*"+nick:"&lt;"+nick+"&gt;";
+			},
+			alertedmessage : function() {
+				return shared.cdata.alert?"<span class='alert'>"+
+					shared.cdata.message+"</span>":shared.cdata.message;
+			},
+			sentrec : function() {return shared.cdata.spooled?"infmsg":
+				(shared.cdata.local?"sent":"received");},
+			nickcolor : function() {
+				return shared.session.mucNickColor(shared.cdata.sender, shared.cdata.local);
+			}
+		}
+	});
+
+	applyPsiSettings();
+
+	shared.session.signalInited();
+
+	return {
+
+	};
+}()
+
+} catch(e) {
+	 document.body.innerHTML = "Theme initialization failed: " + e
+}
+</script>
+</body>
+</html>
--- psi.orig/themes/chatview/psi/classic/load.js
+++ psi/themes/chatview/psi/classic/load.js
@@ -0,0 +1 @@
+chatServer.setMetaData({name: "Classic"});
--- psi.orig/themes/chatview/util.js
+++ psi/themes/chatview/util.js
@@ -0,0 +1,193 @@
+window[chatServer.jsNamespace()] = function() {
+	var htmlSource = document.createElement("div"); //manages appendHtml
+	var server = window.chatServer;
+	var chat =  {
+		console : server.console,
+		adapter : {
+			receiveObject : function(data) {
+				chat.util.showCriticalError("Adapter is not loaded. output impossible!\n\nData was:" + chat.util.props(data));
+			}
+		},
+		util: {
+			showCriticalError : function(text) {
+				var e=document.body || document.documentElement.appendChild(document.createElement("body"));
+				var er = e.appendChild(document.createElement("div"))
+				er.style.cssText = "background-color:red;color:white;border:1px solid black;padding:1em;margin:1em;font-weight:bold";
+				er.innerHTML = chat.util.escapeHtml(text).replace(/\n/, "<br/>");
+			},
+
+			// just for debug
+			escapeHtml : function(html) {
+				return html.split("&").join("&amp;").split( "<").join("&lt;").split(">").join("&gt;");
+			},
+
+			// just for debug
+			props : function(e, rec) {
+				var ret='';
+				for (var i in e) {
+					var gotValue = true;
+					var val = null;
+					try {
+						val = e[i];
+					} catch(err) {
+						val = err.toString();
+						gotValue = false;
+					}
+					if (gotValue) {
+						if (val instanceof Object && rec && val.constructor != Date) {
+							ret+=i+" = "+val.constructor.name+"{"+chat.util.props(val, rec)+"}\n";
+						} else {
+							if (val instanceof Function) {
+								ret+=i+" = Function: "+i+"\n";
+							} else {
+								ret+=i+" = "+(val === null?"null\n":val.constructor.name+"(\""+val+"\")\n");
+							}
+						}
+					} else {
+						ret+=i+" = [CAN'T GET VALUE: "+val+"]\n";
+					}
+				}
+				return ret;
+			},
+
+			// replaces <icon name="icon_name" text="icon_text" />
+			// with <img src="icon://psi/icon_name" title="icon_text" />
+			icon2img : function (obj) {
+			   var img = document.createElement('img');
+			   img.src = "icon:" + obj.getAttribute("name");
+			   img.title = obj.getAttribute("text");
+			   var ib = obj.nextSibling
+			   while (obj.firstChild) obj.parentNode.insertBefore(obj.firstChild, ib);
+			   obj.parentNode.replaceChild(img, obj);
+			},
+
+			// replaces all occurrence of <icon> by function above
+			replaceIcons : function(el) {
+				var icon, icons = [], i, els;
+				while (true) {
+					els = el.getElementsByTagName("icon");
+					if (els.length == 0) break;
+					for (i=0; i<els.length; i++) {
+						chat.util.icon2img(els[i]);
+					}
+				}
+			},
+
+			updateObject : function(object, update) {
+				for (var i in update) {
+					object[i] = update[i]
+				}
+			},
+
+			findStyleSheet : function (sheet, selector) {
+				for (var i=0; i<sheet.cssRules.length; i++) {
+					if (sheet.cssRules[i].selectorText == selector)
+						return sheet.cssRules[i];
+				}
+				return false;
+			},
+
+			appendHtml : function(dest, html) {
+				htmlSource.innerHTML = html;
+				chat.util.replaceIcons(htmlSource);
+				while (htmlSource.firstChild) dest.appendChild(htmlSource.firstChild);
+			},
+
+			siblingHtml : function(dest, html) {
+				htmlSource.innerHTML = html;
+				chat.util.replaceIcons(htmlSource);
+				while (htmlSource.firstChild) dest.parentNode.insertBefore(htmlSource.firstChild, dest);
+			},
+
+			ensureDeleted : function(id) {
+				if (id) {
+					var el = document.getElementById(id);
+					if (el) {
+						el.parentNode.removeChild(el);
+					}
+				}
+			},
+
+			loadXML : function(path, allowEmpty) {
+				allowEmpty = allowEmpty || false;
+				text = server.getFileContents(path);
+				if (!text && !allowEmpty) {
+					throw new Error("File " + path + " is empty. can't parse xml");
+				}
+				try {
+					return new DOMParser().parseFromString(text, "text/xml");
+				} catch (e) {
+					server.console("failed to parse xml from file " + path);
+					throw e;
+				}
+			}
+		},
+
+		WindowScroller : function(animate) {
+			var o=this, state, timerId
+			var ignoreNextScroll = false;
+			o.animate = animate;
+			o.atBottom = true; //just a state of aspiration
+
+			var animationStep = function() {
+				timerId = null;
+				var before = document.height - (window.innerHeight+window.pageYOffset);
+				var step = before;
+				if (o.animate) {
+					step = step>200?200:(step<8?step:Math.floor(step/1.7));
+				}
+				ignoreNextScroll = true;
+				window.scrollTo(0, document.height - window.innerHeight - before + step);
+				if (before>0) {
+					timerId = setTimeout(animationStep, 70); //next step in 250ms even if we are already at bottom (control shot)
+				}
+			}
+
+			var startAnimation = function() {
+				if (timerId) return;
+				if (document.height > window.innerHeight) { //if we have what to scroll
+					timerId = setTimeout(animationStep, 0);
+				}
+			}
+
+			var stopAnimation = function() {
+				if (timerId) {
+					clearTimeout(timerId);
+					timerId = null;
+				}
+			}
+
+			//timeout to be sure content rerendered correctly
+			window.addEventListener("resize", function() {setTimeout(function(){
+				if (o.atBottom) { //immediatelly scroll to bottom if we wish it
+					window.scrollTo(0, document.height - window.innerHeight);
+				}
+			}, 0);}, false);
+
+			//let's consider scroll may happen only by user action
+			window.addEventListener("scroll", function(){
+				if (ignoreNextScroll) {
+					ignoreNextScroll = false;
+					return;
+				}
+				stopAnimation();
+				o.atBottom = document.height == (window.innerHeight+window.pageYOffset);
+			}, false);
+
+			//EXTERNAL API
+			// checks current state of scroll and wish and activates necessary actions
+			o.invalidate = function() {
+				if (o.atBottom) {
+					startAnimation();
+				}
+			}
+
+			o.force = function() {
+				o.atBottom = true;
+				o.invalidate();
+			}
+		}
+	}
+	return chat;
+}();
+"ok"; // just an indicator for script loader
