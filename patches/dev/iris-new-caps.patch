diff --git a/include/iris/xmpp_caps.h b/include/iris/xmpp_caps.h
new file mode 100644
index 0000000..4dde12a
--- /dev/null
+++ b/include/iris/xmpp_caps.h
@@ -0,0 +1 @@
+#include "../../src/xmpp/xmpp-im/xmpp_caps.h"
diff --git a/src/xmpp/xmpp-im/client.cpp b/src/xmpp/xmpp-im/client.cpp
index 6106497..a7a5488 100644
--- a/src/xmpp/xmpp-im/client.cpp
+++ b/src/xmpp/xmpp-im/client.cpp
@@ -69,34 +69,19 @@
 //!  }
 //!  \endcode
 
-#include <stdarg.h>
-#include <qobject.h>
+#include <QObject>
 #include <QMap>
-#include <qtimer.h>
-#include <qpointer.h>
-//Added by qt3to4:
+#include <QTimer>
+#include <QPointer>
 #include <QList>
+
 #include "xmpp_tasks.h"
 #include "xmpp_xmlcommon.h"
 #include "s5b.h"
 #include "xmpp_ibb.h"
 #include "xmpp_bitsofbinary.h"
 #include "filetransfer.h"
-
-/*#include <stdio.h>
-#include <stdarg.h>
-#include <qstring.h>
-#include <qdom.h>
-#include <qobjectlist.h>
-#include <qtimer.h>
-#include "xmpp_stream.h"
-#include "xmpp_tasks.h"
-#include "xmpp_xmlcommon.h"
-#include "xmpp_dtcp.h"
-#include "xmpp_ibb.h"
-#include "xmpp_jidlink.h"
-
-using namespace Jabber;*/
+#include "xmpp_caps.h"
 
 #ifdef Q_OS_WIN
 #define vsnprintf _vsnprintf
@@ -139,6 +124,7 @@ public:
 
 	LiveRoster roster;
 	ResourceList resourceList;
+	CapsManager *capsman;
 	S5BManager *s5bman;
 	IBBManager *ibbman;
 	BoBManager *bobman;
@@ -174,6 +160,8 @@ Client::Client(QObject *par)
 	d->bobman = new BoBManager(this);
 
 	d->ftman = 0;
+
+	d->capsman = new CapsManager(this);
 }
 
 Client::~Client()
@@ -265,6 +253,11 @@ BoBManager *Client::bobManager() const
 	return d->bobman;
 }
 
+CapsManager *Client::capsManager() const
+{
+	return d->capsman;
+}
+
 bool Client::isActive() const
 {
 	return d->active;
diff --git a/src/xmpp/xmpp-im/types.cpp b/src/xmpp/xmpp-im/types.cpp
index b0d5d05..e2b45ac 100644
--- a/src/xmpp/xmpp-im/types.cpp
+++ b/src/xmpp/xmpp-im/types.cpp
@@ -2199,69 +2199,216 @@ bool Subscription::fromString(const QString &s)
 //---------------------------------------------------------------------------
 // Status
 //---------------------------------------------------------------------------
+/**
+ * Default constructor.
+ */
+CapsSpec::CapsSpec()
+{
+}
+
+
+/**
+ * \brief Basic constructor.
+ * @param node the node
+ * @param ven the version
+ * @param ext the list of extensions (separated by spaces)
+ */
+CapsSpec::CapsSpec(const QString& node, const QString& ver, const QString& hashAlgo)
+	: node_(node)
+	, ver_(ver)
+	, hashAlgo_(hashAlgo)
+{}
+
+/**
+ * @brief Checks for validity
+ * @return true on valid
+ */
+bool CapsSpec::isValid() const
+{
+	return !node_.isEmpty() && !ver_.isEmpty() && !hashAlgo_.isEmpty();
+}
+
+
+/**
+ * \brief Returns the node of the capabilities specification.
+ */
+const QString& CapsSpec::node() const
+{
+	return node_;
+}
+
+
+/**
+ * \brief Returns the version of the capabilities specification.
+ */
+const QString& CapsSpec::version() const
+{
+	return ver_;
+}
+
+const QString& CapsSpec::hashAlgorithm() const
+{
+	return hashAlgo_;
+}
+
+QDomElement CapsSpec::toXml(QDomDocument *doc) const
+{
+	QDomElement c = doc->createElement("c");
+	c.setAttribute("xmlns","http://jabber.org/protocol/caps");
+	c.setAttribute("hash",hashAlgo_);
+	c.setAttribute("node",node_);
+	c.setAttribute("ver",ver_);
+	return c;
+}
+
+CapsSpec CapsSpec::fromXml(const QDomElement &e)
+{
+	QString node = e.attribute("node");
+	QString ver = e.attribute("ver");
+	QString hashAlgo = e.attribute("hash");
+	return CapsSpec(node, ver, hashAlgo);
+}
+
+/**
+ * \brief Flattens the caps specification into the set of 'simple'
+ * specifications.
+ * A 'simple' specification is a specification with exactly one extension,
+ * or with the version number as the extension.
+ *
+ * Example: A caps specification with node=http://psi-im.org, version=0.10,
+ * and ext='achat vchat' would be expanded into the following list of specs:
+ *	node=http://psi-im.org, ver=0.10, ext=0.10
+ *	node=http://psi-im.org, ver=0.10, ext=achat
+ *	node=http://psi-im.org, ver=0.10, ext=vchat
+ */
+QString CapsSpec::flatten() const
+{
+	if (isValid())
+		return node_ + QLatin1String("#") + ver_;
+	return QString();
+}
+
+bool CapsSpec::operator==(const CapsSpec& s) const
+{
+	return (node() == s.node() && version() == s.version() && hashAlgorithm() == s.hashAlgorithm());
+}
+
+bool CapsSpec::operator!=(const CapsSpec& s) const
+{
+	return !((*this) == s);
+}
+
+bool CapsSpec::operator<(const CapsSpec& s) const
+{
+	return (node() != s.node() ? node() < s.node() :
+			(version() != s.version() ? version() < s.version() :
+			 hashAlgorithm() < s.hashAlgorithm()));
+}
+
+
+class StatusPrivate : public QSharedData
+{
+public:
+	StatusPrivate() :
+		hasPhotoHash(false),
+		isMUC(false),
+		hasMUCItem(false),
+		hasMUCDestroy(false),
+		mucHistoryMaxChars(-1),
+		mucHistoryMaxStanzas(-1),
+		mucHistorySeconds(-1),
+		ecode(-1)
+	{}
+
+	int priority;
+	QString show, status, key;
+	QDateTime timeStamp;
+	bool isAvailable;
+	bool isInvisible;
+	QString photoHash;
+	bool hasPhotoHash;
+
+	QString xsigned;
+	// gabber song extension
+	QString songTitle;
+	CapsSpec caps;
+	QList<BoBData> bobDataList;
+
+	// MUC
+	bool isMUC, hasMUCItem, hasMUCDestroy;
+	MUCItem mucItem;
+	MUCDestroy mucDestroy;
+	QList<int> mucStatuses;
+	QString mucPassword;
+	int mucHistoryMaxChars, mucHistoryMaxStanzas, mucHistorySeconds;
+	QDateTime mucHistorySince;
+
+	int ecode;
+	QString estr;
+};
+
 
 Status::Status(const QString &show, const QString &status, int priority, bool available)
 {
-	v_isAvailable = available;
-	v_show = show;
-	v_status = status;
-	v_priority = priority;
-	v_timeStamp = QDateTime::currentDateTime();
-	v_isInvisible = false;
-	v_hasPhotoHash = false;
-	v_isMUC = false;
-	v_hasMUCItem = false;
-	v_hasMUCDestroy = false;
-	v_mucHistoryMaxChars = -1;
-	v_mucHistoryMaxStanzas = -1;
-	v_mucHistorySeconds = -1;
-	ecode = -1;
+	d = new StatusPrivate;
+
+	d->isAvailable = available;
+	d->show = show;
+	d->status = status;
+	d->priority = priority;
+	d->timeStamp = QDateTime::currentDateTime();
+	d->isInvisible = false;
 }
 
 Status::Status(Type type, const QString& status, int priority)
 {
-	v_status = status;
-	v_priority = priority;
-	v_timeStamp = QDateTime::currentDateTime();
-	v_hasPhotoHash = false;
-	v_isMUC = false;
-	v_hasMUCItem = false;
-	v_hasMUCDestroy = false;
-	v_mucHistoryMaxChars = -1;
-	v_mucHistoryMaxStanzas = -1;
-	v_mucHistorySeconds = -1;
-	ecode = -1;
+	d = new StatusPrivate;
+
+	d->status = status;
+	d->priority = priority;
+	d->timeStamp = QDateTime::currentDateTime();
 	setType(type);
 }
 
+Status::Status(const Status &other) :
+	d(other.d)
+{
+}
+
+Status &Status::operator=(const Status &other)
+{
+	d = other.d;
+	return *this;
+}
+
 Status::~Status()
 {
 }
 
 bool Status::hasError() const
 {
-	return (ecode != -1);
+	return (d->ecode != -1);
 }
 
 void Status::setError(int code, const QString &str)
 {
-	ecode = code;
-	estr = str;
+	d->ecode = code;
+	d->estr = str;
 }
 
 void Status::setIsAvailable(bool available)
 {
-	v_isAvailable = available;
+	d->isAvailable = available;
 }
 
 void Status::setIsInvisible(bool invisible)
 {
-	v_isInvisible = invisible;
+	d->isInvisible = invisible;
 }
 
 void Status::setPriority(int x)
 {
-	v_priority = x;
+	d->priority = x;
 }
 
 void Status::setType(Status::Type _type)
@@ -2310,124 +2457,109 @@ void Status::setType(QString stat)
 
 void Status::setShow(const QString & _show)
 {
-	v_show = _show;
+	d->show = _show;
 }
 
 void Status::setStatus(const QString & _status)
 {
-	v_status = _status;
+	d->status = _status;
 }
 
 void Status::setTimeStamp(const QDateTime & _timestamp)
 {
-	v_timeStamp = _timestamp;
+	d->timeStamp = _timestamp;
 }
 
 void Status::setKeyID(const QString &key)
 {
-	v_key = key;
+	d->key = key;
 }
 
 void Status::setXSigned(const QString &s)
 {
-	v_xsigned = s;
+	d->xsigned = s;
 }
 
 void Status::setSongTitle(const QString & _songtitle)
 {
-	v_songTitle = _songtitle;
-}
-
-void Status::setCapsNode(const QString & _capsNode)
-{
-	v_capsNode = _capsNode;
+	d->songTitle = _songtitle;
 }
 
-void Status::setCapsVersion(const QString & _capsVersion)
+void Status::setCaps(const CapsSpec & caps)
 {
-	v_capsVersion = _capsVersion;
-}
-
-void Status::setCapsHashAlgorithm(const QString & _capsHashAlgorithm)
-{
-	v_capsHashAlgorithm = _capsHashAlgorithm;
-}
-
-void Status::setCapsExt(const QString & _capsExt)
-{
-	v_capsExt = _capsExt;
+	d->caps = caps;
 }
 
 void Status::setMUC()
 {
-	v_isMUC = true;
+	d->isMUC = true;
 }
 
 void Status::setMUCItem(const MUCItem& i)
 {
-	v_hasMUCItem = true;
-	v_mucItem = i;
+	d->hasMUCItem = true;
+	d->mucItem = i;
 }
 
 void Status::setMUCDestroy(const MUCDestroy& i)
 {
-	v_hasMUCDestroy = true;
-	v_mucDestroy = i;
+	d->hasMUCDestroy = true;
+	d->mucDestroy = i;
 }
 
 void Status::setMUCHistory(int maxchars, int maxstanzas, int seconds, const QDateTime &since)
 {
-	v_mucHistoryMaxChars = maxchars;
-	v_mucHistoryMaxStanzas = maxstanzas;
-	v_mucHistorySeconds = seconds;
-	v_mucHistorySince = since;
+	d->mucHistoryMaxChars = maxchars;
+	d->mucHistoryMaxStanzas = maxstanzas;
+	d->mucHistorySeconds = seconds;
+	d->mucHistorySince = since;
 }
 
 
 const QString& Status::photoHash() const
 {
-	return v_photoHash;
+	return d->photoHash;
 }
 
 void Status::setPhotoHash(const QString& h)
 {
-	v_photoHash = h;
-	v_hasPhotoHash = true;
+	d->photoHash = h;
+	d->hasPhotoHash = true;
 }
 
 bool Status::hasPhotoHash() const
 {
-	return v_hasPhotoHash;
+	return d->hasPhotoHash;
 }
 
 void Status::addBoBData(const BoBData &bob)
 {
-	v_bobDataList.append(bob);
+	d->bobDataList.append(bob);
 }
 
 QList<BoBData> Status::bobDataList() const
 {
-	return v_bobDataList;
+	return d->bobDataList;
 }
 
 bool Status::isAvailable() const
 {
-	return v_isAvailable;
+	return d->isAvailable;
 }
 
 bool Status::isAway() const
 {
-	return (v_show == "away" || v_show == "xa" || v_show == "dnd");
+	return (d->show == "away" || d->show == "xa" || d->show == "dnd");
 }
 
 bool Status::isInvisible() const
 {
-	return v_isInvisible;
+	return d->isInvisible;
 }
 
 int Status::priority() const
 {
-	return v_priority;
+	return d->priority;
 }
 
 Status::Type Status::type() const
@@ -2471,131 +2603,116 @@ QString Status::typeString() const
 
 const QString & Status::show() const
 {
-	return v_show;
+	return d->show;
 }
 const QString & Status::status() const
 {
-	return v_status;
+	return d->status;
 }
 
 QDateTime Status::timeStamp() const
 {
-	return v_timeStamp;
+	return d->timeStamp;
 }
 
 const QString & Status::keyID() const
 {
-	return v_key;
+	return d->key;
 }
 
 const QString & Status::xsigned() const
 {
-	return v_xsigned;
+	return d->xsigned;
 }
 
 const QString & Status::songTitle() const
 {
-	return v_songTitle;
+	return d->songTitle;
 }
 
-const QString & Status::capsNode() const
+const CapsSpec & Status::caps() const
 {
-	return v_capsNode;
-}
-
-const QString & Status::capsVersion() const
-{
-	return v_capsVersion;
-}
-
-const QString & Status::capsHashAlgorithm() const
-{
-	return v_capsHashAlgorithm;
-}
-
-const QString & Status::capsExt() const
-{
-	return v_capsExt;
+	return d->caps;
 }
 
 bool Status::isMUC() const
 {
-	return v_isMUC || !v_mucPassword.isEmpty() || hasMUCHistory();
+	return d->isMUC || !d->mucPassword.isEmpty() || hasMUCHistory();
 }
 
 bool Status::hasMUCItem() const
 {
-	return v_hasMUCItem;
+	return d->hasMUCItem;
 }
 
 const MUCItem& Status::mucItem() const
 {
-	return v_mucItem;
+	return d->mucItem;
 }
 
 bool Status::hasMUCDestroy() const
 {
-	return v_hasMUCDestroy;
+	return d->hasMUCDestroy;
 }
 
 const MUCDestroy& Status::mucDestroy() const
 {
-	return v_mucDestroy;
+	return d->mucDestroy;
 }
 
 const QList<int>& Status::getMUCStatuses() const
 {
-	return v_mucStatuses;
+	return d->mucStatuses;
 }
 
 void Status::addMUCStatus(int i)
 {
-	v_mucStatuses += i;
+	d->mucStatuses += i;
 }
 
 const QString& Status::mucPassword() const
 {
-	return v_mucPassword;
+	return d->mucPassword;
 }
 
 bool Status::hasMUCHistory() const
 {
-	return v_mucHistoryMaxChars >= 0 || v_mucHistoryMaxStanzas >= 0 || v_mucHistorySeconds >= 0 || !v_mucHistorySince.isNull();
+	return d->mucHistoryMaxChars >= 0 || d->mucHistoryMaxStanzas >= 0 || d->mucHistorySeconds >= 0 || !d->mucHistorySince.isNull();
 }
 
 int Status::mucHistoryMaxChars() const
 {
-	return v_mucHistoryMaxChars;
+	return d->mucHistoryMaxChars;
 }
 
 int Status::mucHistoryMaxStanzas() const
 {
-	return v_mucHistoryMaxStanzas;
+	return d->mucHistoryMaxStanzas;
 }
 
 int Status::mucHistorySeconds() const
 {
-	return v_mucHistorySeconds;
+	return d->mucHistorySeconds;
 }
 
 const QDateTime & Status::mucHistorySince() const
 {
-	return v_mucHistorySince;
+	return d->mucHistorySince;
 }
 
 void Status::setMUCPassword(const QString& i)
 {
-	v_mucPassword = i;
+	d->mucPassword = i;
 }
 
 int Status::errorCode() const
 {
-	return ecode;
+	return d->ecode;
 }
 
 const QString & Status::errorString() const
 {
-	return estr;
+	return d->estr;
 }
 
 
diff --git a/src/xmpp/xmpp-im/xmpp_caps.cpp b/src/xmpp/xmpp-im/xmpp_caps.cpp
new file mode 100644
index 0000000..877a0bf
--- /dev/null
+++ b/src/xmpp/xmpp-im/xmpp_caps.cpp
@@ -0,0 +1,449 @@
+/*
+ * capsregistry.cpp
+ * Copyright (C) 2006-2016  Remko Troncon, Rion
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#include <QCoreApplication>
+#include <QDebug>
+#include <QTextCodec>
+#include <QFile>
+#include <QDomElement>
+
+#include "xmpp_features.h"
+#include "xmpp_caps.h"
+#include "xmpp_discoinfotask.h"
+#include "xmpp_client.h"
+
+namespace XMPP {
+
+
+QDomElement CapsInfo::toXml(QDomDocument *doc) const
+{
+	QDomElement caps = doc->createElement("info");
+	caps.appendChild(doc->createElement("atime")).setNodeValue(_lastSeen.toString(Qt::ISODate));
+	caps.appendChild(_disco.toDiscoInfoResult(doc));
+	return caps;
+}
+
+CapsInfo CapsInfo::fromXml(const QDomElement &caps)
+{
+	QDateTime lastSeen = QDateTime::fromString(caps.firstChildElement("atime").nodeValue(), Qt::ISODate);
+	DiscoItem item = DiscoItem::fromDiscoInfoResult(caps.firstChildElement("query"));
+	return CapsInfo(item, lastSeen);
+}
+
+
+// -----------------------------------------------------------------------------
+
+/**
+ * \class CapsRegistry
+ * \brief A singleton class managing the capabilities of clients.
+ */
+CapsRegistry *CapsRegistry::instance_ = 0;
+
+/**
+ * \brief Default constructor.
+ */
+CapsRegistry::CapsRegistry(QObject *parent) :
+	QObject(parent)
+{
+}
+
+CapsRegistry *CapsRegistry::instance()
+{
+	if (!instance_) {
+		instance_ = new CapsRegistry(qApp);
+	}
+	return instance_;
+}
+
+void CapsRegistry::setInstance(CapsRegistry *instance)
+{
+	instance_ = instance;
+}
+
+/**
+ * \brief Convert all capabilities info to XML.
+ */
+void CapsRegistry::save()
+{
+	// Generate XML
+	QDomDocument doc;
+	QDomElement capabilities = doc.createElement("capabilities");
+	doc.appendChild(capabilities);
+	QHash<QString,CapsInfo>::ConstIterator i = capsInfo_.constBegin();
+	for( ; i != capsInfo_.end(); i++) {
+		QDomElement info = i.value().toXml(&doc);
+		info.setAttribute("node",i.key());
+		capabilities.appendChild(info);
+	}
+
+	saveData(doc.toString().toUtf8());
+}
+
+void CapsRegistry::saveData(const QByteArray &data)
+{
+	return;
+}
+
+QByteArray CapsRegistry::loadData()
+{
+	return QByteArray();
+}
+
+/**
+ * \brief Sets the file to save the capabilities info to
+ */
+void CapsRegistry::load()
+{
+	QByteArray data = loadData();
+	if (data.isEmpty()) {
+		return;
+	}
+
+	// Load settings
+	QDomDocument doc;
+
+	if (!doc.setContent(QString::fromUtf8(data))) {
+		qWarning() << "CapsRegistry: Cannnot parse input";
+		return;
+	}
+
+	QDomElement caps = doc.documentElement();
+	if (caps.tagName() != "capabilities") {
+		qWarning("caps.cpp: Invalid capabilities element");
+		return;
+	}
+
+	for(QDomNode n = caps.firstChild(); !n.isNull(); n = n.nextSibling()) {
+		QDomElement i = n.toElement();
+		if(i.isNull()) {
+			qWarning("capsregistry.cpp: Null element");
+			continue;
+		}
+
+		if(i.tagName() == "info") {
+			QString node = i.attribute("node");
+			int sep = node.indexOf('#');
+			if (sep > 0 && sep + 1 < node.length()) {
+				capsInfo_[node] = CapsInfo::fromXml(i);
+				//qDebug() << QString("Read %1 %2").arg(node).arg(ver);
+			}
+			else {
+				qWarning() << "capsregistry.cpp: Node" << node << "invalid";
+			}
+		}
+		else {
+			qWarning("capsregistry.cpp: Unknown element");
+		}
+	}
+}
+
+/**
+ * \brief Registers capabilities of a client.
+ */
+void CapsRegistry::registerCaps(const CapsSpec& spec, const DiscoItem &item)
+{
+	QString dnode = spec.flatten();
+	if (!isRegistered(dnode)) {
+		CapsInfo info(item);
+		capsInfo_[dnode] = info;
+		emit registered(spec);
+	}
+}
+
+/**
+ * \brief Checks if capabilities have been registered.
+ */
+bool CapsRegistry::isRegistered(const QString& spec) const
+{
+	return capsInfo_.contains(spec);
+}
+
+DiscoItem CapsRegistry::disco(const QString &spec) const
+{
+	CapsInfo ci = capsInfo_.value(spec);
+	return ci.disco();
+}
+
+
+/*--------------------------------------------------------------
+  _____                __  __
+ / ____|              |  \/  |
+| |     __ _ _ __  ___| \  / | __ _ _ __   __ _  __ _  ___ _ __
+| |    / _` | '_ \/ __| |\/| |/ _` | '_ \ / _` |/ _` |/ _ \ '__|
+| |___| (_| | |_) \__ \ |  | | (_| | | | | (_| | (_| |  __/ |
+ \_____\__,_| .__/|___/_|  |_|\__,_|_| |_|\__,_|\__, |\___|_|
+			| |                                  __/ |
+			|_|                                 |___/
+
+--------------------------------------------------------------*/
+/**
+ * \class CapsManager
+ * \brief A class managing all the capabilities of JIDs and their
+ * clients.
+ */
+
+/**
+ * \brief Default constructor.
+ */
+CapsManager::CapsManager(Client *client) :
+	client_(client),
+	isEnabled_(true)
+{}
+
+CapsManager::~CapsManager()
+{}
+
+
+/**
+ * \brief Checks whether the caps manager is enabled (and does lookups).
+ */
+bool CapsManager::isEnabled()
+{
+	return isEnabled_;
+}
+
+/**
+ * \brief Enables or disables the caps manager.
+ */
+void CapsManager::setEnabled(bool b)
+{
+	isEnabled_ = b;
+}
+
+/**
+ * \brief Registers new incoming capabilities information of a JID.
+ * If the features of the entity are unknown, discovery requests are sent to
+ * retrieve the information.
+ *
+ * @param jid The entity's JID
+ * @param node The entity's caps node
+ * @param ver The entity's caps version
+ * @param ext The entity's caps extensions
+ */
+void CapsManager::updateCaps(const Jid& jid, const CapsSpec &c)
+{
+	if (jid.compare(client_->jid(),false))
+		return;
+
+	QString fullNode = c.flatten();
+	if (capsSpecs_[jid.full()] != c) {
+		//qDebug() << QString("caps.cpp: Updating caps for %1 (node=%2,ver=%3,ext=%4)").arg(QString(jid.full()).replace('%',"%%")).arg(node).arg(ver).arg(ext);
+
+		// Unregister from all old caps node
+		capsJids_[capsSpecs_[jid.full()].flatten()].removeAll(jid.full());
+
+		if (c.isValid()) {
+			// Register with all new caps nodes
+			capsSpecs_[jid.full()] = c;
+			if (!capsJids_[fullNode].contains(jid.full())) {
+				capsJids_[fullNode].push_back(jid.full());
+			}
+
+			emit capsChanged(jid);
+
+			// Register new caps and check if we need to discover features
+			if (isEnabled()) {
+				if (!CapsRegistry::instance()->isRegistered(fullNode) && capsJids_[fullNode].count() == 1) {
+					//qDebug() << QString("caps.cpp: Sending disco request to %1, node=%2").arg(QString(jid.full()).replace('%',"%%")).arg(node + "#" + s.extensions());
+					JT_DiscoInfo* disco = new JT_DiscoInfo(client_->rootTask());
+					connect(disco, SIGNAL(finished()), SLOT(discoFinished()));
+					disco->get(jid, fullNode);
+					disco->go(true);
+				}
+			}
+		}
+		else {
+			// Remove all caps specifications
+			qWarning() << QString("caps.cpp: Illegal caps info from %1: node=%2, ver=%3").arg(QString(jid.full()).replace('%',"%%")).arg(fullNode).arg(c.version());
+			capsSpecs_.remove(jid.full());
+		}
+	}
+	else {
+		// Add to the list of jids
+		capsJids_[fullNode].push_back(jid.full());
+	}
+}
+
+/**
+ * \brief Removes all feature information for a given JID.
+ *
+ * @param jid The entity's JID
+ */
+void CapsManager::disableCaps(const Jid& jid)
+{
+	//qDebug() << QString("caps.cpp: Disabling caps for %1.").arg(QString(jid.full()).replace('%',"%%"));
+	if (capsEnabled(jid)) {
+		QString node = capsSpecs_[jid.full()].flatten();
+		if (!node.isEmpty()) {
+			capsJids_[node].removeAll(jid.full());
+		}
+		capsSpecs_.remove(jid.full());
+		emit capsChanged(jid);
+	}
+}
+
+/**
+ * \brief Called when a reply to disco#info request was received.
+ * If the result was succesful, the resulting features are recorded in the
+ * features database for the requested node, and all the affected jids are
+ * put in the queue for update notification.
+ */
+void CapsManager::discoFinished()
+{
+	//qDebug() << QString("caps.cpp: Disco response from %1, node=%2").arg(QString(jid.full()).replace('%',"%%")).arg(node);
+	// Update features
+	JT_DiscoInfo *task = (JT_DiscoInfo *)sender();
+	CapsSpec cs = capsSpecs_.value(task->jid().full());
+	if (!cs.isValid()) {
+		return;
+	}
+	CapsRegistry::instance()->registerCaps(cs, task->item());
+}
+
+/**
+ * \brief This slot is called whenever capabilities of a client were discovered.
+ * All jids with the corresponding client are updated.
+ */
+void CapsManager::capsRegistered(const CapsSpec& cs)
+{
+	// Notify affected jids.
+	foreach(const QString &s, capsJids_[cs.flatten()]) {
+		//qDebug() << QString("caps.cpp: Notifying %1.").arg(s.replace('%',"%%"));
+		emit capsChanged(s);
+	}
+}
+
+/**
+ * \brief Checks whether a given JID is broadcastingn its entity capabilities.
+ */
+bool CapsManager::capsEnabled(const Jid& jid) const
+{
+	return capsSpecs_.contains(jid.full());
+}
+
+
+/**
+ * \brief Requests the list of features of a given JID.
+ */
+XMPP::Features CapsManager::features(const Jid& jid) const
+{
+	//qDebug() << "caps.cpp: Retrieving features of " << jid.full();
+	QStringList f;
+	if (!capsEnabled(jid)) {
+		return Features();
+	}
+	QString node = capsSpecs_[jid.full()].flatten();
+	//qDebug() << QString("    %1").arg(CapsRegistry::instance()->features(s).list().join("\n"));
+	return CapsRegistry::instance()->disco(node).features();
+}
+
+/**
+ * \brief Returns the client name of a given jid.
+ * \param jid the jid to retrieve the client name of
+ */
+QString CapsManager::clientName(const Jid& jid) const
+{
+	if (capsEnabled(jid)) {
+		CapsSpec cs = capsSpecs_[jid.full()];
+		QString name;
+
+		QString cs_str = cs.flatten();
+		if (CapsRegistry::instance()->isRegistered(cs_str)) {
+			DiscoItem disco = CapsRegistry::instance()->disco(cs_str);
+			XData si = disco.registeredExtension(QLatin1String("urn:xmpp:dataforms:softwareinfo"));
+			if (si.isValid()) {
+				name = si.getField("software").value().value(0);
+			}
+
+			if (name.isEmpty()) {
+				const DiscoItem::Identities& i = disco.identities();
+				if (i.count() > 0) {
+					name = i.first().name;
+				}
+			}
+		}
+
+		// Try to be intelligent about the name
+		if (name.isEmpty()) {
+			name = cs.node();
+			if (name.startsWith("http://"))
+				name = name.right(name.length() - 7);
+			else if (name.startsWith("https://"))
+				name = name.right(name.length() - 8);
+
+			if (name.startsWith("www."))
+				name = name.right(name.length() - 4);
+
+			int cut_pos = name.indexOf("/");
+			if (cut_pos != -1)
+				name = name.left(cut_pos);
+		}
+
+		return name;
+	}
+	else {
+		return QString();
+	}
+}
+
+/**
+ * \brief Returns the client version of a given jid.
+ */
+QString CapsManager::clientVersion(const Jid& jid) const
+{
+	if (!capsEnabled(jid))
+		return QString();
+
+	QString version;
+	const CapsSpec &cs = capsSpecs_[jid.full()];
+	QString cs_str = cs.flatten();
+	if (CapsRegistry::instance()->isRegistered(cs_str)) {
+		XData form = CapsRegistry::instance()->disco(cs_str).registeredExtension("urn:xmpp:dataforms:softwareinfo");
+		version = form.getField("software_version").value().value(0);
+	}
+
+	if (version.isEmpty())
+		version = cs.version();
+
+	return version;
+}
+
+/**
+ * \brief Returns the OS version of a given jid.
+ */
+QString CapsManager::osVersion(const Jid &jid) const
+{
+	QString os_str;
+	if (capsEnabled(jid)) {
+		QString cs_str = capsSpecs_[jid.full()].flatten();
+		if (CapsRegistry::instance()->isRegistered(cs_str)) {
+			XData form = CapsRegistry::instance()->disco(cs_str).registeredExtension("urn:xmpp:dataforms:softwareinfo");
+			os_str = form.getField("os").value().value(0).trimmed();
+			if (!os_str.isEmpty()) {
+				QString os_ver = form.getField("os_version").value().value(0).trimmed();
+				if (!os_ver.isEmpty())
+					os_str.append(" " + os_ver);
+			}
+		}
+	}
+	return os_str;
+}
+
+} // namespace XMPP
diff --git a/src/xmpp/xmpp-im/xmpp_caps.h b/src/xmpp/xmpp-im/xmpp_caps.h
new file mode 100644
index 0000000..b145e3d
--- /dev/null
+++ b/src/xmpp/xmpp-im/xmpp_caps.h
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2016  Remko Troncon, Rion
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ *
+ */
+
+#ifndef XMPP_CAPS_H
+#define XMPP_CAPS_H
+
+#include <QPointer>
+
+#include "xmpp_features.h"
+#include "xmpp_discoitem.h"
+#include "xmpp_status.h"
+
+
+namespace XMPP {
+
+class CapsInfo
+{
+public:
+	inline CapsInfo() {}
+	inline CapsInfo(const XMPP::DiscoItem &disco, const QDateTime &lastSeen = QDateTime()) :
+		_lastSeen(lastSeen.isNull()? QDateTime::currentDateTime() : lastSeen),
+		_disco(disco) {}
+	inline bool isValid() const { return _lastSeen.isValid(); }
+	inline const QDateTime &lastSeen() const { return _lastSeen; }
+	inline const XMPP::DiscoItem &disco() const { return _disco; }
+	QDomElement toXml(QDomDocument *doc) const;
+	static CapsInfo fromXml(const QDomElement &ci);
+
+private:
+	QDateTime _lastSeen;
+	XMPP::DiscoItem _disco;
+};
+
+
+class CapsRegistry : public QObject
+{
+	Q_OBJECT
+
+public:
+	CapsRegistry(QObject *parent = 0);
+
+	static CapsRegistry* instance();
+	static void setInstance(CapsRegistry*instance);
+
+	void registerCaps(const CapsSpec&, const XMPP::DiscoItem &item);
+	bool isRegistered(const QString &) const;
+	DiscoItem disco(const QString&) const;
+
+signals:
+	void registered(const XMPP::CapsSpec&);
+
+public slots:
+	void load();
+	void save();
+
+protected:
+	virtual void saveData(const QByteArray &data);
+	virtual QByteArray loadData();
+
+private:
+	static CapsRegistry *instance_;
+	QHash<QString,CapsInfo> capsInfo_;
+};
+
+
+class CapsManager : public QObject
+{
+	Q_OBJECT
+
+public:
+	CapsManager(Client *client);
+	~CapsManager();
+
+	bool isEnabled();
+	void setEnabled(bool);
+
+	void updateCaps(const Jid& jid, const CapsSpec& caps);
+	void disableCaps(const Jid& jid);
+	bool capsEnabled(const Jid& jid) const;
+	XMPP::Features features(const Jid& jid) const;
+	QString clientName(const Jid& jid) const;
+	QString clientVersion(const Jid& jid) const;
+	QString osVersion(const Jid& jid) const;
+
+signals:
+	/**
+	 * This signal is emitted when the feature list of a given JID have changed.
+	 */
+	void capsChanged(const Jid& jid);
+
+protected slots:
+	void discoFinished();
+	void capsRegistered(const CapsSpec&);
+
+private:
+	Client *client_;
+	bool isEnabled_;
+	QMap<QString,CapsSpec> capsSpecs_;
+	QMap<QString,QList<QString> > capsJids_;
+};
+
+} // namespace XMPP
+
+#endif // CAPS_H
diff --git a/src/xmpp/xmpp-im/xmpp_client.h b/src/xmpp/xmpp-im/xmpp_client.h
index 156312d..d8a8709 100644
--- a/src/xmpp/xmpp-im/xmpp_client.h
+++ b/src/xmpp/xmpp-im/xmpp_client.h
@@ -48,6 +48,7 @@ namespace XMPP {
 	class BSConnection;
 	class Stream;
 	class Task;
+	class CapsManager;
 }
 
 namespace XMPP
@@ -121,6 +122,7 @@ namespace XMPP
 		IBBManager *ibbManager() const;
 		BoBManager *bobManager() const;
 		JidLinkManager *jidLinkManager() const;
+		CapsManager *capsManager() const;
 
 		void setFileTransferEnabled(bool b);
 		FileTransferManager *fileTransferManager() const;
diff --git a/src/xmpp/xmpp-im/xmpp_discoinfotask.cpp b/src/xmpp/xmpp-im/xmpp_discoinfotask.cpp
index eb92cf4..4d0e75e 100644
--- a/src/xmpp/xmpp-im/xmpp_discoinfotask.cpp
+++ b/src/xmpp/xmpp-im/xmpp_discoinfotask.cpp
@@ -125,39 +125,8 @@ bool DiscoInfoTask::take(const QDomElement &x)
 		return false;
 
 	if(x.attribute("type") == "result") {
-		QDomElement q = queryTag(x);
-
-		DiscoItem item;
-
-		item.setJid( d->jid );
-		item.setNode( q.attribute("node") );
-
-		QStringList features;
-		DiscoItem::Identities identities;
-
-		for(QDomNode n = q.firstChild(); !n.isNull(); n = n.nextSibling()) {
-			QDomElement e = n.toElement();
-			if( e.isNull() )
-				continue;
-
-			if ( e.tagName() == "feature" ) {
-				features << e.attribute("var");
-			}
-			else if ( e.tagName() == "identity" ) {
-				DiscoItem::Identity id;
-
-				id.category = e.attribute("category");
-				id.name     = e.attribute("name");
-				id.type     = e.attribute("type");
-
-				identities.append( id );
-			}
-		}
-
-		item.setFeatures( features );
-		item.setIdentities( identities );
-
-		d->item = item;
+		d->item = DiscoItem::fromDiscoInfoResult(queryTag(x));
+		d->item.setJid( d->jid );
 
 		setSuccess(true);
 	}
diff --git a/src/xmpp/xmpp-im/xmpp_discoitem.cpp b/src/xmpp/xmpp-im/xmpp_discoitem.cpp
index 59e9551..d13dafa 100644
--- a/src/xmpp/xmpp-im/xmpp_discoitem.cpp
+++ b/src/xmpp/xmpp-im/xmpp_discoitem.cpp
@@ -18,35 +18,38 @@
  *
  */
 
+#include <QtXml>
+
 #include "xmpp_discoitem.h"
 
 using namespace XMPP;
 
-class DiscoItem::Private
+class XMPP::DiscoItemPrivate : public QSharedData
 {
 public:
-	Private()
+	DiscoItemPrivate()
 	{
-		action = None;
+		action = DiscoItem::None;
 	}
 
 	Jid jid;
 	QString name;
 	QString node;
-	Action action;
+	DiscoItem::Action action;
 
 	Features features;
-	Identities identities;
+	DiscoItem::Identities identities;
+	QList<XData> exts;
 };
 
 DiscoItem::DiscoItem()
 {
-	d = new Private;
+	d = new DiscoItemPrivate;
 }
 
 DiscoItem::DiscoItem(const DiscoItem &from)
 {
-	d = new Private;
+	d = new DiscoItemPrivate;
 	*this = from;
 }
 
@@ -58,13 +61,14 @@ DiscoItem & DiscoItem::operator= (const DiscoItem &from)
 	d->action = from.d->action;
 	d->features = from.d->features;
 	d->identities = from.d->identities;
+	d->exts = from.d->exts;
 
 	return *this;
 }
 
 DiscoItem::~DiscoItem()
 {
-	delete d;
+
 }
 
 AgentItem DiscoItem::toAgentItem() const
@@ -104,6 +108,127 @@ void DiscoItem::fromAgentItem(const AgentItem &ai)
 	setFeatures( ai.features() );
 }
 
+QString DiscoItem::capsHash(QCryptographicHash::Algorithm algo) const
+{
+	QStringList prep;
+	DiscoItem::Identities idents = d->identities;
+	qSort(idents);
+
+	foreach (const DiscoItem::Identity &id, idents) {
+		prep << QString("%1/%2/%3/%4<").arg(id.category, id.type, id.lang, id.name);
+	}
+
+	QStringList fl = d->features.list();
+	qSort(fl);
+	prep += fl;
+
+	QMap<QString,XData> forms;
+	foreach (const XData &xd, d->exts) {
+		if (xd.registrarType().isEmpty()) {
+			continue;
+		}
+		if (forms.contains(xd.registrarType())) {
+			return QString(); // ill-formed
+		}
+		forms.insert(xd.registrarType(), xd);
+	}
+	foreach (const XData &xd, forms.values()) {
+		prep << xd.registrarType();
+		QMap <QString, QStringList> values;
+		foreach (const XData::Field &f, xd.fields()) {
+			if (f.var() == QLatin1String("FORM_TYPE")) {
+				continue;
+			}
+			if (values.contains(f.var())) {
+				return QString(); // ill-formed
+			}
+			QStringList v = f.value();
+			if (v.isEmpty()) {
+				continue; // maybe it's media-element but xep-115 (1.5) and xep-232 (0.3) are not clear about that.
+			}
+			qSort(v);
+			values[f.var()] = v;
+		}
+		foreach (const QStringList &sl, values.values()) {
+			prep += sl;
+		}
+	}
+
+	QByteArray ba = (prep.join(QLatin1String("<")) + QLatin1Char('<')).toUtf8();
+	return QString::fromLatin1(QCryptographicHash::hash(ba, algo).toBase64());
+}
+
+DiscoItem DiscoItem::fromDiscoInfoResult(const QDomElement &q)
+{
+	DiscoItem item;
+
+	item.setNode( q.attribute("node") );
+
+	QStringList features;
+	DiscoItem::Identities identities;
+	QList<XData> extList;
+
+	for(QDomNode n = q.firstChild(); !n.isNull(); n = n.nextSibling()) {
+		QDomElement e = n.toElement();
+		if( e.isNull() )
+			continue;
+
+		if ( e.tagName() == "feature" ) {
+			features << e.attribute("var");
+		}
+		else if ( e.tagName() == "identity" ) {
+			DiscoItem::Identity id;
+
+			id.category = e.attribute("category");
+			id.type     = e.attribute("type");
+			id.lang     = e.attribute("lang");
+			id.name     = e.attribute("name");
+
+			identities.append( id );
+		}
+		else if (e.tagName() == QLatin1String("x") && e.namespaceURI() == QLatin1String("jabber:x:data")) {
+			XData form;
+			form.fromXml(e);
+			extList.append(form);
+		}
+	}
+
+	item.setFeatures( features );
+	item.setIdentities( identities );
+	item.setExtensions( extList );
+
+	return item;
+}
+
+QDomElement DiscoItem::toDiscoInfoResult(QDomDocument *doc) const
+{
+	QDomElement q = doc->createElementNS(QLatin1String("http://jabber.org/protocol/disco#info"), QLatin1String("query"));
+	q.setAttribute("node", d->node);
+
+	foreach (const Identity &id, d->identities) {
+		QDomElement idel = q.appendChild(doc->createElement(QLatin1String("identity"))).toElement();
+		idel.setAttribute("category", id.category);
+		idel.setAttribute("type", id.type);
+		if (!id.lang.isEmpty()) {
+			idel.setAttribute("lang", id.lang);
+		}
+		if (!id.name.isEmpty()) {
+			idel.setAttribute("name", id.name);
+		}
+	}
+
+	foreach (const QString &f, d->features.list()) {
+		QDomElement fel = q.appendChild(doc->createElement(QLatin1String("feature"))).toElement();
+		fel.setAttribute("var", f);
+	}
+
+	foreach (const XData &f, d->exts) {
+		q.appendChild(f.toXml(doc));
+	}
+
+	return q;
+}
+
 const Jid &DiscoItem::jid() const
 {
 	return d->jid;
@@ -167,6 +292,25 @@ void DiscoItem::setIdentities(const Identities &i)
 		setName( i.first().name );
 }
 
+const QList<XData> &DiscoItem::extensions() const
+{
+	return d->exts;
+}
+
+void DiscoItem::setExtensions(const QList<XData> &extlist)
+{
+	d->exts = extlist;
+}
+
+XData DiscoItem::registeredExtension(const QString &ns) const
+{
+	foreach (const XData &xd, d->exts) {
+		if (xd.registrarType() == ns) {
+			return xd;
+		}
+	}
+	return XData();
+}
 
 DiscoItem::Action DiscoItem::string2action(QString s)
 {
@@ -197,3 +341,19 @@ QString DiscoItem::action2string(Action a)
 }
 
 
+
+bool XMPP::operator<(const DiscoItem::Identity &a, const DiscoItem::Identity &b)
+{
+	int r = a.category.compare(b.category);
+	if (!r) {
+		r = a.type.compare(b.type);
+		if (!r) {
+			r = a.lang.compare(b.lang);
+			if (!r) {
+				r = a.name.compare(b.name);
+			}
+		}
+	}
+
+	return r < 0;
+}
diff --git a/src/xmpp/xmpp-im/xmpp_discoitem.h b/src/xmpp/xmpp-im/xmpp_discoitem.h
index 8380ba5..969dd09 100644
--- a/src/xmpp/xmpp-im/xmpp_discoitem.h
+++ b/src/xmpp/xmpp-im/xmpp_discoitem.h
@@ -22,12 +22,16 @@
 #define XMPP_DISCOITEM
 
 #include <QString>
+#include <QCryptographicHash>
 
 #include "xmpp/jid/jid.h"
 #include "xmpp_features.h"
+#include "xmpp_xdata.h"
 #include "xmpp_agentitem.h"
 
 namespace XMPP {
+	class DiscoItemPrivate;
+
 	class DiscoItem
 	{
 	public:
@@ -57,14 +61,25 @@ namespace XMPP {
 		struct Identity
 		{
 			QString category;
-			QString name;
 			QString type;
+			QString lang;
+			QString name;
+
+			inline Identity() {}
+			inline Identity(const QString &categoty, const QString &type,
+							const QString &lang = QString::null, const QString &name = QString::null) :
+				category(categoty), type(type), lang(lang), name(name) {}
 		};
 
 		typedef QList<Identity> Identities;
 
 		const Identities &identities() const;
 		void setIdentities(const Identities &);
+		inline void setIdentities(const Identity &id) { setIdentities(Identities() << id); }
+
+		const QList<XData> &extensions() const;
+		void setExtensions(const QList<XData> &extlist);
+		XData registeredExtension(const QString &ns) const;
 
 		// some useful helper functions
 		static Action string2action(QString s);
@@ -77,10 +92,16 @@ namespace XMPP {
 		AgentItem toAgentItem() const;
 		void fromAgentItem(const AgentItem &);
 
+		QString capsHash(QCryptographicHash::Algorithm algo) const;
+
+		static DiscoItem fromDiscoInfoResult(const QDomElement &x);
+		QDomElement toDiscoInfoResult(QDomDocument *doc) const;
+
 	private:
-		class Private;
-		Private *d;
+		QSharedDataPointer<DiscoItemPrivate> d;
 	};
+
+	bool operator<(const DiscoItem::Identity &a, const DiscoItem::Identity &b);
 }
 
 #endif
diff --git a/src/xmpp/xmpp-im/xmpp_status.h b/src/xmpp/xmpp-im/xmpp_status.h
index f7c88ea..8d34352 100644
--- a/src/xmpp/xmpp-im/xmpp_status.h
+++ b/src/xmpp/xmpp-im/xmpp_status.h
@@ -30,6 +30,30 @@
 
 namespace XMPP
 {
+	class CapsSpec
+	{
+		public:
+			CapsSpec();
+			CapsSpec(const QString& node, const QString& ver, const QString& hashAlgo);
+			bool isValid() const;
+			const QString& node() const;
+			const QString& version() const;
+			const QString& hashAlgorithm() const;
+			QString flatten() const;
+
+			bool operator==(const CapsSpec&) const;
+			bool operator!=(const CapsSpec&) const;
+			bool operator<(const CapsSpec&) const;
+
+			QDomElement toXml(QDomDocument *doc) const;
+			static CapsSpec fromXml(const QDomElement &e);
+
+		private:
+			QString node_, ver_, hashAlgo_;
+	};
+
+	class StatusPrivate;
+
 	class Status
 	{
 	public:
@@ -37,6 +61,8 @@ namespace XMPP
 
 		Status(const QString &show=QString(), const QString &status=QString(), int priority=0, bool available=true);
 		Status(Type type, const QString& status=QString(), int priority=0);
+		Status(const Status &);
+		Status &operator=(const Status &);
 		~Status();
 
 		int priority() const;
@@ -55,10 +81,7 @@ namespace XMPP
 
 		const QString & xsigned() const;
 		const QString & songTitle() const;
-		const QString & capsNode() const;
-		const QString & capsVersion() const;
-		const QString & capsHashAlgorithm() const;
-		const QString & capsExt() const;
+		const CapsSpec & caps() const;
 
 		bool isMUC() const;
 		bool hasMUCItem() const;
@@ -85,10 +108,7 @@ namespace XMPP
 		void setIsAvailable(bool);
 		void setIsInvisible(bool);
 		void setError(int, const QString &);
-		void setCapsNode(const QString&);
-		void setCapsVersion(const QString&);
-		void setCapsHashAlgorithm(const QString&);
-		void setCapsExt(const QString&);
+		void setCaps(const CapsSpec&);
 
 		void setMUC();
 		void setMUCItem(const MUCItem&);
@@ -110,31 +130,7 @@ namespace XMPP
 		QList<BoBData> bobDataList() const;
 
 	private:
-		int v_priority;
-		QString v_show, v_status, v_key;
-		QDateTime v_timeStamp;
-		bool v_isAvailable;
-		bool v_isInvisible;
-		QString v_photoHash;
-		bool v_hasPhotoHash;
-
-		QString v_xsigned;
-		// gabber song extension
-		QString v_songTitle;
-		QString v_capsNode, v_capsVersion, v_capsHashAlgorithm, v_capsExt;
-		QList<BoBData> v_bobDataList;
-
-		// MUC
-		bool v_isMUC, v_hasMUCItem, v_hasMUCDestroy;
-		MUCItem v_mucItem;
-		MUCDestroy v_mucDestroy;
-		QList<int> v_mucStatuses;
-		QString v_mucPassword;
-		int v_mucHistoryMaxChars, v_mucHistoryMaxStanzas, v_mucHistorySeconds;
-		QDateTime v_mucHistorySince;
-
-		int ecode;
-		QString estr;
+		QSharedDataPointer<StatusPrivate> d;
 	};
 
 }
diff --git a/src/xmpp/xmpp-im/xmpp_tasks.cpp b/src/xmpp/xmpp-im/xmpp_tasks.cpp
index 8a9aa6c..2172ae4 100644
--- a/src/xmpp/xmpp-im/xmpp_tasks.cpp
+++ b/src/xmpp/xmpp-im/xmpp_tasks.cpp
@@ -588,16 +588,8 @@ void JT_Presence::pres(const Status &s)
 			tag.appendChild(x);
 		}
 
-		if(!s.capsNode().isEmpty() && !s.capsVersion().isEmpty()) {
-			QDomElement c = doc()->createElement("c");
-			c.setAttribute("xmlns","http://jabber.org/protocol/caps");
-			if (!s.capsHashAlgorithm().isEmpty())
-				c.setAttribute("hash",s.capsHashAlgorithm());
-			c.setAttribute("node",s.capsNode());
-			c.setAttribute("ver",s.capsVersion());
-			if (!s.capsExt().isEmpty())
-				c.setAttribute("ext",s.capsExt());
-			tag.appendChild(c);
+		if (s.caps().isValid()) {
+			tag.appendChild(s.caps().toXml(doc()));
 		}
 
 		if(s.isMUC()) {
@@ -763,9 +755,7 @@ bool JT_PushPresence::take(const QDomElement &e)
 			p.setKeyID(tagContent(i));
 		}
  		else if(i.tagName() == "c" && i.attribute("xmlns") == "http://jabber.org/protocol/caps") {
- 			p.setCapsNode(i.attribute("node"));
- 			p.setCapsVersion(i.attribute("ver"));
- 			p.setCapsExt(i.attribute("ext"));
+			p.setCaps(CapsSpec::fromXml(i));
   		}
 		else if(i.tagName() == "x" && i.attribute("xmlns") == "vcard-temp:x:update") {
 			QDomElement t;
@@ -1486,72 +1476,32 @@ bool JT_ServInfo::take(const QDomElement &e)
 			node = q.attribute("node");
 
 		QDomElement iq = createIQ(doc(), "result", e.attribute("from"), e.attribute("id"));
-		QDomElement query = doc()->createElement("query");
-		query.setAttribute("xmlns", "http://jabber.org/protocol/disco#info");
-		if (!node.isEmpty())
-			query.setAttribute("node", node);
-		iq.appendChild(query);
-
-		// Identity
-		DiscoItem::Identity identity = client()->identity();
-		QDomElement id = doc()->createElement("identity");
-		if (!identity.category.isEmpty() && !identity.type.isEmpty()) {
-			id.setAttribute("category",identity.category);
-			id.setAttribute("type",identity.type);
-			if (!identity.name.isEmpty()) {
-				id.setAttribute("name",identity.name);
-			}
-		}
-		else {
-			// Default values
-			id.setAttribute("category","client");
-			id.setAttribute("type","pc");
+		DiscoItem item;
+		item.setNode(node);
+		DiscoItem::Identity id = client()->identity();
+		if (id.category.isEmpty() || id.type.isEmpty()) {
+			id.category = "client";
+			id.type = "pc";
 		}
-		query.appendChild(id);
+		item.setIdentities(id);
 
-		QDomElement feature;
+		Features features;
 		if (node.isEmpty() || node == client()->capsNode() + "#" + client()->capsVersion()) {
 			if (client()->fileTransferManager()) {
-				// Standard features
-				feature = doc()->createElement("feature");
-				feature.setAttribute("var", "http://jabber.org/protocol/bytestreams");
-				query.appendChild(feature);
-
-				feature = doc()->createElement("feature");
-				feature.setAttribute("var", "http://jabber.org/protocol/ibb");
-				query.appendChild(feature);
-
-				feature = doc()->createElement("feature");
-				feature.setAttribute("var", "http://jabber.org/protocol/si");
-				query.appendChild(feature);
-
-				feature = doc()->createElement("feature");
-				feature.setAttribute("var", "http://jabber.org/protocol/si/profile/file-transfer");
-				query.appendChild(feature);
+				features.addFeature("http://jabber.org/protocol/bytestreams");
+				features.addFeature("http://jabber.org/protocol/ibb");
+				features.addFeature("http://jabber.org/protocol/si");
+				features.addFeature("http://jabber.org/protocol/si/profile/file-transfer");
 			}
-
-			feature = doc()->createElement("feature");
-			feature.setAttribute("var", "http://jabber.org/protocol/disco#info");
-			query.appendChild(feature);
-
-			feature = doc()->createElement("feature");
-			feature.setAttribute("var", "urn:xmpp:bob");
-			query.appendChild(feature);
-
-			feature = doc()->createElement("feature");
-			feature.setAttribute("var", "urn:xmpp:ping");
-			query.appendChild(feature);
-
-			feature = doc()->createElement("feature");
-			feature.setAttribute("var", "urn:xmpp:time");
-			query.appendChild(feature);
+			features.addFeature("http://jabber.org/protocol/disco#info");
+			features.addFeature("urn:xmpp:bob");
+			features.addFeature("urn:xmpp:ping");
+			features.addFeature("urn:xmpp:time");
 
 			// Client-specific features
 			QStringList clientFeatures = client()->features().list();
 			foreach (const QString & i, clientFeatures) {
-				feature = doc()->createElement("feature");
-				feature.setAttribute("var", i);
-				query.appendChild(feature);
+				features.addFeature(i);
 			}
 
 			if (node.isEmpty()) {
@@ -1560,9 +1510,7 @@ bool JT_ServInfo::take(const QDomElement &e)
 				for (QStringList::ConstIterator i = exts.begin(); i != exts.end(); ++i) {
 					const QStringList& l = client()->extension(*i).list();
 					for ( QStringList::ConstIterator j = l.begin(); j != l.end(); ++j ) {
-						feature = doc()->createElement("feature");
-						feature.setAttribute("var", *j);
-						query.appendChild(feature);
+						features.addFeature(*j);
 					}
 				}
 			}
@@ -1572,9 +1520,7 @@ bool JT_ServInfo::take(const QDomElement &e)
 			if (client()->extensions().contains(ext)) {
 				const QStringList& l = client()->extension(ext).list();
 				for ( QStringList::ConstIterator it = l.begin(); it != l.end(); ++it ) {
-					feature = doc()->createElement("feature");
-					feature.setAttribute("var", *it);
-					query.appendChild(feature);
+					features.addFeature(*it);
 				}
 			}
 			else {
@@ -1586,6 +1532,8 @@ bool JT_ServInfo::take(const QDomElement &e)
 		}
 
 		if (!invalid_node) {
+			item.setFeatures(features);
+			iq.appendChild(item.toDiscoInfoResult(doc()));
 			send(iq);
 		}
 		else {
diff --git a/src/xmpp/xmpp-im/xmpp_xdata.cpp b/src/xmpp/xmpp-im/xmpp_xdata.cpp
index 16bd85b..6ae7f5c 100644
--- a/src/xmpp/xmpp-im/xmpp_xdata.cpp
+++ b/src/xmpp/xmpp-im/xmpp_xdata.cpp
@@ -431,6 +431,19 @@ XData::FieldList XData::fields() const
 	return d->fields;
 }
 
+XData::Field XData::getField(const QString &var) const
+{
+	if ( !d->fields.isEmpty() ) {
+		FieldList::ConstIterator it = d->fields.begin();
+		for ( ; it != d->fields.end(); ++it) {
+			Field f = *it;
+			if (f.isValid() && f.var() == var)
+				return f;
+		}
+	}
+	return Field();
+}
+
 void XData::setFields(const FieldList &f)
 {
 	d->fields = f;
diff --git a/src/xmpp/xmpp-im/xmpp_xdata.h b/src/xmpp/xmpp-im/xmpp_xdata.h
index 9689636..d8fd261 100644
--- a/src/xmpp/xmpp-im/xmpp_xdata.h
+++ b/src/xmpp/xmpp-im/xmpp_xdata.h
@@ -161,6 +161,7 @@ namespace XMPP {
 		typedef QList<Field> FieldList;
 
 		FieldList fields() const;
+		Field getField(const QString &var) const;
 		void setFields(const FieldList &);
 
 	private:
diff --git a/src/xmpp/xmpp.pri b/src/xmpp/xmpp.pri
index c7e161b..8742bf7 100644
--- a/src/xmpp/xmpp.pri
+++ b/src/xmpp/xmpp.pri
@@ -68,6 +68,7 @@ HEADERS += \
 	$$PWD/xmpp-im/xmpp_agentitem.h \
 	$$PWD/xmpp-im/xmpp_discoitem.h \
 	$$PWD/xmpp-im/xmpp_bitsofbinary.h \
+	$$PWD/xmpp-im/xmpp_caps.h \
 	$$PWD/xmpp-im/im.h
 
 SOURCES += \
@@ -95,4 +96,6 @@ SOURCES += \
 	$$PWD/xmpp-im/s5b.cpp \
 	$$PWD/xmpp-im/xmpp_ibb.cpp \
 	$$PWD/xmpp-im/filetransfer.cpp \
-	$$PWD/xmpp-im/xmpp_bitsofbinary.cpp
+	$$PWD/xmpp-im/xmpp_bitsofbinary.cpp \
+	$$PWD/xmpp-im/xmpp_caps.cpp
+
