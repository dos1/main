--- a/options/default.xml
+++ b/options/default.xml
@@ -225,6 +225,7 @@ QLineEdit#le_status_text {
                 <lockdown-roster type="bool">false</lockdown-roster>
                 <raise-on-new-event type="bool">false</raise-on-new-event>
                 <quit-on-close type="bool">false</quit-on-close>
+                <raise-inactive type="bool">true</raise-inactive>
                 <show-avatar-frame type="bool">false</show-avatar-frame>
                 <show>
                     <agent-contacts type="bool">true</agent-contacts>
--- a/src/common.cpp
+++ b/src/common.cpp
@@ -39,6 +39,8 @@
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/wait.h>
+
+#include "x11windowsystem.h"
 #endif
 
 #ifdef Q_OS_WIN
@@ -456,101 +458,6 @@ TabbableWidget* findActiveTab()
     return tw;
 }
 
-#ifdef HAVE_X11
-#include <X11/Xlib.h>
-#include <X11/Xutil.h> // needed for WM_CLASS hinting
-
-void x11wmClass(Display *dsp, WId wid, QString resName)
-{
-    if (!QX11Info::isPlatformX11())
-        return;
-
-    //Display *dsp = x11Display();                 // get the display
-    //WId win = winId();                           // get the window
-    XClassHint classhint;                          // class hints
-    // Get old class hint. It is important to save old class name
-    XGetClassHint(dsp, wid, &classhint);
-    XFree(classhint.res_name);
-
-    const QByteArray latinResName = resName.toLatin1();
-    classhint.res_name = (char *)latinResName.data(); // res_name
-    XSetClassHint(dsp, wid, &classhint);           // set the class hints
-
-    XFree(classhint.res_class);
-}
-
-//>>>-- Nathaniel Gray -- Caltech Computer Science ------>
-//>>>-- Mojave Project -- http://mojave.cs.caltech.edu -->
-// Copied from http://www.nedit.org/archives/discuss/2002-Aug/0386.html
-
-// Helper function
-bool getCardinal32Prop(Display *display, Window win, char *propName, long *value)
-{
-    if (!QX11Info::isPlatformX11())
-        return false;
-
-    Atom nameAtom, typeAtom, actual_type_return;
-    int actual_format_return, result;
-    unsigned long nitems_return, bytes_after_return;
-    long *result_array=NULL;
-
-    nameAtom = XInternAtom(display, propName, False);
-    typeAtom = XInternAtom(display, "CARDINAL", False);
-    if (nameAtom == None || typeAtom == None) {
-        //qDebug("Atoms not interned!");
-        return false;
-    }
-
-
-    // Try to get the property
-    result = XGetWindowProperty(display, win, nameAtom, 0, 1, False,
-        typeAtom, &actual_type_return, &actual_format_return,
-        &nitems_return, &bytes_after_return,
-        (unsigned char **)&result_array);
-
-    if( result != Success ) {
-        //qDebug("not Success");
-        return false;
-    }
-    if( actual_type_return == None || actual_format_return == 0 ) {
-        //qDebug("Prop not found");
-        return false;
-    }
-    if( actual_type_return != typeAtom ) {
-        //qDebug("Wrong type atom");
-    }
-    *value = result_array[0];
-    XFree(result_array);
-    return true;
-}
-
-
-// Get the desktop number that a window is on
-bool desktopOfWindow(Window *window, long *desktop)
-{
-    Display *display = QX11Info::display();
-    bool result = getCardinal32Prop(display, *window, (char *)"_NET_WM_DESKTOP", desktop);
-    //if( result )
-    //    qDebug("Desktop: " + QString::number(*desktop));
-    return result;
-}
-
-
-// Get the current desktop the WM is displaying
-bool currentDesktop(long *desktop)
-{
-    Window rootWin;
-    Display *display = QX11Info::display();
-    bool result;
-
-    rootWin = RootWindow(QX11Info::display(), XDefaultScreen(QX11Info::display()));
-    result = getCardinal32Prop(display, rootWin, (char *)"_NET_CURRENT_DESKTOP", desktop);
-    //if( result )
-    //    qDebug("Current Desktop: " + QString::number(*desktop));
-    return result;
-}
-#endif
-
 void clearMenu(QMenu *m)
 {
     m->clear();
@@ -579,7 +486,7 @@ void bringToFront(QWidget *widget, bool)
     // If we're not on the current desktop, do the hide/show trick
     long dsk, curr_dsk;
     Window win = w->winId();
-    if(desktopOfWindow(&win, &dsk) && currentDesktop(&curr_dsk)) {
+    if(X11WindowSystem::instance()->desktopOfWindow(&win, &dsk) && X11WindowSystem::instance()->currentDesktop(&curr_dsk)) {
         //qDebug() << "bringToFront current desktop=" << curr_dsk << " windowDesktop=" << dsk;
         if((dsk != curr_dsk) && (dsk != -1)) {  // second condition for sticky windows
             w->hide();
--- a/src/common.h
+++ b/src/common.h
@@ -151,12 +151,10 @@ void replaceWidget(QWidget *, QWidget *);
 void closeDialogs(QWidget *);
 TabbableWidget* findActiveTab();
 #ifdef HAVE_X11
-#include <QWidget>
-#include <QX11Info>
-void x11wmClass(Display *dsp, WId wid, QString resName);
-#define X11WM_CLASS(x)    x11wmClass(QX11Info::display(), winId(), (x));
+# include "x11windowsystem.h"
+# define X11WM_CLASS(x)    X11WindowSystem::instance()->x11wmClass(QX11Info::display(), winId(), (x));
 #else
-#define X11WM_CLASS(x)    /* dummy */
+# define X11WM_CLASS(x)    /* dummy */
 #endif
 void reorderGridLayout(QGridLayout* layout, int maxCols);
 int devicePixelRatio(QWidget *);
--- a/src/mainwin.cpp
+++ b/src/mainwin.cpp
@@ -79,6 +79,10 @@
 #include "rosteravatarframe.h"
 #include "avatars.h"
 
+#ifdef HAVE_X11
+#include <x11windowsystem.h>
+#endif
+
 using namespace XMPP;
 
 static const QString showStatusMessagesOptionPath = "options.ui.contactlist.status-messages.show";
@@ -154,6 +158,10 @@ public:
 
     PsiRosterWidget* rosterWidget_;
 
+#ifdef Q_OS_WIN
+    DWORD deactivationTickCount;
+#endif
+
     void registerActions();
     IconAction* getAction( QString name );
     void updateMenu(QStringList actions, QMenu* menu);
@@ -1416,6 +1424,22 @@ void MainWin::closeEvent(QCloseEvent* e)
 
 void MainWin::changeEvent(QEvent *event)
 {
+#ifdef Q_OS_WIN
+    if (event->type() == QEvent::ActivationChange
+        && PsiOptions::instance()->getOption("options.ui.systemtray.enable").toBool()
+        && PsiOptions::instance()->getOption("options.ui.contactlist.raise-inactive").toBool()) {
+        //On Windows app window loose active state when you
+        //  click on tray icon. Workaround is to use timer:
+        //  we'll keep activated == true within 300 msec
+        //  (+ doubleClickInterval, if double click is enabled)
+        //  after deactivation.
+        if (!isActiveWindow())
+        {
+            d->deactivationTickCount = GetTickCount();
+        }
+    }
+#endif
+
     if (event->type() == QEvent::ActivationChange ||
         event->type() == QEvent::WindowStateChange)
     {
@@ -1536,14 +1560,37 @@ void MainWin::optionsUpdate()
     updateTray();
 }
 
-void MainWin::toggleVisible()
+void MainWin::toggleVisible(bool fromTray)
 {
-    if(!isHidden()) {
-        trayHide();
-    }
-    else {
-        trayShow();
+    if (PsiOptions::instance()->getOption("options.ui.contactlist.raise-inactive").toBool())
+    {
+        bool hidden = false;
+#ifdef Q_OS_WIN
+        if (fromTray) {
+            int timeout = 300;
+            if (PsiOptions::instance()->getOption("options.ui.systemtray.use-double-click").toBool())
+                timeout += qApp->doubleClickInterval();
+            hidden = isHidden() || (GetTickCount() - d->deactivationTickCount > timeout);
+        }
+        else {
+            hidden = isHidden() || !isActiveWindow();
+        }
+#elif defined(HAVE_X11)
+        Q_UNUSED(fromTray);
+        hidden = isHidden() || X11WindowSystem::instance()->isWindowObscured(this, PsiOptions::instance()->getOption("options.ui.contactlist.always-on-top").toBool());
+#else
+        Q_UNUSED(fromTray);
+        hidden = isHidden() || !isActiveWindow();
+#endif
+        if(hidden) {
+            trayShow();
+        }
+        else {
+            trayHide();
+        }
     }
+    else
+        isHidden() ? trayShow() : trayHide();
 }
 
 void MainWin::setTrayToolTip(const Status& status, bool, bool)
@@ -1567,32 +1614,21 @@ void MainWin::trayClicked(const QPoint &, int button)
         return;
     }
 
-    if(!isHidden()) {
-        trayHide();
-    }
-    else {
-        trayShow();
-    }
+    toggleVisible(true);
 }
 
 void MainWin::trayDoubleClicked()
 {
-    if(!PsiOptions::instance()->getOption("options.ui.systemtray.use-double-click").toBool()) {
-        return;
-    }
+    //Double click works like second single click now if "double-click" style is disabled
 
-    if(d->nextAmount > 0) {
-        doRecvNextEvent();
-        return;
+    if(PsiOptions::instance()->getOption("options.ui.systemtray.use-double-click").toBool()) {
+        if(d->nextAmount > 0) {
+            doRecvNextEvent();
+            return;
+        }
     }
 
-
-    if(!isHidden()) {
-        trayHide();
-    }
-    else {
-        trayShow();
-    }
+    toggleVisible(true);
 }
 
 void MainWin::trayShow()
--- a/src/mainwin.h
+++ b/src/mainwin.h
@@ -178,7 +178,7 @@ public slots:
     void optionsUpdate();
     void setTrayToolTip(const XMPP::Status &, bool usePriority = false, bool isManualStatus = false);
 
-    void toggleVisible();
+    void toggleVisible(bool fromTray = false);
 
     void avcallConfig();
 
--- a/src/src.pri
+++ b/src/src.pri
@@ -613,6 +613,10 @@ win32:!dbus {
     LIBS += -lUser32
 }
 
+unix:!macx:!haiku {
+    HEADERS += $$PWD/x11windowsystem.h
+    SOURCES += $$PWD/x11windowsystem.cpp
+}
 
 unix:!dbus {
     SOURCES += $$PWD/activeprofiles_stub.cpp
--- /dev/null
+++ b/src/x11windowsystem.cpp
@@ -0,0 +1,314 @@
+#include "x11windowsystem.h"
+
+#include <QX11Info>
+#include <X11/Xlib.h>
+#include <X11/Xutil.h> // needed for WM_CLASS hinting
+
+const long MAX_PROP_SIZE = 100000;
+X11WindowSystem* X11WindowSystem::_instance = 0;
+
+
+void X11WindowSystem::x11wmClass(Display *dsp, WId wid, QString resName)
+{
+    if (!QX11Info::isPlatformX11())
+        return;
+
+    //Display *dsp = x11Display();                 // get the display
+    //WId win = winId();                           // get the window
+    XClassHint classhint;                          // class hints
+    // Get old class hint. It is important to save old class name
+    XGetClassHint(dsp, wid, &classhint);
+    XFree(classhint.res_name);
+
+    const QByteArray latinResName = resName.toLatin1();
+    classhint.res_name = (char *)latinResName.data(); // res_name
+    XSetClassHint(dsp, wid, &classhint);           // set the class hints
+
+    XFree(classhint.res_class);
+}
+
+//>>>-- Nathaniel Gray -- Caltech Computer Science ------>
+//>>>-- Mojave Project -- http://mojave.cs.caltech.edu -->
+// Copied from http://www.nedit.org/archives/discuss/2002-Aug/0386.html
+
+// Helper function
+static bool getCardinal32Prop(Display *display, Window win, char *propName, long *value)
+{
+    if (!QX11Info::isPlatformX11())
+        return false;
+
+    Atom nameAtom, typeAtom, actual_type_return;
+    int actual_format_return, result;
+    unsigned long nitems_return, bytes_after_return;
+    long *result_array=NULL;
+
+    nameAtom = XInternAtom(display, propName, False);
+    typeAtom = XInternAtom(display, "CARDINAL", False);
+    if (nameAtom == None || typeAtom == None) {
+        //qDebug("Atoms not interned!");
+        return false;
+    }
+
+
+    // Try to get the property
+    result = XGetWindowProperty(display, win, nameAtom, 0, 1, False,
+        typeAtom, &actual_type_return, &actual_format_return,
+        &nitems_return, &bytes_after_return,
+        (unsigned char **)&result_array);
+
+    if( result != Success ) {
+        //qDebug("not Success");
+        return false;
+    }
+    if( actual_type_return == None || actual_format_return == 0 ) {
+        //qDebug("Prop not found");
+        return false;
+    }
+    if( actual_type_return != typeAtom ) {
+        //qDebug("Wrong type atom");
+    }
+    *value = result_array[0];
+    XFree(result_array);
+    return true;
+}
+
+
+// Get the desktop number that a window is on
+bool X11WindowSystem::desktopOfWindow(Window *window, long *desktop)
+{
+    Display *display = QX11Info::display();
+    bool result = getCardinal32Prop(display, *window, (char *)"_NET_WM_DESKTOP", desktop);
+    //if( result )
+    //    qDebug("Desktop: " + QString::number(*desktop));
+    return result;
+}
+
+
+// Get the current desktop the WM is displaying
+bool X11WindowSystem::currentDesktop(long *desktop)
+{
+    Window rootWin;
+    Display *display = QX11Info::display();
+    bool result;
+
+    rootWin = RootWindow(QX11Info::display(), XDefaultScreen(QX11Info::display()));
+    result = getCardinal32Prop(display, rootWin, (char *)"_NET_CURRENT_DESKTOP", desktop);
+    //if( result )
+    //    qDebug("Current Desktop: " + QString::number(*desktop));
+    return result;
+}
+
+X11WindowSystem::X11WindowSystem()
+{
+    const int atomsCount = 10;
+    const char* names[atomsCount] = {
+        "_NET_CLIENT_LIST_STACKING",
+        "_NET_FRAME_EXTENTS",
+
+        "_NET_WM_WINDOW_TYPE",
+        "_NET_WM_WINDOW_TYPE_NORMAL",
+        "_NET_WM_WINDOW_TYPE_DIALOG",
+        "_NET_WM_WINDOW_TYPE_UTILITY",
+        "_NET_WM_WINDOW_TYPE_SPLASH",
+
+        "_NET_WM_STATE",
+        "_NET_WM_STATE_ABOVE",
+        "_NET_WM_STATE_HIDDEN"
+    };
+    Atom atoms[atomsCount], *atomsp[atomsCount] = {
+        &net_client_list_stacking,
+        &net_frame_extents,
+
+        &net_wm_window_type,
+        &net_wm_window_type_normal,
+        &net_wm_window_type_dialog,
+        &net_wm_window_type_utility,
+        &net_wm_window_type_splash,
+
+        &net_wm_state,
+        &net_wm_state_above,
+        &net_wm_state_hidden
+    };
+    int i = atomsCount;
+    while (i--)
+        atoms[i] = 0;
+
+    XInternAtoms(QX11Info::display(), (char**)names, atomsCount, true, atoms);
+
+    i = atomsCount;
+    while (i--)
+        *atomsp[i] = atoms[i];
+
+    if (net_wm_window_type_normal != None)
+        normalWindows.insert(net_wm_window_type_normal);
+    if (net_wm_window_type_dialog != None)
+        normalWindows.insert(net_wm_window_type_dialog);
+    if (net_wm_window_type_utility != None)
+        normalWindows.insert(net_wm_window_type_utility);
+    if (net_wm_window_type_splash != None)
+        normalWindows.insert(net_wm_window_type_splash);
+
+    if (net_wm_state_hidden != None)
+        ignoredWindowStates.insert(net_wm_state_hidden);
+}
+
+X11WindowSystem* X11WindowSystem::instance()
+{
+    if (!_instance)
+        _instance = new X11WindowSystem();
+    return X11WindowSystem::_instance;
+}
+
+// Get window coords relative to desktop window
+QRect X11WindowSystem::windowRect(Window win)
+{
+    Window w_unused;
+    int x, y;
+    unsigned int w, h, junk;
+    XGetGeometry(QX11Info::display(), win, &w_unused, &x, &y, &w, &h, &junk, &junk);
+    XTranslateCoordinates(QX11Info::display(), win, QX11Info::appRootWindow(), 0, 0, &x, &y, &w_unused);
+
+    Atom type_ret;
+    int format_ret;
+    unsigned char *data_ret;
+    unsigned long nitems_ret, unused;
+    const Atom XA_CARDINAL = (Atom) 6;
+    if (net_frame_extents != None && XGetWindowProperty(QX11Info::display(), win, net_frame_extents,
+                                                        0l, 4l, False, XA_CARDINAL, &type_ret, &format_ret,
+                                                        &nitems_ret, &unused, &data_ret) == Success)
+    {
+        if (type_ret == XA_CARDINAL && format_ret == 32 && nitems_ret == 4) {
+            //Struts array: 0 - left, 1 - right, 2 - top, 3 - bottom
+            long *d = (long *) data_ret;
+            x -= d[0];
+            y -= d[2];
+            w += d[0] + d[1];
+            h += d[2] + d[3];
+        }
+        if ( data_ret )
+            XFree(data_ret);
+    }
+
+    return QRect(x, y, w, h);
+}
+
+// Determine if window is obscured by other windows
+bool X11WindowSystem::isWindowObscured(QWidget *widget, bool alwaysOnTop)
+{
+    if (net_wm_state_above != None)
+    {
+        if (!alwaysOnTop)
+            ignoredWindowStates.insert(net_wm_state_above);
+        else
+            ignoredWindowStates.remove(net_wm_state_above);
+    }
+
+    //TODO Is it correct to use QX11Info::appRootWindow() as root window?
+    Q_ASSERT(widget);
+    QWidget* w = widget->window();
+    Window win = w->winId();
+    long desktop;
+    desktopOfWindow(&win, &desktop);
+
+    const Atom XA_WINDOW= (Atom) 33;
+    Atom type_ret;
+    int format_ret;
+    unsigned char *data_ret;
+    unsigned long nitems_ret, unused;
+
+    if (net_client_list_stacking != None)
+    {
+        QRect winRect = windowRect(win);
+        if (XGetWindowProperty(QX11Info::display(), QX11Info::appRootWindow(), net_client_list_stacking,
+                       0, MAX_PROP_SIZE, False, XA_WINDOW, &type_ret,
+                       &format_ret, &nitems_ret, &unused, &data_ret) == Success) {
+            if (type_ret == XA_WINDOW && format_ret == 32) {
+                Window *wins = (Window *) data_ret;
+
+                //Enumerate windows in reverse order (from most foreground window)
+                while (nitems_ret--)
+                {
+                    Window current = wins[nitems_ret];
+
+                    long winDesktop;
+                    desktopOfWindow(&current, &winDesktop);
+                    if (desktop != winDesktop)
+                        continue;
+
+                    //We are not interested in underlying windows
+                    if (current == win)
+                        break;
+
+                    //If our window in not alwaysOnTop ignore such windows, because we can't raise on top of them
+                    if (windowHasAnyOfStates(current, ignoredWindowStates))
+                        continue;
+
+                    if (!windowHasOnlyTypes(current, normalWindows))
+                        continue;
+
+                    QRect rect = windowRect(current);
+                    if (winRect.intersects(rect))
+                        return true;
+                }
+            }
+            if (data_ret)
+                XFree(data_ret);
+        }
+    }
+    return false;
+}
+
+//If window has any type other than allowed_types return false, else return true
+bool X11WindowSystem::windowHasOnlyTypes(Window win, const QSet<Atom> &allowedTypes)
+{
+    const Atom XA_ATOM = (Atom) 4;
+    Atom type_ret;
+    int format_ret;
+    unsigned char *data_ret;
+    unsigned long nitems_ret, unused;
+
+    if (net_wm_window_type != None && XGetWindowProperty(QX11Info::display(), win, net_wm_window_type,
+                                                         0l, 2048l, False, XA_ATOM, &type_ret,
+                                                         &format_ret, &nitems_ret, &unused, &data_ret) == Success) {
+        if (type_ret == XA_ATOM && format_ret == 32 && nitems_ret > 0) {
+            Atom *types = (Atom *) data_ret;
+            for (unsigned long i = 0; i < nitems_ret; i++)
+            {
+                if (!allowedTypes.contains(types[i]))
+                {
+                    return false;
+                }
+            }
+        }
+        if (data_ret)
+            XFree(data_ret);
+        return true;
+    }
+    else
+        return false;
+}
+
+//If window has any of filteredStates return
+bool X11WindowSystem::windowHasAnyOfStates(Window win, const QSet<Atom> &filteredStates)
+{
+    const Atom XA_ATOM = (Atom) 4;
+    Atom type_ret;
+    int format_ret;
+    unsigned char *data_ret;
+    unsigned long nitems_ret, unused;
+    if (net_wm_state != None && XGetWindowProperty(QX11Info::display(), win, net_wm_state, 0l, 2048l,
+                                                   False, XA_ATOM, &type_ret, &format_ret,
+                                                   &nitems_ret, &unused, &data_ret) == Success) {
+        if (type_ret == XA_ATOM && format_ret == 32 && nitems_ret > 0) {
+            Atom *states = (Atom *) data_ret;
+            for (unsigned long i = 0; i < nitems_ret; i++) {
+
+                if (filteredStates.contains(states[i]))
+                    return true;
+            }
+        }
+        if ( data_ret )
+            XFree(data_ret);
+    }
+    return false;
+}
--- /dev/null
+++ b/src/x11windowsystem.h
@@ -0,0 +1,48 @@
+#ifndef X11WINDOWSYSTEM_H
+#define X11WINDOWSYSTEM_H
+
+#include <QtCore>
+#include <QWidget>
+#include <QRect>
+#include <QSet>
+#include <QX11Info>
+
+//TODO: Find a way to include Xlib here and not redefine Atom and Window types
+typedef unsigned long Atom;
+typedef unsigned long Window;
+
+class X11WindowSystem {
+private:
+    Atom net_client_list_stacking;
+    Atom net_frame_extents;
+
+    Atom net_wm_window_type;
+    Atom net_wm_window_type_normal;
+    Atom net_wm_window_type_dialog;
+    Atom net_wm_window_type_utility;
+    Atom net_wm_window_type_splash;
+
+    Atom net_wm_state;
+    Atom net_wm_state_above;
+    Atom net_wm_state_hidden;
+
+    QSet<Atom> normalWindows, ignoredWindowStates;
+
+    static X11WindowSystem* _instance;
+    X11WindowSystem();
+    ~X11WindowSystem() {}
+    X11WindowSystem(const X11WindowSystem& ) {};
+    X11WindowSystem & operator=(const X11WindowSystem &) {return *this;};
+
+public:
+    static X11WindowSystem* instance();
+    QRect windowRect(Window win);
+    bool isWindowObscured(QWidget *widget, bool alwaysOnTop);
+    bool windowHasOnlyTypes(Window win, const QSet<Atom> &allowedTypes);
+    bool windowHasAnyOfStates(Window win, const QSet<Atom> &filteredStates);
+    bool currentDesktop(long *desktop);
+    bool desktopOfWindow(Window *window, long *desktop);
+    void x11wmClass(Display *dsp, WId wid, QString resName);
+};
+
+#endif // X11WINDOWSYSTEM_H
