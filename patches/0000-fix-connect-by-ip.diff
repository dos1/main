--- a/iris/iris.pri
+++ b/iris/iris.pri
@@ -2,7 +2,10 @@ IRIS_BASE = $$PWD
 include(common.pri)
 
 CONFIG *= link_prl # doesn't seems to work but at least it's documented unlike dependp_prl
-unix:PRE_TARGETDEPS += $$top_iris_builddir/lib/libiris.a # most of devs are on Linux anyway
+unix {  # most of devs are on Linux anyway
+	PRE_TARGETDEPS += $$top_iris_builddir/lib/libiris.a
+	PRE_TARGETDEPS += $$top_iris_builddir/lib/libirisnet.a
+}
 
 INCLUDEPATH += $$IRIS_BASE/include $$IRIS_BASE/include/iris $$IRIS_BASE/src
 
--- a/iris/src/irisnet/corelib/netinterface_qtname.cpp
+++ b/iris/src/irisnet/corelib/netinterface_qtname.cpp
@@ -63,12 +63,24 @@ public:
 	int resolve_start(const QByteArray &name, int qType, bool longLived)
 	{
 		Q_UNUSED(longLived); // FIXME handle local like in jdns name provider
-		QDnsLookup *lookup = new QDnsLookup((QDnsLookup::Type)qType, QString::fromLatin1(name), this);
-		connect(lookup, SIGNAL(finished()), this, SLOT(handleLookup()));
-		int id = currentId++;
-		lookup->setProperty("iid", id);
-		lookups.insert(id, lookup);
-		QMetaObject::invokeMethod(lookup, "lookup", Qt::QueuedConnection);
+        int id = currentId++;
+
+        // check if it's A/AAAA. QDnsLookup fails to handle this in some cases.
+        QHostAddress addr(QString::fromLatin1(name));
+        if (!addr.isNull()) {
+            QList<XMPP::NameRecord> results;
+            XMPP::NameRecord r;
+            r.setAddress(addr);
+            results.append(r);
+            QMetaObject::invokeMethod(this, "resolve_resultsReady", Qt::QueuedConnection,
+                                      Q_ARG(int, id), Q_ARG(QList<XMPP::NameRecord>, results));
+        } else {
+            QDnsLookup *lookup = new QDnsLookup((QDnsLookup::Type)qType, QString::fromLatin1(name), this);
+            connect(lookup, SIGNAL(finished()), this, SLOT(handleLookup()));
+            lookup->setProperty("iid", id);
+            lookups.insert(id, lookup);
+            QMetaObject::invokeMethod(lookup, "lookup", Qt::QueuedConnection);
+        }
 		return id;
 	}
 
--- a/iris/src/irisnet/noncore/cutestuff/bsocket.cpp
+++ b/iris/src/irisnet/noncore/cutestuff/bsocket.cpp
@@ -183,17 +183,26 @@ public:
 		this->domain = host;
 		this->port = port;
 		SockData &sd = addSocket();
-		sd.resolver = new XMPP::ServiceResolver;
-		initResolver(sd.resolver);
-		sd.resolver->setProtocol(protocol == QAbstractSocket::UnknownNetworkLayerProtocol?
-			(fallbackProtocol == QAbstractSocket::IPv4Protocol? XMPP::ServiceResolver::IPv6 : XMPP::ServiceResolver::IPv4) :
-			(protocol== QAbstractSocket::IPv4Protocol? XMPP::ServiceResolver::IPv4 : XMPP::ServiceResolver::IPv6));
-		if (protocol == QAbstractSocket::UnknownNetworkLayerProtocol) {
-			addSocket();
-			fallbackTimer.start();
-		}
-		sd.state = Resolve;
-		sd.resolver->start(domain, port);
+
+        QHostAddress addr(host);
+        if (addr.isNull()) {
+            sd.resolver = new XMPP::ServiceResolver;
+            initResolver(sd.resolver);
+            sd.resolver->setProtocol(protocol == QAbstractSocket::UnknownNetworkLayerProtocol?
+                (fallbackProtocol == QAbstractSocket::IPv4Protocol? XMPP::ServiceResolver::IPv6 : XMPP::ServiceResolver::IPv4) :
+                (protocol== QAbstractSocket::IPv4Protocol? XMPP::ServiceResolver::IPv4 : XMPP::ServiceResolver::IPv6));
+            if (protocol == QAbstractSocket::UnknownNetworkLayerProtocol) {
+                addSocket();
+                fallbackTimer.start();
+            }
+            sd.state = Resolve;
+            sd.resolver->start(domain, port);
+        } else {
+            // connecting by IP.
+            lastIndex = sockets.count() - 1;
+            sd.state = Connecting;
+            sd.sock->connectToHost(addr, port);
+        }
 	}
 
 	void connectToHost(const QString &service, const QString &transport, const QString &domain, quint16 port)
